
  (function(win, doc) {//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\modules/ib.js
/*!
 * ibjs.js 0.358.0
 * IBLEADERS_LIB: ibjs ALPHA
 * AUTHOR: park hyun-jin
 */

(function(window, _ib) {
    var ib, doc, push, slice, splice, _define;
    if (typeof _ib === "function" && _ib.VERSION) {return false;}
    ib = function(selector, context, rootObj) {
        return new ib.fn.init(selector, context, rootObj);
    };
    ib.VERSION = 20131211;
    ib.selectorExp = /(?:\#([\w-]+)|\.([\w-]+)|([\w]+|\*)|[\w\W]+(\,)[\w\W]+|([\w-\*]*\[[\w-]+\=?[\w\W]+\]))$/;
    ib.selectorAttrExp = /^(?:([\#\.]?[\w-\*]+)\[([\w-]+)\=?([\w\W]*)\])$/;
    ib.isHtml = /^<[\w\W]+>$/;
    ib.isSingleTag = /^\<(\w+)\s*\/?\>(\<\/\w+\>|)$/;
    ib.array = [];
    push = ib.arrayPush = ib.array.push;
    slice = ib.arraySlice = ib.array.slice;
    splice = ib.arraySplice = ib.array.splice;
    ib.arrayIndexOf = ib.array.indexOf;
    ib.arrayConcat = ib.array.concat;
    ib.arraySort = ib.array.sort;
    ib.splitExp = /[\s,]+/;
    ib.unitSplitExp = /^([+|-]?[0-9]*[\.]*[0-9]*)(cm|mm|in|px|pt|pc)?$/;
    ib.offsetGap = /^[+|-]?[0-9]*[\.]*[0-9]*/;
    doc = window.document;
    function elementSelect(selector, _context, __ib) {
        var eles, i, j, len;
        eles = ib.selector_a(selector, _context, []);
        if (eles) {
            i = __ib.length || 0;
            for (j = 0, len = eles.length; j < len; ++j) {
                __ib[i++] = eles[j];
            }
            __ib.length = i;
        }
    }
    function wrapper(fn, context) {
        var selector;
        if (ib.isFunction(fn)) {
            selector = fn();
            return ib(selector, context, this);
        }
    }
    ib.fn = ib.prototype = {
        init: function(selector, context, refer) {
            var self = this, ele, match, attr, z;
            if (!selector) return;
            if (typeof selector === "string") {
                if (ib.isHtml.test(selector)) {
                    ele = ib.string2html(selector);
                    if (ib.isPureObject(context)) {
                        for (attr in context) {
                            if (context.hasOwnProperty(attr)) {
                                self.attribute(attr, context[attr], ele[0]);
                            }
                        }
                    }
                    if (ele) {
                        ib.Object.merge(self, ele);
                        self.length = ele.length;
                    }
                } else if (match = ib.selectorExp.exec(selector)) {
                    if (match[1]) {
                        if (ele = document.getElementById(match[1])) {
                            self[0] = ele;
                            ele = null;
                            self.length = 1;
                        } else {
                            self.length = 0;
                        }
                    } else {
                        elementSelect(selector, context || doc, self);
                    }
                }
            } else if (typeof selector === "function") {
                return self.ready(selector);
            } else if (selector && ib.type(selector.length) === "number") {
                if (ib.isWindow(selector) || selector.nodeType) {
                    self[0] = selector;
                    self.length = 1;
                } else {
                    for (z = 0; ele = selector[z]; z++) {
                        if (ib.isDomNode(ele) || ib.isWindow(ele)) {
                            self[z] = ele;
                        }
                    }
                    self.length = z;
                }
            } else {
                self[0] = selector;
                self.length = 1;
            }
            self.context = context || doc;
            self.refer = refer;
            return self;
        },
        wrapper: wrapper,
        push: ib.arrayPush,
        concat: ib.arrayConcat,
        indexOf: ib.arrayIndexOf,
        splice: ib.arraySplice,
        slice: ib.arraySlice,
        sort: ib.arraySort
    };
    ib.fn.init.prototype = ib.fn;
    ib.addMixin = ib.fn.addMixin = function(mixin) {
        mixin.call(this);
    };
    ib.fn.addMixin(function() {
        var context = this;
        context.ready = function(fn) {
            var isReady = false, callback = fn, top;
            function DOMContentLoaded() {
                if (doc.addEventListener) {
                    doc.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                    wait();
                } else {
                    if (doc.readyState === "complete") {
                        doc.detachEvent("onreadystatechange", DOMContentLoaded);
                        wait();
                    }
                }
            }
            function wait() {
                if (!isReady && doc.body) {
                    callback();
                    isReady = true;
                }
            }
            if (doc.addEventListener) {
                doc.addEventListener("DOMContentLoaded", DOMContentLoaded, false);
            } else {
                doc.attachEvent("onreadystatechange", DOMContentLoaded);
                top = false;
                try {
                    top = window.frameElement === null && doc.documentElement;
                } catch (e) {}
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!isReady) {
                            try {
                                top.doScroll("left");
                            } catch (e) {
                                return setTimeout(doScrollCheck, 20);
                            }
                            wait();
                        }
                    })();
                }
            }
        };
        context.get = function(index) {
            return this[index];
        };
        context.index = function(item) {
            return ib.Array([]).indexOf.call({
                array: this
            }, item);
        };
        context.toArray = function() {
            return ib.arraySlice.call(this);
        };
    });
    ib.window = window;
    if ((_define = window.define) && "function" === typeof _define && _define.amd) {
        _define([], function() {
            return window.ib = window._ib = ib;
        });
    } else {
        window.ib = window._ib = ib;
    }
    ib.addMixin(function() {
        var context = this, w = ib.window, typeMap = {
            "[object object]": "object",
            "[object function]": "function",
            "[object array]": "array",
            "[object date]": "date",
            "[object regexp]": "regexp",
            "[object error]": "error",
            "[object null]": "null",
            "[object string]": "string",
            "[object number]": "number",
            "[object boolean]": "boolean",
            "[object nodelist]": "object"
        };
        context.type = function(obj) {
            if (obj === null) {
                return "" + obj;
            } else {
                return typeof obj === "object" || typeof obj === "function" ? typeMap[Object.prototype.toString.call(obj).toLowerCase()] || "object" : typeof obj;
            }
        };
        context.isWindow = function(obj) {
            return ib.isObject(obj) ? ib.window === obj || ib.window == obj.top : false;
        };
        context.isDomNode = function(obj) {
            return ib.isObject(obj) ? w.Node ? obj instanceof Node : typeof obj.nodeType === "number" && typeof obj.nodeName === "string" : false;
        };
        context.isDocument = function(obj) {
            return ib.isObject(obj) ? obj.nodeType === 9 && obj.nodeName === "#document" : false;
        };
        context.isDomFragNode = function(obj) {
            return ib.isObject(obj) ? obj.nodeType === 11 : false;
        };
        context.isElement = function(obj) {
            return ib.isObject(obj) ? obj.nodeType === 1 && typeof obj.nodeName === "string" : false;
        };
        context.isObject = function(obj) {
            return obj ? context.type(obj) === "object" : false;
        };
        var isPureObject = function(obj) {
            var e;
            for (e in obj) {}
            return e === undefined || obj.hasOwnProperty && obj.hasOwnProperty(e);
        };
        context.isPureObject = function(obj) {
            return context.isObject(obj) && isPureObject(obj) ? true : false;
        };
        context.isEmptyObject = function(obj) {
            return context.isObject(obj) && function() {
                var e;
                for (e in obj) {
                    return false;
                }
                return true;
            }();
        };
        context.isFunction = function(obj) {
            return typeof obj === "function";
        };
        context.isArray = Array.isArray || function(obj) {
            return obj ? context.type(obj) === "array" : false;
        };
        context.isString = function(obj) {
            return typeof obj === "string";
        };
        context.isNumber = function(obj) {
            return !context.isNaN(obj) && typeof obj === "number";
        };
        context.isInteger = function(obj) {
            return context.isNumber(obj) && obj % 1 === 0;
        };
        context.isFloat = function(obj) {
            return context.isNumber(obj) && obj % 1 !== 0;
        };
        context.isBoolean = function(obj) {
            return typeof obj === "boolean";
        };
        context.isNull = function(obj) {
            return obj === null;
        };
        context.isUndefined = function(obj) {
            return typeof obj === "undefined";
        };
        context.isNaN = function(obj) {
            return typeof obj === "number" && isNaN(obj);
        };
        context.isNativeCode = context.isNativeFn = function(fn) {
            return /\{\s*\[native code\]\s*\}/i.test(fn);
        };
        var rNot = /^not/;
        context.typeChecker = function(values) {
            var args, format, type, value, fn, isis, result, i, iLen, j, jLen;
            args = arguments;
            for (i = 1, iLen = args.length; i < iLen; ++i) {
                format = args[i];
                result = false;
                if ((args[0].length || 1) === format.length) {
                    for (j = 0, jLen = format.length; j < jLen; ++j) {
                        type = format[j];
                        value = values[j];
                        if (rNot.test(type)) {
                            isis = false;
                            type = type.replace(rNot, "");
                        } else {
                            isis = true;
                        }
                        fn = context["is" + context.String.capitalize(type)];
                        result = fn ? fn(value) ? true : false : false;
                        result = isis ? result : !result;
                        if (!result) {
                            break;
                        }
                    }
                }
                if (result) {
                    return result;
                }
            }
            return result;
        };
    });
    ib.addMixin(function() {
        var context = this, array = [], arraySlice = array.slice, support = {
            __proto__: function() {
                return "__proto__" in {};
            }(),
            objectDefineProperty: function() {
                try {
                    Object.defineProperty({}, "msg", {
                        enumerable: false,
                        writable: false,
                        value: "hi"
                    });
                } catch (e) {
                    return false;
                }
                return true;
            }()
        }, _objectCreate = Object.create || function() {
            function F() {}
            return function(o) {
                if (arguments.length != 1) {
                    throw new Error("Object.create implementation only accepts one parameter.");
                }
                F.prototype = o;
                return new F();
            };
        }(), objectGetPrototypeOf = Object.getPrototypeOf || function(obj) {
            return obj.__proto__ || null;
        }, objectProtoDefinder = function() {
            return support.objectDefineProperty ? function(object, link, value) {
                Object.defineProperty(object, "__proto__", {
                    enumerable: false,
                    writable: false,
                    value: link
                });
            } : function(object, link, value) {
                object.__proto__ = link;
            };
        }(), Class = {
            extend: function(link) {
                var self = this, base, basePrototype, e, prop, group;
                base = objectCreate(self, true);
                for (e in link) {
                    prop = link[e];
                    if (ib.isObject(prop)) {
                        group = base[e] = {};
                        mixin.call(group, self[e], prop);
                    } else {
                        base[e] = prop;
                    }
                }
                return base;
            }
        }, Classes;
        function objectCreate(link) {
            var object = _objectCreate(link);
            if (!support.__proto__) {
                objectProtoDefinder(object, link);
            }
            return object;
        }
        function objectDefineProperties(target, object) {
            var base, desc, e, d;
            if (support.objectDefineProperty) {
                base = target || {};
                for (e in object) {
                    d = {};
                    desc = object[e];
                    if (ib.isObject(desc) && (desc.value != null ? desc.configurable != null || desc.enumerable != null || desc.writable != null ? true : false : true)) {
                        if (desc.hasOwnProperty("configurable")) {
                            d.configurable = !!desc.configurable;
                        }
                        if (desc.hasOwnProperty("enumerable")) {
                            d.enumerable = !!desc.enumerable;
                        }
                        if (desc.hasOwnProperty("writable")) {
                            d.writable = !!desc.writable;
                        }
                        if (desc.hasOwnProperty("value")) {
                            d.value = desc.value;
                        }
                        if (desc.hasOwnProperty("get") && ib.isFunction(desc.get)) {
                            d.get = desc.get;
                        }
                        if (desc.hasOwnProperty("set") && ib.isFunction(desc.set)) {
                            d.set = desc.set;
                        }
                        if (("get" in d || "set" in d) && ("writable" in d || "value" in d)) {
                            throw new Error("TypeError: Invalid property. A property cannot both have accessors and be writable or have a value");
                        }
                        if (ib.isEmptyObject(d)) {
                            d.value = desc;
                            d.configurable = true;
                            d.enumerable = true;
                            d.writable = true;
                        }
                    } else {
                        d.value = desc;
                        d.configurable = true;
                        d.enumerable = true;
                        d.writable = true;
                    }
                    Object.defineProperty(base, e, d);
                }
            }
            return base;
        }
        function objectMake(link) {
            var object = objectCreate(link);
            if (link.hasOwnProperty("init")) {
                object.init.apply(object, arraySlice.call(arguments, 1));
            }
            return object;
        }
        function mixin(baseProto, prop) {
            var e;
            for (e in baseProto) {
                this[e] = baseProto[e];
            }
            if (prop) {
                for (e in prop) {
                    this[e] = prop[e];
                }
            }
            return this;
        }
        function merge() {
            var source = arguments[0], from, objectOverride, len = arguments.length, i = 1, e, sData, fData;
            if (ib.isBoolean(source)) {
                objectOverride = source;
                source = arguments[i];
                i++;
            }
            source = source || {};
            for (;i < len; i++) {
                from = arguments[i];
                for (e in from) {
                    if (from.hasOwnProperty(e)) {
                        sData = source[e];
                        fData = from[e];
                        if (objectOverride && fData && ib.isPureObject(fData)) {
                            source[e] = merge(objectOverride, ib.isPureObject(sData) ? sData : {}, fData);
                        } else if (!ib.isUndefined(fData)) {
                            if (ib.isArray(sData) && ib.isArray(fData) && !objectOverride) {
                                source[e] = sData.concat(fData);
                            } else {
                                source[e] = fData;
                            }
                        }
                    }
                }
            }
            return source;
        }
        context.Object = {
            merge: merge,
            define: function(object) {
                return objectCreate(objectDefineProperties(undefined, object));
            },
            defineProperties: objectDefineProperties,
            make: objectMake,
            getPrototypeOf: objectGetPrototypeOf
        };
        context.Class = Class;
        if (support.objectDefineProperty) {
            Classes = context.Classes = {
                define: function(src, object) {
                    var i, len, c;
                    src = src.split(/\./g);
                    c = Classes;
                    for (i = 0, len = src.length; i < len; ++i) {
                        if (c[src[i]] == null) {
                            Classes._define(c, src[i], object);
                        }
                        c = c[src[i]];
                    }
                    return object;
                },
                _define: function(c, name, value) {
                    var obj = {};
                    obj[name] = {
                        get: function() {
                            return value;
                        }
                    };
                    ib.Object.defineProperties(c, obj);
                }
            };
        }
    });
    ib.addMixin(function() {
        var context = this, array, slice = ib.arraySlice;
        (array = function(arr) {
            this.array = ib.isArray(arr) ? arr : arr != null ? [ arr ] : [];
        }).prototype = {
            unique: function(isAssert) {
                var array = this.array, temp = [], i, len, j;
                if (isAssert) {
                    for (i = 0, len = array.length; i < len; ++i) {
                        for (j = i + 1; j < len; ++j) {
                            if (array[i] === array[j]) {
                                array.splice(j, 1);
                                --len;
                                --j;
                            }
                        }
                    }
                    return array;
                } else {
                    for (i = 0, len = array.length; i < len; ++i) {
                        for (j = i + 1; j < len; ++j) {
                            if (array[i] === array[j]) {
                                j = ++i;
                            }
                        }
                        temp.push(array[i]);
                    }
                    this.array = temp;
                    return temp;
                }
            },
            indexOf: Array.prototype.indexOf ? function(item, from) {
                return Array.prototype.indexOf.call(this.array, item, from);
            } : function(item, from) {
                var array = this.array, len = array.length >>> 0;
                from = Number(arguments[1]) || 0;
                from = from < 0 ? Math.ceil(from) : Math.floor(from);
                if (from < 0) {
                    from += len;
                }
                for (;from < len; from++) {
                    if (from in array && array[from] === item) {
                        return from;
                    }
                }
                return -1;
            },
            sort: function(value) {
                var array = this.array;
                if (ib.isString(value)) {
                    value = value.toLowerCase();
                    if (value === "asc") {
                        value = function(args1, args2) {
                            return args1 === args2 ? 0 : args1 > args2 ? 1 : -1;
                        };
                    } else if (value === "desc") {
                        value = function(args1, args2) {
                            return args1 === args2 ? 0 : args1 < args2 ? 1 : -1;
                        };
                    }
                }
                return value ? array.sort(value) : array.sort();
            },
            push: function(item) {
                this.array.push(item);
                return this;
            },
            remove: function(item) {
                var array = this.array, index = this.indexOf(item);
                return index > -1 ? array.splice(index, 1) : array.splice(0, array.length);
            },
            reverse: function() {
                return this.array.reverse();
            },
            length: function() {
                return this.array.length;
            },
            get: function(index) {
                if (ib.isInteger(index)) {
                    return this.array[index];
                } else {
                    return this.array;
                }
            },
            pop: function() {
                return this.array.pop();
            },
            shift: function() {
                return this.array.shift();
            },
            join: function(spliter) {
                return this.array.join(spliter);
            },
            clone: function() {
                return this.array.slice(0);
            }
        };
        context.Array = function(arr) {
            return new array(arr);
        };
    });
    ib.addMixin(function() {
        var context = this, Iterator;
        function eachObj(value, fn, deep) {
            var self = this, returnValue, val, e;
            for (e in value) {
                val = value[e];
                returnValue = fn(e, val);
                if (self.isReturm) return returnValue;
                if (self.isStop) break;
                if (deep !== false && ib.isObject(val) && !ib.isEmptyObject(val)) {
                    return eachObj(val, fn);
                }
            }
            return;
        }
        (Iterator = function(value) {
            this.value = value;
            this.returnValue = undefined;
            this.isReturm = false;
        }).prototype = {
            foreach: function(value, fn) {
                var self = this, i, len, deep;
                if (ib.isFunction(value)) {
                    deep = fn;
                    fn = value;
                    value = self.value;
                }
                self.isReturm = false;
                self.isStop = false;
                if (value && value.length) {
                    for (i = 0, len = value.length; i < len; i++) {
                        fn(i, value[i]);
                        if (self.isReturm) {
                            self.isReturm = false;
                            return self.returnValue;
                        }
                    }
                } else if (ib.isObject(value)) {
                    eachObj.call(self, value, fn, deep);
                }
            },
            stop: function() {
                this.isReturm = true;
            },
            returm: function(value) {
                var self = this;
                self.isReturm = true;
                self.returnValue = value;
            }
        };
        context.iterator = function(value) {
            return new Iterator(value);
        };
    });
    ib.fn.addMixin(function() {
        this.foreach = function(fn) {
            var self = this, i, ele;
            if (self.length > 0) {
                for (i = 0; ele = self[i]; i++) {
                    fn.call(ele, i);
                }
            }
            return self;
        };
    });
    ib.fn.addMixin(function() {
        var context, eleClass;
        context = this;
        function proc(value, method, propertyName, attributeName) {
            var that, cls, classs, className, i, j, ele;
            that = this;
            if (ib.isString(value)) {
                classs = value.split(ib.splitExp);
                for (i = 0, j = 0; ele = that[i++]; j = 0) {
                    className = ele[propertyName] ? ele[propertyName] + " " : " ";
                    if (className) {
                        while (cls = classs[j++]) {
                            className = method(className, cls);
                        }
                        className = ib.String(className).trim();
                        ele[propertyName] = className;
                        if (ele.removeAttribute && className === "") {
                            ele.removeAttribute(attributeName || propertyName);
                        }
                    }
                }
            }
        }
        function StringArch(propertyName, attributeName) {
            return {
                add: function(className) {
                    var that;
                    that = this;
                    if (!that.length) {
                        return null;
                    }
                    proc.call(that, className, function(className, cls) {
                        if (className.indexOf(cls) < 0) {
                            className += cls + " ";
                        }
                        return className;
                    }, propertyName, attributeName);
                    return that;
                },
                remove: function(className) {
                    var that;
                    that = this;
                    if (!that.length) {
                        return null;
                    }
                    proc.call(that, className, function(className, cls) {
                        return className.replace(new RegExp("(\\s|^)" + cls + "(\\s|$)"), " ");
                    }, propertyName, attributeName);
                    return that;
                },
                toggle: function(className) {
                    var that;
                    that = this;
                    if (!that.length) {
                        return null;
                    }
                    proc.call(that, className, function(className, cls) {
                        if (className.indexOf(cls) < 0) {
                            className += cls + " ";
                        } else {
                            className = className.replace(new RegExp("(\\s|^)" + cls + "(\\s|$)"), " ");
                        }
                        return className;
                    }, propertyName, attributeName);
                    return that;
                },
                has: function(className) {
                    var that, i, ele;
                    that = this;
                    if (!that.length) {
                        return null;
                    }
                    className = " " + className + " ";
                    for (i = 0; ele = that[i++]; ) {
                        if ((" " + ele[propertyName] + " ").indexOf(className) > -1) {
                            return true;
                        }
                    }
                    return false;
                }
            };
        }
        ib.StringArch = StringArch;
        eleClass = StringArch("className", "class");
        context.addClass = eleClass.add;
        context.removeClass = eleClass.remove;
        context.toggleClass = eleClass.toggle;
        context.hasClass = eleClass.has;
    });
    ib.fn.addMixin(function() {
        var context = this, w = ib.window, hookValue = {
            select: {
                get: function(ele) {
                    var options = ele.options, selectedIndex = ele.selectedIndex, selectedOne = ele.type === "select-one", values = selectedIndex < 0 ? null : selectedOne || [], i, option;
                    for (i = 0; option = options[i++]; ) {
                        if ((option.selected || i - 1 === selectedIndex) && !option.disabled && option.getAttribute("disabled") === null) {
                            if (selectedOne) {
                                values = option.value;
                                break;
                            }
                            values.push(option.value);
                        }
                    }
                    return values;
                },
                set: function(value, ele) {
                    var values = ib.Array(value), options = ele.options, option, i;
                    for (i = 0; option = options[i++]; ) {
                        if (values.indexOf(option.value) < 0) {
                            option.selected = false;
                        } else {
                            option.selected = true;
                        }
                    }
                    if (!values.length()) {
                        ele.selectedIndex = -1;
                    }
                    return ele;
                }
            }
        }, excludeInputType = {
            button: true,
            image: true,
            reset: true,
            submit: true
        }, includeChekcbox = {
            checkbox: true,
            radio: true
        }, includeNodeName = {
            input: true,
            select: true,
            textarea: true,
            keygen: true
        };
        function getValue(value, ele) {
            var nodeName = ele.nodeName.toLowerCase(), hook = hookValue[nodeName];
            return hook ? hook.get(ele) : ele.value;
        }
        function setValue(value, ele) {
            var isFunction = ib.isFunction(value), nodeName, hook, val, self = this, i, v;
            self.foreach(function(index) {
                ele = this;
                nodeName = ele.nodeName.toLowerCase();
                hook = hookValue[nodeName], val = isFunction ? value.call(ele, index) : value;
                if (ib.isNumber(val)) {
                    val += "";
                } else if (ib.isArray(val)) {
                    for (i = 0; v = val[i++]; ) {
                        ib.isNumber(v) && (val[i - 1] = v + "");
                    }
                }
                hook ? hook.set(val, ele) : ele.value = val;
            });
            return self;
        }
        function serializeValue(value) {
            return ib.isString(value) || ib.isNumber(value) ? value : "";
        }
        context.value = function(value, target) {
            var self = this;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            return (ib.isUndefined(value) ? getValue : setValue).call(self, value, target);
        };
        context.serializeObject = function(target) {
            var self = this, obj, elements, element, name, type, splitChar, i;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            obj = {};
            splitChar = "|";
            elements = context.property("elements", undefined, target) || self.toArray();
            for (i = 0; element = elements[i++]; ) {
                type = element.type;
                if ((name = element.name) && !excludeInputType[type] && includeNodeName[element.nodeName.toLowerCase()] && !context.property("disabled", undefined, element) && (!includeChekcbox[type] || context.attribute("checked", undefined, element))) {
                    obj[name] ? obj[name] += splitChar + element.value : obj[name] = element.value;
                }
            }
            return obj;
        };
        context.serialize = function(target) {
            var self = this, data, array, value, e;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            data = self.serializeObject(target);
            array = [];
            for (e in data) {
                value = data[e];
                array.push(e + "=" + serializeValue(value));
            }
            return array.join("&");
        };
        context.serializeArray = function(target) {
            var self = this, data, array, value, e;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            data = self.serializeObject(target);
            array = [];
            for (e in data) {
                value = data[e];
                array.push({
                    name: e,
                    value: serializeValue(value)
                });
            }
            return array;
        };
        context.data = function(name, value, target) {
            var self = this;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            if (ib.isString(name)) {
                if (value) {
                    self.foreach(function() {
                        target = this;
                        ib.cache._addData(target, name, value);
                    });
                } else {
                    return ib.cache._getData(target, name);
                }
            }
            return self;
        };
        context.removeData = function(name) {
            var self = this;
            if (!self.length) {
                return null;
            }
            if (ib.isString(name)) {
                self.foreach(function() {
                    target = this;
                    ib.cache._removeData(target, name);
                });
            }
            return self;
        };
        context.hasData = function(name, target) {
            var self = this;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            return ib.cache._hasData(target, name);
        };
    });
    ib.fn.addMixin(function() {
        var context = this;
        function show(target) {
            var value;
            if (context.style("display", undefined, target) === "none") {
                value = ib.cache._getData(target, "oldDisplay") || "block";
                target.style.display = value;
            }
        }
        function hide(target) {
            var oldDisplay;
            if ((oldDisplay = context.style("display", undefined, target)) !== "none") {
                ib.cache._addData(target, "oldDisplay", oldDisplay);
                target.style.display = "none";
            }
        }
        context.show = function() {
            var self = this;
            self.foreach(function() {
                show(this);
            });
            return self;
        };
        context.hide = function() {
            var self = this;
            self.foreach(function() {
                hide(this);
            });
            return self;
        };
        context.toggle = function() {
            var self = this;
            self.foreach(function() {
                var ele = this;
                if (ele.style) {
                    (context.style("display", undefined, ele) === "none" ? show : hide)(ele);
                }
            });
            return self;
        };
    });
    ib.fn.addMixin(function() {
        var context = this, w = ib.window, doc = w.document, handlers = {}, commonProp = [ "altKey", "ctrlKey", "metaKey", "shiftKey", "bubbles", "cancelable", "currentTarget", "eventPhase", "target", "timeStamp", "type", "isTrigger", "selector" ], mouseProp = [ "fromElement", "offsetX", "offsetY", "pageX", "pageY", "screenX", "screenY", "toElement", "x", "y", "clientX", "clientY" ], keyProp = [ "char", "charCode", "key", "keyCode", "which" ], touchProp = [ "fromElement", "offsetX", "offsetY", "pageX", "pageY", "screenX", "screenY", "toElement", "touchs", "targetTouches", "changedTouches", "scale", "rotation" ], rePropNm = {
            target: "srcElement",
            pageX: "clientX",
            pageY: "clientY",
            offsetX: "layerX",
            offsetY: "layerY",
            keyCode: "which"
        }, addEventNm, removeEventNm, prefixEventType, mouseEvent = {
            click: true,
            dblclick: true,
            mousedown: true,
            mousemove: true,
            mouseover: true,
            mouseout: true,
            mouseup: true,
            contextmenu: true,
            drop: true,
            dragover: true,
            dragend: true
        }, keyEvent = {
            keydown: true,
            keypress: true,
            keyup: true
        }, uiEvent = {
            load: true,
            focus: {
                action: function(element) {
                    element.focus();
                }
            },
            blur: {
                action: function(element) {
                    element.blur();
                }
            },
            resize: true,
            scroll: true,
            change: true,
            select: true,
            submit: {
                action: function(element) {
                    element.submit();
                }
            }
        }, bubbleEvent = {
            abort: true,
            error: true,
            resize: true,
            scroll: true,
            change: true,
            select: true,
            submit: true
        }, touchEvent = {
            touchstart: true,
            touchmove: true,
            touchend: true,
            touchcancel: true
        }, eventProp = {
            bubbles: true,
            cancelable: false
        }, eventList;
        ib.Object.merge(bubbleEvent, keyEvent, mouseEvent, touchEvent);
        eventList = ib.Object.merge({}, bubbleEvent, uiEvent);
        function hookEvent(originEvent, data) {
            var self = this, propNm, props, type, i, value, prop;
            self.originEvent = originEvent;
            type = originEvent.type;
            if (mouseEvent[type]) {
                props = commonProp.concat(mouseProp);
            } else if (keyEvent[type]) {
                props = commonProp.concat(keyProp);
                if (originEvent.which == null) {
                    self.which = originEvent.charCode != null ? originEvent.charCode : originEvent.keyCode;
                }
            } else if (touchEvent[type]) {
                props = commonProp.concat(touchProp);
            } else {
                props = commonProp;
            }
            for (i = 0; prop = props[i++]; ) {
                if (ib.isUndefined(value = originEvent[prop])) {
                    value = originEvent[propNm = rePropNm[prop]];
                    if (propNm === "clientX") {
                        value = (value || 0) + ib.window.document.documentElement.scrollLeft;
                    } else if (propNm === "clientY") {
                        value = (value || 0) + ib.window.document.documentElement.scrollTop;
                    }
                }
                self[prop] = value;
            }
            self.delegateTarget = self.originEvent.currentTarget;
            if (data) {
                ib.Object.merge(self, data);
            }
        }
        hookEvent.prototype = {
            preventDefault: function() {
                var self = this, event = self.originEvent;
                self.cancelable = true;
                if (!event) return;
                if (event.preventDefault) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                }
            },
            isPreventDefault: function() {
                return this.cancelable;
            },
            stopPropagation: function() {
                var self = this, event = self.originEvent;
                self.bubbles = false;
                if (!event) return;
                if (event.stopPropagation) {
                    event.stopPropagation();
                } else {
                    event.cancelBubble = true;
                }
            },
            isStopPropagation: function() {
                return !this.bubbles;
            }
        };
        function hookHandler(rTarget, originHandler, delegate) {
            return function(originEvent) {
                var selector = delegate, event = new hookEvent(originEvent), target = event.target, returnSelector, returnVal;
                if (selector && ib.isElement(event.target)) {
                    for (;target != rTarget && ib.isElement(target); target = target.parentNode || rTarget) {
                        if (!target.disabled && (target.attributes.disabled || "").value !== "true") {
                            if (returnSelector = ib.selector_e(selector, target)) {
                                event.delegateTarget = target;
                                event.selector = ib.isBoolean(returnSelector) ? selector : returnSelector;
                                returnVal = originHandler.call(target, event);
                                break;
                            }
                        }
                    }
                } else {
                    returnVal = originHandler.call(rTarget, event);
                }
                if (returnVal === false) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                return returnVal;
            };
        }
        function triggerP(target, dispatchEvent, evt, type) {
            target.dispatchEvent ? target.dispatchEvent(evt) : target.fireEvent("on" + type, evt);
        }
        if (doc.addEventListener) {
            addEventNm = "addEventListener";
            removeEventNm = "removeEventListener";
            prefixEventType = "";
        } else {
            addEventNm = "attachEvent";
            removeEventNm = "detachEvent";
            prefixEventType = "on";
        }
        context.delegate = function(selector, eventType, originHandler) {
            return this.addEvent(eventType, originHandler, selector);
        };
        context.addEvent = function(events, handler, selector, _namespace) {
            var self = this, ele, i, eventArr, event, type, value, tempHandler, namespace;
            if (!self.length) {
                return null;
            }
            if (ib.isString(events) && ib.isFunction(handler)) {
                if (eventArr = events.split(ib.splitExp)) {
                    events = {};
                    for (i = 0; event = eventArr[i++]; ) {
                        events[event] = {
                            handler: handler,
                            selector: selector,
                            namespace: _namespace
                        };
                    }
                }
            }
            for (i = 0; ele = self[i++]; ) {
                for (type in events) {
                    value = events[type];
                    handler = undefined;
                    selector = undefined;
                    namespace = undefined;
                    if (ib.isObject(value)) {
                        handler = value.handler;
                        selector = value.selector;
                        namespace = value.namespace;
                    } else {
                        handler = value;
                    }
                    tempHandler = hookHandler(ele, handler, selector);
                    ib.cache._addData(ele, "events " + type, [ {
                        eventType: type,
                        delegate: selector,
                        namespace: namespace,
                        originHandler: handler,
                        hookHandler: tempHandler,
                        target: ele
                    } ]);
                    ele[addEventNm](prefixEventType + type, tempHandler, false);
                }
            }
            return self;
        };
        context.removeEvent = function(events, handler) {
            var self = this, ele, hookHandler, eventCache, eventData, type, matchType, i, j, event, eventArr, cacheData;
            if (!self.length) {
                return null;
            }
            if (ib.isString(events)) {
                if (eventArr = events.split(ib.splitExp)) {
                    events = {};
                    for (i = 0; event = eventArr[i++]; ) {
                        events[event] = handler;
                    }
                }
            }
            for (i = 0; ele = self[i++]; ) {
                for (type in events) {
                    if (eventCache = ib.cache._getData(ele, "events " + type)) {
                        handler = events[type];
                        matchType = ib.isString(handler) ? "namespace" : "originHandler";
                        for (j = 0; eventData = eventCache[j]; j++) {
                            if (eventData[matchType] === handler || ib.isUndefined(handler)) {
                                hookHandler = eventData.hookHandler;
                                eventCache.splice(j, 1);
                                ele[removeEventNm](prefixEventType + type, hookHandler);
                                matchType === "originHandler" && (j = -1);
                            }
                        }
                        if (eventCache.length === 0) {
                            cacheData = ib.cache._getData(ele, "events");
                            delete cacheData[type];
                            if (ib.isEmptyObject(cacheData)) {
                                ib.cache._removeData(ele, "events");
                            }
                        }
                    }
                }
            }
            return self;
        };
        context.triggerEvent = function(type, target) {
            var self = this, evt, dispatchEvent, i, ele;
            target = target || self;
            if (!self.length && !target) {
                return null;
            }
            dispatchEvent = true;
            if (w.CustomEvent && ib.Browser.name != "msie") {
                evt = new w.CustomEvent(type, eventProp);
            } else if (doc.createEvent) {
                evt = doc.createEvent("Event");
                evt.initEvent(type, eventProp.bubbles, eventProp.cancelable);
            } else if (doc.createEventObject) {
                evt = doc.createEventObject();
                for (var e in eventProp) {
                    evt[e] = eventProp[e];
                }
                dispatchEvent = false;
            }
            evt.isTrigger = true;
            if (target.length) {
                for (i = 0; ele = target[i++]; ) {
                    triggerP(ele, dispatchEvent, evt, type);
                }
            } else {
                triggerP(target, dispatchEvent, evt, type);
            }
            return self;
        };
        context.trigger = function(type, selector, data) {
            var self = this, eventPath, cur, temp, event, eventData, i, iLen, j, jLen, ret, obj;
            if (ib.isPureObject(selector)) {
                data = selector;
                selector = selector.selector;
            }
            if (ib.isPureObject(type)) {
                data = type;
                type = type.type;
                selector = type.selector;
            }
            if (data) {
                delete data.type;
                delete data.selector;
            }
            if (!type) return;
            obj = {
                type: type,
                isTrigger: true,
                bubbles: bubbleEvent[type] ? true : false,
                cancelable: false,
                timeStamp: new Date().getTime()
            };
            self.foreach(function() {
                eventPath = [ this ];
                obj.target = selector ? ib(selector)[0] : eventPath[0];
                if (!ib.isWindow(this) && obj.bubbles) {
                    for (cur = this; cur = cur.parentNode; ) {
                        temp = cur;
                        eventPath.push(cur);
                    }
                    if (temp === (this.ownerDocument || doc)) {
                        eventPath.push(temp.defaultView || temp.parentWindow || w);
                    }
                }
                for (i = 0, iLen = eventPath.length; i < iLen; i++) {
                    if (eventData = ib.cache._getData(eventPath[i], "events " + type)) {
                        obj.delegateTarget = obj.currentTarget = eventPath[i];
                        event = new hookEvent(obj, data);
                        for (j = 0, jLen = eventData.length; j < jLen; j++) {
                            if (eventData[j].delegate) {
                                if (selector) {
                                    if (ib.Array(eventData[j].delegate.split(",")).indexOf(selector) == -1) {
                                        continue;
                                    }
                                    event.selector = selector;
                                } else if (!ib.selector_e(eventData[j].delegate, this)) {
                                    continue;
                                }
                            }
                            ret = eventData[j].originHandler.call(this, event);
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                        if (eventList[type] && ib.isFunction(eventList[type].action)) {
                            eventList[type].action(eventPath[i]);
                        }
                        if (event.isStopPropagation()) {
                            break;
                        }
                    }
                }
            });
            return self;
        };
        context.focus = function(target) {
            var self = this;
            target = target || self[0];
            if (target != ib.window.document.activeElement && target.focus) {
                target.focus();
            }
            return self;
        };
        context.blur = function(target) {
            var self = this;
            target = target || self[0];
            if (target == ib.window.document.activeElement && target.blur) {
                target.blur();
            }
            return self;
        };
    });
    ib.fn.addMixin(function() {
        var context = this;
        function clone(deep, target) {
            return target.cloneNode(deep ? deep : ib.isUndefined(deep) ? true : deep);
        }
        function getDescendant(context, tagName, excludeSelf) {
            var eles, ele, arr, i;
            if (context.getElementsByTagName) {
                eles = context.getElementsByTagName(tagName || "*");
            } else if (context.querySelectorAll) {
                eles = context.getquerySelectorAll(tagName || "*");
            }
            if (eles !== undefined) {
                arr = [];
                for (i = 0; ele = eles[i++]; ) {
                    arr.push(ele);
                }
                eles = null;
                return ib.isElement(context) && !excludeSelf ? ib.arrayConcat.apply([ context ], arr) : arr;
            } else {
                return undefined;
            }
        }
        function clearData(eles) {
            var key, data, cache = ib.cache.cache, event, eventType, i, ele, j, evt;
            for (i = 0; ele = eles[i++]; ) {
                key = ele[ib.cacheId];
                if (data = cache[key]) {
                    if (data.events) {
                        for (eventType in data.events) {
                            event = data.events[eventType];
                            for (j = 0; evt = event[j]; j++) {
                                context.removeEvent(eventType, evt.originHandler, [ ele ]);
                            }
                        }
                    }
                    delete cache[key];
                    context.removeProperty(ib.cacheId, ele);
                }
            }
        }
        function eleInnerOuter(val, fn) {
            var self = this, ele, i, v;
            if (ib.isString(val)) {
                val = ib.string2html(val);
            }
            self.foreach(function() {
                ele = this;
                if (ib.isElement(val)) {
                    fn.call(ele, val);
                } else {
                    for (i = 0; v = val[i++]; ) {
                        v.nodeType == 3 && (v = v.nodeValue);
                        if (ib.isString(v)) {
                            v = ib.selector_a(v, document, [])[0];
                        }
                        fn.call(ele, v);
                    }
                }
            });
        }
        function getText(ele) {
            var text = "", nodeType = ele.nodeType;
            if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (ele.textContent) {
                    return ele.textContent;
                } else {
                    for (ele = ele.firstChild; ele; ele = ele.nextSibling) {
                        text += getText(ele, true);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return ib.String(ele.nodeValue).trim() + " ";
            }
            return text;
        }
        function setText(ele, val) {
            var nodeValue;
            ele.textContent === undefined ? ele.innerText = val : ele.textContent = val;
        }
        context.clone = function(deep) {
            var self = this;
            var clones = [];
            if (!self.length) {
                return null;
            }
            self.foreach(function() {
                clones.push(clone(deep, this));
            });
            return clones;
        };
        context.append = function(val) {
            var self = this;
            if (!self.length) {
                return null;
            }
            eleInnerOuter.call(self, val, function(val) {
                this.appendChild(val);
            });
            return self;
        };
        context.appendTo = function(val) {
            var self = this;
            if (!self.length) {
                return null;
            }
            eleInnerOuter.call(self, val, function(val) {
                val.appendChild(this);
            });
            return self;
        };
        context.prepend = function(val) {
            var self = this, ele;
            if (!self.length) {
                return null;
            }
            eleInnerOuter.call(self, val, function(val) {
                ele = this;
                ele.insertBefore(val, ele.firstChild);
            });
            return self;
        };
        context.prependTo = function(val) {
            var self = this;
            if (!self.length) {
                return null;
            }
            eleInnerOuter.call(self, val, function(val) {
                val.insertBefore(this, val.firstChild);
            });
            return self;
        };
        context.after = function(val) {
            var self = this, ele;
            if (!self.length) {
                return null;
            }
            eleInnerOuter.call(self, val, function(val) {
                ele = this;
                if (ele.parentNode) {
                    ele.parentNode.insertBefore(val, ele.nextSibling);
                }
            });
            return self;
        };
        context.before = function(val) {
            var self = this, ele;
            if (!self.length) {
                return null;
            }
            eleInnerOuter.call(self, val, function(val) {
                ele = this;
                if (ele.parentNode) {
                    ele.parentNode.insertBefore(val, ele);
                }
            });
            return self;
        };
        context.remove = function() {
            var self = this, desc, ele;
            if (!self.length) {
                return null;
            }
            self.foreach(function() {
                ele = this;
                if (desc = getDescendant(ele)) {
                    clearData(desc);
                }
                if (ele.parentNode) {
                    ele.parentNode.removeChild(ele);
                }
            });
        };
        context.empty = function() {
            var self = this, desc, ele;
            if (!self.length) {
                return null;
            }
            self.foreach(function() {
                ele = this;
                if (desc = getDescendant(ele, undefined, true)) {
                    clearData(desc);
                }
                while (ele.firstChild) {
                    ele.removeChild(ele.firstChild);
                }
                (ele.nodeName || "").toLowerCase() === "select" && ele.options && (ele.options.length = 0);
            });
            return self;
        };
        context.html = function(val, target) {
            var self = this, desc, ele;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            if (ib.isUndefined(val)) {
                return target.innerHTML;
            } else if (ib.isString(val)) {
                self.foreach(function() {
                    ele = this;
                    if (desc = getDescendant(ele, undefined, true)) {
                        clearData(desc);
                    }
                    ele.innerHTML = val;
                });
                return self;
            }
        };
        context.text = function(val) {
            var self = this, text;
            if (!self.length) {
                return null;
            }
            text = "";
            if (val === undefined) {
                self.foreach(function() {
                    text += getText(this) + " ";
                });
                return ib.String(text).trim();
            } else if (!ib.isObject(val)) {
                self.foreach(function() {
                    setText(this, "" + val);
                });
                return self;
            }
        };
    });
    ib.fn.addMixin(function() {
        var context = this, tMethods = {
            parents: parents,
            children: children,
            childSibling: childSibling,
            sibling: sibling
        }, childTran = {
            first: "nextSibling",
            last: "previousSibling"
        }, traversingTran = {};
        function parents(selector, target, parents) {
            while (target && (target = target.parentNode) && ib.isElement(target)) {
                if (selector) {
                    ib.selector_e(selector, target) && parents.push(target);
                } else {
                    parents.push(target);
                }
            }
        }
        function children(selector, target, children) {
            var child, i;
            if (!target) {
                return;
            }
            for (child = target.firstChild, i = 0; child; child = child.nextSibling) {
                if (ib.isElement(child)) {
                    if (!ib.isUndefined(selector)) {
                        if (selector === i) {
                            children.push(child);
                            return;
                        } else {
                            ib.selector_e(selector, child) && children.push(child);
                        }
                    } else {
                        children.push(child);
                    }
                    ++i;
                }
            }
        }
        function childSibling(target, prop) {
            if (target) {
                while (!ib.isElement(target) && (target = target[prop])) {}
            }
            return target;
        }
        function sibling(target, prop) {
            if (target) {
                while (!ib.isElement(target) && (target = target[prop])) {}
            }
            return target;
        }
        traversingTran.parent = function(ele, selector, arr) {
            arr.push(ib.isElement(ele) ? ele.parentNode : null);
        };
        traversingTran.parents = traversingTran.children = function(ele, selector, arr, value) {
            tMethods[value](selector, ele, arr);
        };
        traversingTran.first = traversingTran.last = function(ele, selector, arr, value) {
            arr.push(childSibling(ele[value + "Child"], childTran[value]));
        };
        traversingTran.next = traversingTran.previous = function(ele, selector, arr, value) {
            arr.push(sibling(ele[value + "Sibling"], value + "Sibling"));
        };
        traversingTran.find = function(ele, selector, arr) {
            ib.selector_a(selector || "*", ele, arr);
        };
        ib.iterator([ "parent", "parents", "children", "first", "last", "next", "previous", "find" ]).foreach(function(index, value) {
            context[value] = function(selector) {
                var self = this;
                return self.wrapper(function() {
                    var arr = [];
                    self.foreach(function() {
                        traversingTran[value](this, selector, arr, value);
                    });
                    return ib.Array(arr).unique();
                });
            };
        });
    });
    ib.fn.addMixin(function() {
        var context = this, fixNm = {
            readonly: "readOnly",
            ismap: "isMap",
            usemap: "useMap",
            noresize: "noResize",
            maxlength: "maxLength",
            tabindex: "tabIndex",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            colspan: "colSpan",
            rowspan: "rowSpan",
            "class": "className",
            checked: "checked"
        }, propNm;
        function _setAttr(args, target) {
            var value, e;
            for (e in args) {
                value = args[e];
                if (ib.isNull(value) || ib.isUndefined(value) || ib.isNaN(value)) {
                    target.removeAttribute(e);
                } else {
                    (propNm = fixNm[e]) ? target[propNm] = value : target.setAttribute(e, value);
                }
            }
        }
        function setAttr(args, target) {
            var self = this;
            if (ib.isObject(args)) {
                if (target) {
                    _setAttr(args, target);
                } else {
                    self.foreach(function() {
                        _setAttr(args, this);
                    });
                }
            }
            return self;
        }
        function getAttr(args, target) {
            var attrs, attr, attrObj, i, value;
            target = target || this[0];
            attrs = args.split(ib.splitExp);
            attrObj;
            if (attrs.length > 1) {
                attrObj = {};
                for (i = 0; attr = attrs[i++]; ) {
                    if (value = (propNm = fixNm[attr]) ? target[propNm] : target.getAttribute(attr)) {
                        if (value !== null) {
                            attrObj[attr] = value;
                        }
                    }
                }
                return ib.isEmptyObject(attrObj) ? null : attrObj;
            } else {
                return (propNm = fixNm[args]) ? target[propNm] : target.getAttribute(args);
            }
        }
        function removeAttr(target, attributes) {
            var attribute, i;
            for (i = 0; attribute = attributes[i++]; ) {
                (propNm = fixNm[attribute]) ? target[propNm] = null : target.removeAttribute(attribute);
            }
        }
        function _setProp(args, target) {
            var e;
            for (e in args) {
                target[fixNm[e] || e] = args[e];
            }
        }
        function setProp(args, target) {
            var self = this;
            if (ib.isObject(args)) {
                if (target) {
                    _setProp(args, target);
                } else {
                    self.foreach(function() {
                        _setProp(args, this);
                    });
                }
            }
            return self;
        }
        function getProp(args, target) {
            var properties, property, prop, propertyObj, i;
            target = target || this[0];
            properties = args.split(ib.splitExp);
            if (properties.length > 1) {
                propertyObj = {};
                for (i = 0; property = properties[i++]; ) {
                    if (prop = target[fixNm[property] || property]) {
                        if (prop !== null) {
                            propertyObj[property] = prop;
                        }
                    }
                }
                return ib.isEmptyObject(propertyObj) ? null : propertyObj;
            } else {
                return target[fixNm[args] || args];
            }
        }
        function removeProp(target, properties) {
            var property, i;
            for (i = 0; property = properties[i++]; ) {
                target[fixNm[property] || property] = null;
            }
        }
        context.attribute = function(args1, args2, target) {
            var self = this, temp;
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = args2;
            }
            return (ib.isObject(args1) ? setAttr : getAttr).call(self, args1, target);
        };
        context.removeAttribute = function(attr, target) {
            var self = this, propNm, attributes;
            if (!self.length && !target) {
                return null;
            }
            if (ib.isString(attr)) {
                attributes = attr.split(ib.splitExp);
                if (target) {
                    removeAttr(target, attributes);
                } else {
                    self.foreach(function() {
                        removeAttr(this, attributes);
                    });
                }
            }
            return self;
        };
        context.property = function(args1, args2, target) {
            var self = this, temp;
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = args2;
            }
            return (ib.isObject(args1) ? setProp : getProp).call(self, args1, target);
        };
        context.removeProperty = function(prop, target) {
            var self = this, propNm, properties;
            if (!self.length && !target) {
                return null;
            }
            if (!prop) return;
            if (ib.isString(prop)) {
                properties = prop.split(ib.splitExp);
                if (target) {
                    removeProp(target, properties);
                } else {
                    self.foreach(function() {
                        removeProp(this, properties);
                    });
                }
            }
        };
    });
    ib.fn.addMixin(function() {
        var context = this, w = ib.window, doc = w.document;
        function process(target, value, scroll, pageOffset, method) {
            if (ib.isUndefined(value)) {
                return target === w || target === doc ? w[pageOffset] || doc.documentElement[scroll] || doc.body[scroll] : target[scroll];
            } else {
                target = ib.isDocument(target) && target.defaultView || target.parentWindow || target;
                if (target == w) {
                    method(value);
                } else {
                    target[scroll] = value;
                }
            }
        }
        function getScroll(args, target) {
            target = target || this[0];
            if (args === "top") {
                return process.call(this, target, undefined, "scrollTop", "pageYOffset");
            } else if (args === "left") {
                return process.call(this, target, undefined, "scrollLeft", "pageXOffset");
            } else {
                return {
                    top: process.call(this, target, undefined, "scrollTop", "pageYOffset"),
                    left: process.call(this, target, undefined, "scrollLeft", "pageXOffset")
                };
            }
        }
        function _setScroll(args, target) {
            var top, left, temp;
            !!(top = args.top) && process.call(this, target, top, "scrollTop", "pageYOffset", function(value) {
                w.scrollTo("top", value);
            });
            !!(left = args.left) && process.call(this, target, left, "scrollLeft", "pageXOffset", function(value) {
                w.scrollTo("left", value);
            });
        }
        function setScroll(args, target) {
            var self = this;
            if (ib.isObject(args)) {
                if (target) {
                    _setScroll(args, target);
                } else {
                    self.foreach(function() {
                        _setScroll(args, this);
                    });
                }
            }
            return self;
        }
        context.scroll = function(args1, args2, target) {
            var self = this, temp;
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = "" + args2;
            }
            return (ib.isObject(args1) ? setScroll : getScroll).call(self, args1, target);
        };
        context.scrollTop = function(args, target) {
            return this.scroll("top", args, target);
        };
        context.scrollLeft = function(args, target) {
            return this.scroll("left", args, target);
        };
    });
    ib.fn.addMixin(function() {
        var context = this;
        function getNumber(value) {
            var match;
            return +((match = ib.unitSplitExp.exec(value)) ? match[1] : 0);
        }
        function getStyleValue(computed, style) {
            return computed[style] || computed.getPropertyValue(style);
        }
        context.size = function(args1, args2, target) {
            var self = this, temp;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            if (!target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = args2;
            }
            return ib.isObject(args1) ? self.style(args1, target) : args1 === "width" || args1 === "height" ? self[args1](undefined, target) : {
                width: self.width(undefined, target),
                height: self.height(undefined, target)
            };
        };
        context.height = function(args, target) {
            var self = this, docEle, computed;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args)) {
                return self.style({
                    height: args
                });
            } else {
                if (ib.isWindow(target)) {
                    return target.document.documentElement.clientHeight;
                }
                if (ib.isDocument(target)) {
                    docEle = target.documentElement;
                    return Math.max(docEle.clientHeight, target.body.scrollHeight, docEle.scrollHeight, target.body.offsetHeight, docEle.offsetHeight);
                }
                computed = self.computedStyle(target);
                return target.offsetHeight - getNumber(getStyleValue(computed, "paddingTop")) - getNumber(getStyleValue(computed, "paddingBottom")) - getNumber(getStyleValue(computed, "borderTopWidth")) - getNumber(getStyleValue(computed, "borderBottomWidth"));
            }
        };
        context.innerHeight = function(target) {
            var self = this, computed;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            computed = self.computedStyle(target);
            if (ib.isElement(target)) {
                return target.offsetHeight - getNumber(getStyleValue(computed, "borderTopWidth")) - getNumber(getStyleValue(computed, "borderBottomWidth"));
            }
        };
        context.outerHeight = function(target) {
            var self = this, computed;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            computed = self.computedStyle(target);
            if (ib.isElement(target)) {
                return target.offsetHeight + getNumber(getStyleValue(computed, "marginTop")) + getNumber(getStyleValue(computed, "marginBottom"));
            }
        };
        context.width = function(args, target) {
            var self = this, docEle, computed;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args)) {
                return self.style({
                    width: args
                });
            } else {
                if (ib.isWindow(target)) {
                    return target.document.documentElement.clientWidth;
                }
                if (ib.isDocument(target)) {
                    docEle = target.documentElement;
                    return Math.max(docEle.clientWidth, target.body.scrollWidth, docEle.scrollWidth, target.body.offsetWidth, docEle.offsetWidth);
                }
                computed = self.computedStyle(target);
                return target.offsetWidth - getNumber(getStyleValue(computed, "paddingLeft")) - getNumber(getStyleValue(computed, "paddingRight")) - getNumber(getStyleValue(computed, "borderLeftWidth")) - getNumber(getStyleValue(computed, "borderRightWidth"));
            }
        };
        context.innerWidth = function(target) {
            var self = this, computed;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            computed = self.computedStyle(target);
            if (ib.isElement(target)) {
                return target.offsetWidth - getNumber(getStyleValue(computed, "borderLeftWidth")) - getNumber(getStyleValue(computed, "borderRightWidth"));
            }
        };
        context.outerWidth = function(target) {
            var self = this, computed;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            computed = self.computedStyle(target);
            if (ib.isElement(target)) {
                return target.offsetWidth + getNumber(getStyleValue(computed, "marginLeft")) + getNumber(getStyleValue(computed, "marginRight"));
            }
        };
    });
    ib.fn.addMixin(function() {
        var context = this, absNumber = {
            width: true,
            height: true
        }, excludePx = {
            "font-weight": true,
            fontWeight: true,
            opacity: true,
            "z-index": true,
            zIndex: true,
            zoom: true
        }, prefixs = "Moz Webkit O Ms".split(" "), opacityRegexp = /opacity\s*\=\s*([\.|0-9]*)/, hookCss = {
            opacity: {
                get: function(computed, style, ele) {
                    var opacity, filter;
                    if ((opacity = computed.opacity) !== null && opacity !== undefined) {
                        return opacity;
                    } else {
                        opacity = opacityRegexp.exec(filter = (ele.currentStyle ? ele.currentStyle.filter : ele.style.filter) || "");
                        return opacity ? parseFloat(opacity[1]) / 100 : computed ? "1" : "";
                    }
                },
                set: function(value, ele) {
                    var style = ele.style, opacity = ib.isNumber(+value) ? "alpha(opacity=" + value * 100 + ")" : "";
                    style.zoom = 1;
                    style.filter = opacity;
                }
            }
        }, getComputedStyle = ib.window.getComputedStyle ? ib.window.getComputedStyle : function(ele, pseude) {
            return {
                getPropertyValue: function(prop) {
                    var re = /(\-([a-z]){1})/g;
                    if (prop === "float") prop = "styleFloat";
                    if (re.test(prop)) {
                        prop = prop.replace(re, function() {
                            return arguments[2].toUpperCase();
                        });
                    }
                    return ele.currentStyle[prop] ? ele.currentStyle[prop] : null;
                }
            };
        };
        hookCss["width"] = hookCss["height"] = {
            get: function(computed, style, ele) {
                return context[style](undefined, undefined, ele);
            }
        };
        function propertyStyle(target, styleName) {
            var style = target.style, value, i, prefix;
            typeof style[styleName] === "string" ? value = style[styleName] : function() {
                for (i = 0; prefix = prefixs[i++]; ) {
                    if (typeof (value = style[prefix + context.String.capitalize(styleName)]) === string) {
                        break;
                    }
                }
            };
            return value;
        }
        function removeEndDot(match) {
            var value;
            if (/^[0-9]+[\.]+$/.test(match[1])) {
                value = match[1].substring(0, match[1].indexOf("."));
            }
            return value;
        }
        function toCamelCase(string) {
            return string.replace(/-([a-z0-9])/gi, function($1, $2) {
                return $2.toUpperCase();
            });
        }
        function _setStyle(args, target) {
            var strStyle, value, match, e;
            for (e in args) {
                value = args[e];
                if (!excludePx[e] && ib.isNumber(value)) {
                    if ((match = ib.unitSplitExp.exec(value)) && !match[2]) {
                        removeEndDot(match);
                        value = value + "px";
                    }
                }
                if (absNumber[e]) {
                    if (match = ib.unitSplitExp.exec(value)) {
                        removeEndDot(match);
                        match[1] < 0 && (value = 0 + match[2]);
                    }
                }
                e = toCamelCase(e);
                target.style[e] = value;
            }
        }
        function setStyle(args, target) {
            var self = this;
            if (ib.isObject(args)) {
                if (target) {
                    _setStyle(args, target);
                } else {
                    self.foreach(function() {
                        _setStyle(args, this);
                    });
                }
            }
            return self;
        }
        function getStyle(args, target) {
            var self = this, styles = args.split(ib.splitExp), style, styleObj, i, value;
            target = target || self[0];
            if (styles.length > 1) {
                styleObj = {};
                for (i = 0; style = styles[i++]; ) {
                    value = propertyStyle(target, style) || context.css(style, undefined, undefined, target);
                    if (value !== null) {
                        styleObj[style] = value;
                    }
                }
                return ib.isEmptyObject(styleObj) ? null : styleObj;
            } else {
                return propertyStyle(target, args) || context.css(args, undefined, undefined, target);
            }
        }
        function cssUnit(computed, style, removeUnit) {
            var value = computed[style] || computed.getPropertyValue(style);
            return removeUnit && value ? +value.replace(/cm|mm|in|px|pt|pc$/, "") : value;
        }
        function _setCss(args, removeUnit, target) {
            if ("opacity" in args && target.style.opacity === undefined) {
                hookCss["opacity"].set(args["opacity"], target);
            }
            context.style(args, undefined, target);
        }
        function setCss(args, removeUnit, target) {
            var self = this;
            if (ib.isObject(args)) {
                if (target) {
                    _setCss(args, removeUnit, target);
                } else {
                    self.foreach(function() {
                        _setCss(args, removeUnit, this);
                    });
                }
            }
            return self;
        }
        function getCss(args, removeUnit, target) {
            var self = this, computed, match, cssObj, styles, style, hook, i, value;
            target = target || self[0];
            styles = args.split(ib.splitExp);
            computed = self.computedStyle(target);
            if (styles.length > 1) {
                cssObj = {};
                for (i = 0; style = styles[i++]; ) {
                    hook = hookCss[style];
                    value = hook ? hook.get(computed, style, target) : cssUnit(computed, style, removeUnit);
                    cssObj[style] = value === null ? "" : value;
                }
                return ib.isEmptyObject(cssObj) ? null : cssObj;
            } else {
                hook = hookCss[args];
                return hook ? hook.get(computed, args, target) : cssUnit(computed, args, removeUnit);
            }
        }
        context.style = function(args1, args2, target) {
            var self = this, temp;
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = args2;
            }
            return (ib.isObject(args1) ? setStyle : getStyle).call(self, args1, target);
        };
        context.css = function(args1, args2, removeUnit, target) {
            var self = this, temp;
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = args2;
            }
            return (ib.isObject(args1) ? setCss : getCss).call(self, args1, removeUnit, target);
        };
        context.computedStyle = function(target) {
            var self = this;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            return getComputedStyle(target, null);
        };
    });
    ib.fn.addMixin(function() {
        var context = this, doc = ib.window.document, excludePosition = {
            absolute: true,
            relative: true,
            fixed: true
        };
        function currentPosition(v1, v2, type, target) {
            var currPosition = ib.offsetGap.exec(context.style(type, undefined, target))[0] || ib.offsetGap.exec(context.offset(type, undefined, target))[0] || 0;
            return currPosition - v1 + v2;
        }
        function _setOffset(args, target) {
            var offset = abOffset(target), position = excludePosition[context.css("position", undefined, undefined, target)] === undefined ? {
                position: "relative"
            } : {}, top, left;
            if (ib.isObject(args)) {
                if (ib.isNumber(top = args.top)) {
                    top = currentPosition(offset.top, top, "top", target);
                    position.top = top;
                }
                if (ib.isNumber(left = args.left)) {
                    left = currentPosition(offset.left, left, "left", target);
                    position.left = left;
                }
                context.style(position, undefined, target);
            }
        }
        function setOffset(args, target) {
            var self = this;
            if (ib.isObject(args)) {
                if (target) {
                    _setOffset(args, target);
                } else {
                    self.foreach(function() {
                        _setOffset(args, this);
                    });
                }
            }
            return self;
        }
        function getOffset(args, target) {
            var offset;
            target = target || this[0];
            offset = abOffset(target);
            return ib.isString(args) && (args === "top" || args === "left") ? offset[args] : offset;
        }
        function abOffset(target) {
            var doc = target.ownerDocument.documentElement, box = target.getBoundingClientRect ? target.getBoundingClientRect() : {
                top: 0,
                left: 0
            };
            return {
                top: box.top + (ib.window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0),
                left: box.left + (ib.window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)
            };
        }
        context.offset = function(args1, args2, target) {
            var self = this, temp;
            if (!self.length && !target) {
                return null;
            }
            if (!ib.isUndefined(args2) && ib.isString(args1)) {
                temp = args1;
                args1 = {};
                args1[temp] = args2;
            }
            return (ib.isObject(args1) ? setOffset : getOffset).call(self, args1, target);
        };
        context.offsetTop = function(args, target) {
            return this.offset("top", args, target);
        };
        context.offsetLeft = function(args, target) {
            return this.offset("left", args, target);
        };
        context.offsetParent = function(target) {
            var self = this, offsetParent;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            offsetParent = target.offsetParent || doc.documentElement;
            if (!offsetParent) {
                return null;
            }
            while (offsetParent && offsetParent.nodeName !== "html" && context.css("position", undefined, undefined, offsetParent) === "static") {
                offsetParent = offsetParent.offsetParent;
            }
            return ib(offsetParent || doc.documentElement);
        };
        context.position = function(target) {
            var self = this, computedStyle, offsetParent, targetOffset, parentOffset = {
                top: 0,
                left: 0
            }, offsetParentBorder, targetMargin;
            target = target || self[0];
            if (!self.length && !target) {
                return null;
            }
            if (context.css("position", undefined, undefined, target) === "fixed") {
                targetOffset = target.getBoundingClientRect();
            } else {
                offsetParent = context.offsetParent(target)[0];
                targetOffset = context.offset(undefined, undefined, target);
                if (offsetParent.nodeName !== "html") {
                    parentOffset = context.offset(undefined, undefined, offsetParent);
                }
                offsetParentBorder = context.css("borderTopWidth borderLeftWidth", undefined, true, offsetParent);
                parentOffset.top += offsetParentBorder.borderTopWidth || 0;
                parentOffset.left += offsetParentBorder.borderLeftWidth || 0;
            }
            targetMargin = context.css("marginTop marginLeft", undefined, true, target);
            return {
                top: targetOffset.top - parentOffset.top - (targetMargin.marginTop || 0),
                left: targetOffset.left - parentOffset.left - (targetMargin.marginLeft || 0)
            };
        };
    });
    ib.addMixin(function() {
        var context = this;
        var cacheId = "ib" + "xxxxxxxx".replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
            return v.toString(16);
        }), Cache;
        (Cache = function(object) {
            this.cacheKey = 0;
            this.cache = object;
            this.removeKeyList = [];
        }).prototype = {
            _addData: function(obj, name, data) {
                var self = this, key, nameSpace, i, d;
                if (!obj || !name || data === undefined) {
                    return;
                }
                if (!(key = obj[cacheId])) {
                    key = obj[cacheId] = self.removeKeyList.pop() || ++self.cacheKey;
                    self.cache[key] = {};
                }
                nameSpace = self._getNameSpace(self.cache[key], name);
                if (nameSpace.obj === undefined) {
                    self._createNameSpace(self.cache[key], name);
                    nameSpace = self._getNameSpace(self.cache[key], name);
                }
                if (ib.isArray(data)) {
                    if (!ib.isArray(nameSpace.obj[nameSpace.name])) {
                        nameSpace.obj[nameSpace.name] = [];
                    }
                    for (i = 0; d = data[i++]; ) {
                        nameSpace.obj[nameSpace.name].push(d);
                    }
                } else if (data != null) {
                    nameSpace.obj[nameSpace.name] = data;
                }
            },
            _removeData: function(obj, name) {
                var cache = this._getNameSpace(this.cache[obj[cacheId]], name);
                if (cache) {
                    delete cache.obj[cache.name];
                    if (context.isEmptyObject(cache.obj)) {
                        if (cache.name === name) {
                            this._removeCache(obj);
                        } else {
                            while ((name = name.replace(cache.name, "").replace(/^\s+|\s+$/g, "")) !== "") {
                                cache = this._getNameSpace(this.cache[obj[cacheId]], name);
                                if (context.isEmptyObject(cache.obj)) {
                                    if (this.cache[obj[cacheId]] === cache.obj) {
                                        this._removeCache(obj);
                                    } else {
                                        delete cache.obj[cache.name];
                                    }
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                }
            },
            _removeCache: function(obj) {
                var key;
                if (!obj || !(key = obj[cacheId])) {
                    return;
                }
                delete this.cache[key];
                delete obj[cacheId];
                self.removeKeyList.push(key);
            },
            _getData: function(obj, name) {
                var key, nameSpace;
                if (!obj || !name) {
                    return;
                }
                if (!(key = obj[cacheId])) {
                    return undefined;
                }
                nameSpace = this._getNameSpace(this.cache[key], name);
                return nameSpace.obj != null ? nameSpace.obj[nameSpace.name] : undefined;
            },
            _hasData: function(obj, name, data, iterator) {
                var cache = this._getData(obj, name), has;
                if (cache) {
                    if (ib.isFunction(data)) {
                        if (ib.isEmptyObject(cache) || iterator === undefined) {
                            return false;
                        }
                        return iterator.foreach(cache, data);
                    } else if (ib.isUndefined(data)) {
                        return true;
                    } else {
                        return cache === data;
                    }
                }
                return false;
            },
            _getCache: function(obj) {
                var key;
                if (obj) {
                    return this.cache[obj[cacheId]];
                } else {
                    return this.cache;
                }
            },
            _createNameSpace: function(obj, nameSpace) {
                var names = nameSpace.split(ib.splitExp);
                function create(obj, index) {
                    var name;
                    if (!(name = names[index++])) {
                        return;
                    }
                    obj[name] == null && (obj[name] = {});
                    create(obj[name], index);
                }
                create(obj, 0);
                return obj;
            },
            _getNameSpace: function(obj, nameSpace) {
                var names = nameSpace.split(ib.splitExp), nms, curObj;
                function get(obj, index) {
                    var name;
                    if (!(name = names[index++]) || index >= names.length || obj == null) {
                        return {
                            obj: obj,
                            name: names[names.length - 1]
                        };
                    }
                    return get(obj[name], index);
                }
                return get(obj, 0);
            }
        };
        context.cache = new Cache({});
        context.Cache = Cache;
        context.cacheId = cacheId;
    });
    ib.addMixin(function() {
        var context = this;
        context.proxy = function(fn, context) {
            var temp, args;
            if (ib.isString(context)) {
                temp = fn[context];
                context = fn;
                fn = temp;
            }
            if (ib.isFunction(fn)) {
                args = ib.arraySlice.call(arguments, 2);
                return function() {
                    return fn.apply(context || this, args.concat(ib.arraySlice.call(arguments, 0)));
                };
            }
        };
    });
    ib.addMixin(function() {
        var context = this;
        var userAgent = function(ua) {
            ua = (ua || window.navigator.userAgent).toString().toLowerCase();
            function checkUserAgent(ua) {
                var browser = {}, match = /(dolfin)[ \/]([\w.]+)/.exec(ua) || /(opera|opr)(?:.*version)?[ \/]([\w.]+)/.exec(ua) || /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)(?:.*version)?[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || /(trident)(?:.*? rv[ :]?([\w.]+))?/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+))?/.exec(ua) || [ "", "unknown" ];
                if (match[1] === "webkit") {
                    match = /(iphone|ipad|ipod)[\S\s]*os ([\w._\-]+) like/.exec(ua) || /(android)[ \/]([\w._\-]+);/.exec(ua) || [ match[0], "safari", match[2] ];
                } else if (match[1] === "mozilla") {
                    match[1] = "firefox";
                } else if (/polaris|natebrowser|([010|011|016|017|018|019]{3}\d{3,4}\d{4}$)/.test(ua)) {
                    match[1] = "polaris";
                } else if (match[1] === "trident" && match[2]) {
                    match[1] = "msie";
                } else if (match[1] === "opr") {
                    match[1] = "opera";
                }
                browser[match[1]] = true;
                browser.name = match[1];
                browser.version = setVersion(match[2]);
                return browser;
            }
            function setVersion(versionString) {
                var version = {}, versions = versionString ? versionString.split(/\.|-|_/) : [ "0", "0", "0" ];
                version.info = versions.join(".");
                version.major = versions[0] || "0";
                version.minor = versions[1] || "0";
                version.patch = versions[2] || "0";
                return version;
            }
            function checkPlatform(ua) {
                if (isPc(ua)) {
                    return "pc";
                } else if (isTablet(ua)) {
                    return "tablet";
                } else if (isMobile(ua)) {
                    return "mobile";
                } else {
                    return "";
                }
            }
            function isPc(ua) {
                if (ua.match(/linux|windows (nt|98)|macintosh/) && !ua.match(/android|mobile|polaris|lgtelecom|uzard|natebrowser|ktf;|skt;/)) {
                    return true;
                }
                return false;
            }
            function isTablet(ua) {
                if (ua.match(/ipad/) || ua.match(/android/) && !ua.match(/mobi|mini|fennec/)) {
                    return true;
                }
                return false;
            }
            function isMobile(ua) {
                if (!!ua.match(/ip(hone|od)|android.+mobile|windows (ce|phone)|blackberry|symbian|webos|firefox.+fennec|opera m(ob|in)i|polaris|iemobile|lgtelecom|nokia|sonyericsson|dolfin|uzard|natebrowser|ktf;|skt;/)) {
                    return true;
                } else {
                    return false;
                }
            }
            function checkOs(ua) {
                var os = {}, match = (/android/.test(ua) ? "android" : false) || (/like mac os x./.test(ua) ? "ios" : false) || (/(mac os)/.test(ua) ? "mac" : false) || (/polaris|natebrowser|([010|011|016|017|018|019]{3}\d{3,4}\d{4}$)/.test(ua) ? "polaris" : false) || (/(windows)/.test(ua) ? "windows" : false) || (/(linux)/.test(ua) ? "linux" : false) || (/webos/.test(ua) ? "webos" : false) || (/bada/.test(ua) ? "bada" : false) || (/(rim|blackberry)/.test(ua) ? "blackberry" : false) || "unknown";
                os[match] = true;
                os.name = match;
                return os;
            }
            function checkApp(ua) {
                var app = {}, match = /(crios)[ \/]([\w.]+)/.exec(ua) || /(daumapps)[ \/]([\w.]+)/.exec(ua) || [ "", "" ];
                if (match[1]) {
                    app.isApp = true;
                    app.name = match[1];
                    app.version = setVersion(match[2]);
                } else {
                    app.isApp = false;
                }
                return app;
            }
            return {
                ua: ua,
                browser: checkUserAgent(ua),
                platform: checkPlatform(ua),
                os: checkOs(ua),
                app: checkApp(ua)
            };
        };
        var result = userAgent(ib.window.navigator.userAgent);
        context.Browser = {
            os: result.os.name,
            name: result.browser.name,
            version: result.browser.version.major,
            platform: result.platform,
            ua: result.ua,
            analyUA: userAgent
        };
        context.isSmartDevice = /tablet|mobile/i.test(result.platform);
    });
    ib.addMixin(function() {
        var context = this, doc = ib.window.document;
        context.createCookie = function(name, value, days) {
            var date, expires;
            if (days) {
                date = new Date();
                date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
                expires = "; expires=" + date.toGMTString();
            } else {
                expires = "";
            }
            doc.cookie = name + "=" + value + expires + "; path=/";
        };
        context.readCookie = function(name) {
            var nameEQ = name + "=", ca = doc.cookie.split(";"), i, c;
            for (i = 0; i < ca.length; ++i) {
                c = ca[i];
                while (c.charAt(0) === " ") {
                    c = c.substring(1, c.length);
                }
                if (c.indexOf(nameEQ) === 0) {
                    return c.substring(nameEQ.length, c.length);
                }
            }
            return null;
        };
        context.eraseCookie = function(name) {
            ib.createCookie(name, "", -1);
        };
    });
    ib.addMixin(function() {
        var context = this, w = ib.window, FnCollection;
        (FnCollection = function(option) {
            var i, opt;
            this.functions = ib.Array([]);
            this.context = w;
            this.fireIndex = 0;
            this.isStop = false;
            if (ib.isString(option)) {
                option = option.split(ib.splitExp);
                for (i = 0; opt = option[i++]; ) {
                    this[opt.toLowerCase()] = true;
                }
            }
        }).prototype = {
            add: function(fn) {
                var self = this, memory;
                if (ib.isFunction(fn)) {
                    if (self.memory && ib.isObject(self.memory)) {
                        memory = self.memory;
                        self._fire([ fn ], memory.context, memory.args, 0);
                        self.memory = true;
                    }
                    if (self.unique) {
                        !self.has(fn) && self.functions.push(fn);
                    } else {
                        self.functions.push(fn);
                    }
                }
                return self;
            },
            remove: function(fn) {
                if (ib.isFunction(fn)) {
                    this.functions.remove(fn);
                }
                return this;
            },
            empty: function() {
                var self = this;
                self.functions = ib.Array([]);
                self.fireIndex = 0;
                return self;
            },
            has: function(fn) {
                return this.functions.indexOf(fn) > -1 ? true : false;
            },
            get: function(index) {
                var self = this;
                return ib.isInteger(index) ? self.functions.array[index] : self.functions.array;
            },
            setContext: function(context) {
                this.context = context;
                return this;
            },
            fire: function() {
                var self = this, functions = self.functions.array, context = self.context, args = arguments;
                self.memory && (self.memory = {
                    context: context,
                    args: args
                });
                self._fire(functions, context, args, self.fireIndex);
                return self;
            },
            _fire: function(functions, context, args, fireIndex) {
                var self = this, returnValue, index, fn;
                for (index = fireIndex; fn = functions[index++]; ) {
                    returnValue = fn.apply(context, args);
                    if (self.stoponfalse && returnValue === false) {
                        self.fireIndex = index - 1;
                        break;
                    }
                }
                if (self.dual) {
                    self.empty();
                }
            },
            refire: function() {
                var self = this;
                self.fireIndex = 0;
                self.fire.apply(self, arguments);
                return self;
            },
            length: function() {
                return this.functions.length();
            }
        };
        context.fnCollection = function(option) {
            return new FnCollection(option);
        };
    });
    ib.addMixin(function() {
        var context = this, w = ib.window, FnDeferred, bundles = [ [ "done", "resolve", "resolved" ], [ "fail", "reject", "rejected" ], [ "progress", "notify" ] ], iterator = ib.iterator(bundles);
        (FnDeferred = function() {
            this.doneCollection = ib.fnCollection("dual memory");
            this.failCollection = ib.fnCollection("dual memory");
            this.progressCollection = ib.fnCollection("memory");
            this.groupSize = 0;
        }).prototype = {
            grouping: function(result) {
                return ib.isUndefined(result) ? "deferredGroup" : result;
            },
            group: function() {
                var i, len = arguments.length, groupSize = 0;
                for (i = 0; i < len; i++) {
                    arguments[i] === "deferredGroup" && groupSize++;
                }
                this.groupSize = groupSize;
                return this;
            }
        };
        var deferred = function() {
            var deferred = this, coll, def;
            iterator.foreach(function(i, bundle) {
                deferred[bundle[0]] = function(fn) {
                    if (ib.isFunction(fn)) {
                        this[bundle[0] + "Collection"].add(fn);
                    }
                    return this;
                };
                deferred[bundle[1]] = bundle[2] ? function() {
                    def = this;
                    def.args = (def.args || []).concat(ib.arraySlice.call(arguments, 0));
                    if (--def.groupSize === 0) {
                        coll = def[bundle[0] + "Collection"].setContext({
                            state: bundle[2]
                        });
                        coll.fire.apply(coll, def.args);
                    }
                    return def;
                } : function() {
                    def = this;
                    coll = def[bundle[0] + "Collection"];
                    coll.fire.apply(coll, ib.arraySlice.call(arguments, 0));
                    return def;
                };
            });
        };
        deferred.call(FnDeferred.prototype);
        context.fnDeferred = function() {
            return new FnDeferred();
        };
    });
    ib.addMixin(function() {
        var context, FnWrapper;
        context = this;
        (FnWrapper = function(object, options) {
            this.object = object;
            this._when = {};
            this._define = {};
            this._wrapped = {};
        }).prototype = {
            _wrap: function(name) {
                var that, object;
                that = this;
                object = that.object;
                object[name] = function(name, fn) {
                    return function() {
                        var args;
                        args = arguments.length ? context.arraySlice.call(arguments, 0) : [];
                        if (that._when[name] == null || that._when[name] && that._when[name].apply(this, args) !== false) {
                            if (that._define[name]) {
                                return that._define[name].apply(this, [ name, fn ].concat(args));
                            } else {
                                return fn.apply(this, args);
                            }
                        }
                    };
                }(name, object[name]);
            }
        };
        context.iterator([ "when", "define" ]).foreach(function(index, name) {
            FnWrapper.prototype[name] = function(name) {
                return function(fnName, validate) {
                    var that, object, temp, e, fn;
                    that = this;
                    object = that.object;
                    if (context.isString(fnName) && context.isFunction(validate)) {
                        temp = fnName;
                        fnName = {};
                        fnName[temp] = validate;
                    }
                    if (context.isObject(fnName)) {
                        for (e in fnName) {
                            fn = fnName[e];
                            if (context.isFunction(temp = object[e])) {
                                if (!that._wrapped[e]) {
                                    that._wrap(e);
                                    that._wrapped[e] = true;
                                }
                                that["_" + name][e] = fn;
                            }
                        }
                    }
                    return that;
                };
            }(name);
        });
        context.fnWrapper = function(object) {
            if (context.isObject(object)) {
                return new FnWrapper(object);
            }
        };
    });
    ib.addMixin(function() {
        var context = this, Observer;
        (Observer = function() {
            this.listeners = {};
        }).prototype = {
            addListener: function(type, func, context, namespace) {
                var self = this, handlers;
                (handlers = self.listeners[type]) || (handlers = self.listeners[type] = []);
                handlers.push({
                    func: func,
                    context: context || window,
                    namespace: namespace || "default"
                });
                return self;
            },
            removeListener: function(type, func) {
                var self = this, listeners = self.listeners, handlers = listeners[type], i, len;
                if (handlers) {
                    if (func) {
                        for (i = 0, len = handlers.length; i < len; ++i) {
                            if (func === handlers[i].func) {
                                handlers.splice(i, 1);
                                i--;
                                len--;
                                if (handlers.length === 0) {
                                    delete listeners[type];
                                    break;
                                }
                            }
                        }
                    } else {
                        handlers = [];
                    }
                } else if (arguments.length === 0) {
                    self.listeners = {};
                }
                return self;
            },
            fireEvent: function(type, data, namespace) {
                var listeners = this.listeners, handlers = listeners[type], i, handler;
                if (!listeners || !handlers) {
                    return;
                }
                for (i = 0; handler = handlers[i++]; ) {
                    if (namespace && namespace !== handler.namespace) {
                        continue;
                    }
                    if (!handler.func.call(handler.context, {
                        type: type,
                        data: data
                    })) {
                        return false;
                    }
                }
                return true;
            }
        };
        context.observer = function() {
            return new Observer();
        };
    });
    ib.addMixin(function() {
        var context = this, w = ib.window, doc = w.document, eleWrapMap = {
            thead: {
                depth: 1,
                prefix: "<table>",
                postfix: "</table>"
            },
            tbody: {
                depth: 1,
                prefix: "<table>",
                postfix: "</table>"
            },
            tfoot: {
                depth: 1,
                prefix: "<table>",
                postfix: "</table>"
            },
            tr: {
                depth: 2,
                prefix: "<table><tbody>",
                postfix: "</tbody></table>"
            },
            th: {
                depth: 3,
                prefix: "<table><tbody><tr>",
                postfix: "</tr></tbody></table>"
            },
            td: {
                depth: 3,
                prefix: "<table><tbody><tr>",
                postfix: "</tr></tbody></table>"
            },
            option: {
                depth: 1,
                prefix: "<select>",
                postfix: "</select>"
            },
            area: {
                depth: 1,
                prefix: "<map>",
                postfix: "</map>"
            }
        }, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta = {
            "\b": "\\b",
            "	": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            '"': '\\"',
            "\\": "\\\\"
        };
        function quote(string) {
            return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                var c = meta[a];
                return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' : '"' + string + '"';
        }
        function str(key, holder) {
            var value = holder[key], partial, prop, e, i, len;
            switch (ib.type(value)) {
              case "string":
                return quote(value);

              case "number":
              case "boolean":
              case "null":
                return "" + value;

              case "array":
                partial = [];
                for (i = 0, len = value.length; i < len; i++) {
                    partial.push(str(i, value));
                }
                return partial.length === 0 ? "[]" : "[" + partial.join(",") + "]";

              case "object":
                partial = [];
                for (e in value) {
                    if (value.hasOwnProperty(e)) {
                        if (prop = str(e, value)) {
                            partial.push(quote(e) + ":" + prop);
                        }
                    }
                }
                return partial.length === 0 ? "{}" : "{" + partial.join(",") + "}";
            }
        }
        context.string2html = function(string) {
            var match, parsed, docFrag, docFragDiv, div, childNodes, childNode, eles = [], ele, i, tag, wrap, depth = 0;
            if (match = ib.isSingleTag.exec(string)) {
                parsed = [ doc.createElement(match[1]) ];
            } else {
                parsed = [];
                docFrag = doc.createDocumentFragment();
                docFragDiv = docFrag.appendChild(doc.createElement("div"));
                tag = (/\<(\w+)\s*?/.exec(string) || [ "", "" ])[1].toLowerCase();
                if (wrap = eleWrapMap[tag]) {
                    depth = wrap.depth;
                    string = wrap.prefix + string + wrap.postfix;
                }
                docFragDiv.innerHTML = string;
                while (depth--) {
                    docFragDiv = docFragDiv.lastChild;
                }
                childNodes = docFragDiv.childNodes;
                for (i = 0; childNode = childNodes[i++]; ) {
                    eles.push(childNode);
                }
                docFragDiv.textContent = "";
                while (docFragDiv.firstChild) {
                    docFragDiv.removeChild(docFragDiv.firstChild);
                }
                docFragDiv = docFrag.lastChild;
                if (docFragDiv) {
                    docFrag.removeChild(docFragDiv);
                }
                for (i = 0; ele = eles[i++]; ) {
                    docFrag.appendChild(ele);
                }
                childNodes = docFrag.childNodes;
                for (i = 0; childNode = childNodes[i++]; ) {
                    parsed.push(childNode);
                }
                docFrag = docFragDiv = null;
            }
            return parsed;
        };
        context.string2xml = function(string) {
            var doc;
            if (window.DOMParser) {
                doc = new DOMParser().parseFromString(string, "application/xml");
            } else {
                doc = new ActiveXObject("Microsoft.XMLDOM");
                doc.async = "false";
                doc.loadXML(string);
                doc.childNodes[0].nodeName === "xml" && doc.removeChild(doc.childNodes[0]);
            }
            return doc;
        };
        context.xml2string = function(xml) {
            var string;
            if (window.XMLSerializer) {
                string = new XMLSerializer().serializeToString(xml);
            } else {
                string = xml.xml;
            }
            return string;
        };
        context.json = {
            parse: function(text, nonSyntaxCheck) {
                text = ib.String("" + text).trim();
                if (nonSyntaxCheck) {
                    return new Function("return " + text)();
                }
                if (w.JSON && w.JSON.parse) {
                    return w.JSON.parse(text);
                }
                if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
                    return new Function("return " + text)();
                }
                throw new SyntaxError("JSON.parse");
            },
            stringify: function(json) {
                var string;
                if (w.JSON && w.JSON.stringify) {
                    string = w.JSON.stringify(json);
                } else {
                    string = str("", {
                        "": json
                    });
                }
                return string;
            },
            minify: function(json) {
                var inReg = /(\")|(\/\/)|(\r|\n)|(\/\*)|(\*\/)/g, isInString = false, isInSingleCmt = false, isInMultiCmt = false, result = [], from, leftContext, rightContext, temp, dbQuotationCh;
                while (exec = inReg.exec(json)) {
                    leftContext = RegExp.leftContext;
                    rightContext = RegExp.rightContext;
                    if (!isInSingleCmt && !isInMultiCmt) {
                        temp = leftContext.substring(from);
                        if (!isInString) {
                            temp = temp.replace(/[\r\n\s]*/g, "");
                        }
                        result.push(temp);
                    }
                    from = inReg.lastIndex;
                    if (exec[1] && !isInSingleCmt && !isInMultiCmt) {
                        dbQuotationCh = /\\*$/.exec(leftContext);
                        if (!isInString || !dbQuotationCh || dbQuotationCh[0].length % 2 == 0) {
                            isInString = !isInString;
                        }
                        --from;
                        rightContext = json.substring(from);
                    } else if (exec[2] && !isInString && !isInSingleCmt && !isInMultiCmt) {
                        isInSingleCmt = true;
                    } else if (exec[3] && !isInString && isInSingleCmt && !isInMultiCmt) {
                        isInSingleCmt = false;
                    } else if (exec[4] && !isInString && !isInSingleCmt && !isInMultiCmt) {
                        isInMultiCmt = true;
                    } else if (exec[5] && !isInString && !isInSingleCmt && isInMultiCmt) {
                        isInMultiCmt = false;
                    } else if (!isInSingleCmt && !isInMultiCmt && !/[\r\n\s]/.test(exec[0])) {
                        result.push(exec[0]);
                    }
                }
                result.push(rightContext);
                return result.join("");
            }
        };
    });
    ib.addMixin(function() {
        var context = this, doc = window.document, push = ib.arrayPush, attributeExp = /^\[[\w\W]+\]$/;
        function slice(eles, i, basket) {
            var ele;
            basket = basket || [];
            for (;ele = eles[i++]; ) {
                basket.push(ele);
            }
            eles = null;
            return basket;
        }
        function sId(context, query, basket) {
            var ele = context.getElementById ? context.getElementById(query) : document.getElementById(query);
            if (ele) {
                basket.push(ele);
                ele = null;
                return basket;
            }
        }
        function sClass(context, query, basket) {
            var eles;
            if (context.getElementsByClassName) {
                eles = context.getElementsByClassName(query);
            } else {
                eles = function(className) {
                    var arrEle = [], classNameExp = new RegExp("(^| )" + className + "( |$)"), eles = context.getElementsByTagName("*"), ele, i;
                    for (i = 0; ele = eles[i++]; ) {
                        if (classNameExp.test(ele.className)) {
                            arrEle.push(ele);
                        }
                    }
                    ele = eles = null;
                    return arrEle;
                }(query);
            }
            if (eles) {
                push.apply(basket, slice(eles, 0));
                eles = null;
                return basket;
            }
        }
        function sTag(context, query, basket) {
            var eles = context.getElementsByTagName(query);
            if (eles) {
                push.apply(basket, slice(eles, 0));
                eles = null;
                return basket;
            }
        }
        function sAttr(context, selector, basket) {
            var match, query, attrNm, attrVal, i, ele;
            selector = ib.selectorAttrExp.exec(selector);
            if (selector[1]) {
                match = ib.selectorExp.exec(selector[1]);
                if (match[1]) {
                    basket = sId(context, match[1], basket);
                } else if (match[2]) {
                    basket = sClass(context, match[2], basket);
                } else if (match[3]) {
                    basket = sTag(context, match[3], basket);
                }
                attrNm = selector[2];
                for (i = 0; ele = basket[i]; i++) {
                    if (!((attrVal = ele.getAttribute(attrNm)) && (selector[3] ? attrVal === selector[3] : true))) {
                        basket.splice(i, 1);
                        --i;
                    }
                }
                return basket;
            }
        }
        function sMultiSelect(context, multiSelector, basket) {
            var selectors = multiSelector.split(/\,/g), selector, temp = [], i, selector;
            if (selectors && selectors.length > 0) {
                for (i = 0; selector = selectors[i++]; ) {
                    push.apply(basket, ib.selector_a(selector, context, []));
                }
                return ib.Array(basket).unique(true);
            }
        }
        context.selector_a = function(selector, context, basket) {
            var arrSelector, index, corrIndex, temp, i, len, target, result, eles, match, query;
            if (ib.isNativeCode(context.querySelectorAll)) {
                eles = slice(context.querySelectorAll(selector), 0, basket);
            } else {
                arrSelector = ib.String(selector).trim().split(/\s/);
                index = arrSelector.length - 1;
                match = ib.selectorExp.exec(arrSelector[index]);
                if (match) {
                    if (match[1]) {
                        eles = sId(context, match[1], basket);
                    } else if (match[2]) {
                        eles = sClass(context, match[2], basket);
                    } else if (match[3]) {
                        eles = sTag(context, match[3], basket);
                    } else if (match[5]) {
                        attributeExp.test(match[5]) && (match[5] = "*" + match[5]);
                        eles = sAttr(context, match[5], basket);
                    } else if (match[4]) {
                        eles = sMultiSelect(context, selector, basket);
                    }
                }
                if (index > 0 && eles && eles.length > 0) {
                    temp = slice(eles, 0);
                    while (index > 0) {
                        corrIndex = [];
                        selector = arrSelector[--index];
                        for (i = 0, len = temp.length; i < len; i++) {
                            result = false;
                            target = temp[i];
                            while (target = target.parentNode) {
                                if (ib.selector_e(selector, target)) {
                                    result = true;
                                    temp[i] = target;
                                    break;
                                }
                            }
                            if (!result) {
                                eles.splice(i, 1);
                                temp.splice(i, 1);
                                --len;
                                --i;
                            }
                        }
                    }
                }
            }
            return eles;
        };
        function eId(context, query) {
            return context.id === query;
        }
        function eClass(context, query) {
            return (" " + context.className + " ").indexOf(" " + query + " ") > -1;
        }
        function eTag(context, query) {
            return context.nodeName.toLowerCase() === query.toLowerCase();
        }
        function eAttr(context, selector) {
            var match, attrNm, attrVal, selVal, returnValue;
            selector = ib.selectorAttrExp.exec(selector);
            if (selector[1]) {
                match = ib.selectorExp.exec(selector[1]);
                if (match[1]) {
                    returnValue = eId(context, match[1]);
                } else if (match[2]) {
                    returnValue = eClass(context, match[2]);
                } else if (match[3]) {
                    returnValue = eTag(context, match[3]);
                } else if (match[5]) {
                    returnValue = eAttr(context, match[5]);
                    if (returnValue) {
                        return returnValue;
                    }
                }
                returnValue = returnValue && (attrVal = context[attrNm = selector[2]] || (context.attributes[attrNm] || {}).value || false) && ((selVal = selector[3]) ? attrVal == selVal : true);
            }
            return returnValue;
        }
        function eMultiSelect(context, multiSelector) {
            var selectors = multiSelector.split(/\,/g), selector, i;
            if (selectors && selectors.length > 0) {
                for (i = 0; selector = selectors[i++]; ) {
                    if (ib.selector_e(selector, context, sMultiSelect)) {
                        return selector;
                    }
                }
            }
            return false;
        }
        context.selector_e = function(selector, context, sMultiSelect) {
            var match, ele;
            match = ib.selectorExp.exec(selector);
            if (match) {
                if (match[1]) {
                    ele = eId(context, match[1]);
                } else if (match[2]) {
                    ele = eClass(context, match[2]);
                } else if (match[3]) {
                    ele = eTag(context, match[3]);
                } else if (match[5]) {
                    attributeExp.test(match[5]) && (match[5] = "*" + match[5]);
                    ele = eAttr(context, match[5]);
                } else if (match[4]) {
                    ele = sMultiSelect ? sMultiSelect(context, selector) : eMultiSelect(context, selector);
                }
            }
            return ele;
        };
    });
    ib.addMixin(function() {
        var context = this, string;
        function toCase(string, index, methodName) {
            return string.substring(0, index) + string.charAt(index)[methodName]() + string.substring(index + 1);
        }
        (string = function(str) {
            this.string = ib.isString(str) ? str : "";
        }).prototype = {
            trim: function(isMultiLine) {
                return isMultiLine ? this.string.replace(/^\s+|\s+$/gm, "") : this.string.replace(/^\s+|\s+$/g, "");
            },
            trimRight: function(isMultiLine) {
                return isMultiLine ? this.string.replace(/\s+$/gm, "") : this.string.replace(/\s+$/g, "");
            },
            trimLeft: function(isMultiLine) {
                return isMultiLine ? this.string.replace(/^\s+/gm, "") : this.string.replace(/^\s+/g, "");
            },
            padRight: function(character, length) {
                var string = this.string;
                while (string.length < length) {
                    string = string + character;
                }
                return string;
            },
            padLeft: function(character, length) {
                var string = this.string;
                while (string.length < length) {
                    string = character + string;
                }
                return string;
            },
            replaceAll: function(oldStr, newStr) {
                return this.string.replace(new RegExp(oldStr, "g"), newStr);
            },
            toUpperCase: function(index) {
                if (index != null) {
                    return toCase(this.string, index, "toUpperCase");
                } else {
                    return this.string.toUpperCase();
                }
            },
            toLowerCase: function(index) {
                if (index != null) {
                    return toCase(this.string, index, "toLowerCase");
                } else {
                    return this.string.toLowerCase();
                }
            }
        };
        context.String = function(str) {
            return new string(str);
        };
        context.String.capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };
    });
    ib.addMixin(function() {
        var context = this, w = ib.window, doc = w.document, sheetExp = /^([\w\W]+)\s+{([\w\W]+)}$/, extra = {}, StyleSheet;
        context.createStyle = function(rules, prefix) {
            var prefix = prefix || "", head, style, setRule;
            head = doc.getElementsByTagName("head")[0];
            if (head) {
                style = doc.createElement("style");
                style.type = "text/css";
                setRule = function(st) {
                    var acc = st.styleSheet ? {
                        style: st.styleSheet,
                        refer: "cssText"
                    } : {
                        style: st,
                        refer: "innerHTML"
                    };
                    return function(text) {
                        head.appendChild(style);
                        acc.style[acc.refer] += text + "\r\n";
                    };
                }(style);
                setRule(rules);
            }
            return style;
        };
        function getStyle(rule, style) {
            return rule.style[style];
        }
        function setStyle(rule, obj) {
            var e;
            for (e in obj) {
                rule.style[e] = obj[e];
            }
        }
        (StyleSheet = function(args) {
            var self = this, head = doc.getElementsByTagName("head")[0], style, sheet, index;
            if (head) {
                sheet = doc.styleSheets || doc.sheet;
                if (ib.isInteger(args)) {
                    self.styleSheet = sheet[args];
                } else if (ib.isElement(args) && args.nodeName.toLowerCase() === "style") {
                    self.styleSheet = args.sheet || args.styleSheet;
                } else {
                    style = doc.createElement("style");
                    style.type = "text/css";
                    head.appendChild(style);
                    self.styleSheet = sheet[sheet.length - 1];
                }
                if (ib.isEmptyObject(extra) && self.styleSheet) {
                    extra.insertRule = self.styleSheet.insertRule ? "insertRule" : "addRule";
                    extra.deleteRule = self.styleSheet.deleteRule ? "deleteRule" : "removeRule";
                    extra.cssRules = self.styleSheet.cssRules ? "cssRules" : "rules";
                }
            }
        }).prototype = {
            addCssRule: function(rule) {
                var self = this, sheet = self.styleSheet, match, length = sheet[extra.cssRules].length;
                if (sheet.insertRule) {
                    sheet.insertRule(rule, length);
                } else {
                    match = sheetExp.exec(rule);
                    sheet.addRule(match[1], match[2], length);
                }
                return length;
            },
            getCssRule: function(selector) {
                var self = this, sheet = self.styleSheet, rules = sheet[extra.cssRules], rule, corRule, index = -1, i;
                if (ib.isString(selector)) {
                    for (i = 0; rule = rules[i++]; ) {
                        if ((rule.selectorText || "").toLowerCase() === selector) {
                            corRule = rule;
                            index = i - 1;
                            break;
                        }
                    }
                } else if (ib.isInteger(selector)) {
                    corRule = rules[selector];
                    index = selector;
                }
                return corRule ? {
                    style: function(style, value) {
                        var temp;
                        if (ib.isString(style) && ib.isString(value)) {
                            temp = style;
                            style = {};
                            style[temp] = value;
                        }
                        if (ib.isObject(style)) {
                            setStyle(corRule, style);
                            return this;
                        } else if (ib.isString(style)) {
                            return getStyle(corRule, style);
                        }
                    },
                    remove: function() {
                        if (index > -1) {
                            sheet[extra.deleteRule](index);
                        }
                    }
                } : undefined;
            }
        };
        context.styleSheet = function(args) {
            return new StyleSheet(args);
        };
        context.searchDir = function(fileName) {
            var scripts = doc.getElementsByTagName("script"), script, dir, href, match, i, j, len;
            var script_src="";
            for (i = 0; script = scripts[i++]; ) {
                //if(script.src.indexOf(w.location.protocol)==-1){
                //    script_src = w.location.protocol+"//"+w.location.host+script.src;
                //}
                if(_ib!=undefined){
                    if (_ib.Browser.name === 'ie' && _ib.Browser.version === '7') {
                        scriptPath = window.location.protocol + '//' + window.location.host + script.src;
                    }else{
                        scriptPath = script.src;
                    }
                }
                else {
                    scriptPath = script.src;
                }

                if (scriptPath  && scriptPath .match(new RegExp("(^|/)(?:[._-a-zA-Z]*?)" + fileName + "(?:[._-a-zA-Z]*?).js([?#].*)?$", "i"))) {
                    dir = scriptPath .replace(/[^\/]+$/, "");
                    if (dir.indexOf(w.location.protocol) < 0) {
                        href = w.location.href.replace(/[^\/]+$/, "");
                        match = dir.match(/\.\.\//g) || "";
                        for (j = 0, len = match.length; j < len; j++) {
                            href = href.replace(/[\d._-a-zA-Z]+\/$/i, "");
                            dir = dir.replace(/\.\.\//, "");
                        }
                        scripts = null;
                        return href + dir.replace(/^(\.\/|\/)/, "");
                    }
                    break;
                }
            }
            scripts = null;
            return dir;
        };
    });
    ib.addMixin(function() {
        var context = this, w = ib.window, doc = w.document, iterator = ib.iterator([ "get", "post" ]), CreateRequest = w.XMLHttpRequest ? function() {
            return new XMLHttpRequest();
        } : function() {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (ex1) {
                try {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                } catch (ex2) {}
            }
        }, hrefExp = /^((?:http|https)\:)(?:\/\/([\w\W]+)(?:\:([\d]+)|)|)([^?]+)/, absUrlExp = /^\//, xmlExp = /\.xml$/, setting = {
            requestMethod: {
                get: "GET",
                post: "POST",
                head: "HEAD"
            },
            isAsync: true,
            headers: {
                xRequestedWith: "XMLHttpRequest",
                contentType: "application/x-www-form-urlencoded; charset=utf-8"
            },
            accept: {
                "*": "*/*",
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            responseType: {
                text: "responseText",
                xml: "responseXML"
            },
            readyState: {
                "0": "unitializaed",
                "1": "loading",
                "2": "loaded",
                "3": "interactive",
                "4": "complete"
            },
            parse: {
                text: w.String,
                xml: ib.string2xml,
                json: function(json, nonSyntaxCheckJson, jsonMinify) {
                    return ib.json.parse(jsonMinify ? ib.json.minify(json) : json, nonSyntaxCheckJson);
                }
            }
        }, supported = {
            timeout: function() {
                return CreateRequest().timeout != null ? true : false;
            }()
        }, requestLocation = function() {
            var href;
            return (href = location.protocol + "//" + location.host + location.pathname).substring(0, href.lastIndexOf("/") + 1);
        }(), XHRequest;
        function addParam(key, value, query) {
            query.push(encodeURIComponent(key) + "=" + encodeURIComponent(ib.isFunction(value) ? value(key) : value == null ? "" : value));
        }
        function stringParam(param, baseKey, query, onlyString) {
            var paramList, paramItem, i, len;
            paramList = param.split(/\&/g);
            for (i = 0, len = paramList.length; i < len; ++i) {
                paramItem = paramList[i].split(/\=/g);
                if (baseKey != null) {
                    if (onlyString === undefined) {
                        addParam(paramItem[0], paramItem[1], query);
                    } else if (onlyString === false) {
                        addParam(baseKey, paramItem[0], query);
                    }
                } else {
                    addParam(baseKey + "[" + paramItem[0] + "]", paramItem[1], query);
                }
            }
        }
        function convertParam(param, baseKey, query, onlyString) {
            var type;
            query = query || [];
            switch (type = ib.type(param)) {
              case "object":
              case "array":
                ib.iterator(param).foreach(function(index, value) {
                    var key = baseKey ? baseKey + "[" + index + "]" : index;
                    type === "object" ? convertParam(param[index], key, query, false) : addParam(key, param[index], query);
                }, false);
                break;

              case "function":
                baseKey && convertParam(param(), baseKey, query, onlyString);
                break;

              case "number":
              case "boolean":
                addParam(baseKey, param, query);
                break;

              case "string":
                stringParam(param, baseKey || "", query, onlyString);
                break;
            }
            return baseKey == null && query.join("&");
        }
        function parseResponseHeaders(headerStr) {
            var headers = {}, headerPairs, headerPair, i, len, index, key, val;
            if (!headerStr) {
                return headers;
            }
            headerPairs = headerStr.split("\r\n");
            for (i = 0, len = headerPairs.length; i < len; i++) {
                headerPair = headerPairs[i];
                index = headerPair.indexOf(": ");
                if (index > 0) {
                    key = headerPair.substring(0, index);
                    val = headerPair.substring(index + 2);
                    headers[key] = val;
                }
            }
            return headers;
        }
        (XHRequest = function(options) {
            this.request = CreateRequest();
            this.open = false;
        }).prototype = {
            sendRequest: function(options) {
                var type = setting.requestMethod[(options.type || "").toLowerCase()], accept = options.accept, param = options.param || null, tempParam = "", cache = options.cache, readyState, success = options.success, fail = options.fail, self = this, url = options.url || "", responseData, responseHeader, errorMsg, timeout = options.timeout, nativeAbort, timeoutId, state, isAsync = options.isAsync, contentType = options.contentType, headers = {}, e;
                if (!hrefExp.test(url)) {
                    if (!absUrlExp.test(url)) {
                        url = requestLocation + url;
                    }
                }
                self.request.onreadystatechange = function () {
                    var request = self.request;
                    if (request.readyState === 3) {
                        try {
                            responseHeader = parseResponseHeaders(request.getAllResponseHeaders());
                        } catch (e) {}
                    }
                    if (request.readyState === 4) {
                        if (state !== "abort") {
                            clearTimeout(timeoutId);
                            if (request.status === 200 || request.status === 0) {
                                try {
                                    responseData = (setting.parse[accept] || setting.parse.text)(request.responseText, options.nonSyntaxCheckJson, options.jsonMinify);
                                    success && success(responseData, responseHeader);
                                } catch (e) {
                                    fail && fail(request, responseHeader, e);
                                }
                            } else {
                                fail && fail(request, responseHeader, {
                                    message: "request status error"
                                });
                            }
                        } else {
                            self.request.abort = nativeAbort = null;
                        }
                        self.request.onreadystatechange = function() {};
                    }
                };
                if (param && !ib.isString(param)) {
                    param = convertParam(param);
                }
                if (type === "GET") {
                    contentType && (headers["Content-Type"] = contentType);
                    if (param) {
                        if (url != null) {
                            url += "?" + param;
                        }
                        param = null;
                    }
                } else if (type === "POST") {
                    headers["Content-Type"] = contentType || setting.headers.contentType;
                    if (cache === false) {
                        url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
                    }
                }
                self._openRequest(type, url, isAsync);
                if (isAsync !== false) {
                    if (ib.isInteger(timeout)) {
                        timeoutId = setTimeout(function () {
                            self.request.abort();
                        }, timeout);
                        nativeAbort = self.request.abort;
                        self.request.abort = function () {
                            if (self.request) {
                                nativeAbort.call(self.request);
                            }
                            state = "abort";
                            fail && fail(state);
                        };
                    }
                }
                headers["X-Requested-With"] = setting.headers.xRequestedWith;
                headers["Accept"] = setting.accept[accept] ? setting.accept[accept] + ", " + setting.accept["*"] : setting.accept["*"];

                if (options.reqHeaders) {
                    if (options.reqHeaders.ReqHeader) {
                        for (header in options.reqHeaders.ReqHeader) {
                            headers[header] = options.reqHeaders.ReqHeader[header];
                            self._setRequestHeader(header, headers[header]);

                        }
                    }
                }

                for (header in options.reqHeaders) {
                    if (options.reqHeaders.ReqHeader) {
                    } else {
                        headers[header] = options.reqHeaders[header];
                        self._setRequestHeader(header, headers[header]);
                    }
                }
                try{
                    self.request.send(param);
                }catch(e){

                }

            },
            _setRequestHeader: function(name, value) {
                var self = this;
                if (self.request && self.open) {
                    self.request.setRequestHeader(name, value);
                }
            },
            _openRequest: function(type, url, async, name, password) {
                var self = this;
                self.open = true;
                self.request.open(type, url, async === undefined ? true : async, name || "", password || "");
            }
        };
        iterator.foreach(function(i, type) {
            context[type] = function(options) {
                return new XHRequest().sendRequest({
                    type: type,
                    accept: options.accept,
                    param: options.param,
                    url: options.url,
                    reqHeaders: options.reqHeaders,
                    jsonMinify: options.jsonMinify,
                    isAsync: options.isAsync,
                    timeout: options.timeout,
                    nonSyntaxCheckJson: options.nonSyntaxCheckJson,
                    contentType: options.contentType,
                    success: options.success,
                    fail: options.fail
                });
            };
        });
        context.xRequest = function() {
            return new XHRequest();
        };
        context.net = function() {
            var xhObj = new XHRequest();
            function request(options) {
                xhObj.sendRequest(options);
            }
            return {
                request: request
            };
        };
    });
    ib.addMixin(function() {
        var context = this, Color, max = Math.max, min = Math.min;
        function isHex(value) {
            if (/^#?([a-fA-F\d]{3}|[a-fA-F\d]{6})$/.test(value)) {
                return true;
            } else {
                return false;
            }
        }
        function isObj(value) {
            var r, g, b;
            if (ib.isObject(value) && "r" in value && ib.isInteger(value.r) && "g" in value && ib.isInteger(value.g) && "b" in value && ib.isInteger(value.b)) {
                return true;
            } else {
                return false;
            }
        }
        function hexFormater(value) {
            var hex;
            value = value.replace(/^#?([a-fA-F\d])([a-fA-F\d])([a-fA-F\d])$/i, function($1, $2, $3, $4) {
                return $2 + $2 + $3 + $3 + $4 + $4;
            });
            hex = /^#?([a-fA-F\d]{2})([a-fA-F\d]{2})([a-fA-F\d]{2})$/i.exec(value);
            return {
                r: parseInt(hex[1], 16),
                g: parseInt(hex[2], 16),
                b: parseInt(hex[3], 16)
            };
        }
        function objFormater(value) {
            return {
                r: rgbValidation(value.r),
                g: rgbValidation(value.g),
                b: rgbValidation(value.b)
            };
        }
        function rgbValidation(value) {
            return value < 0 ? 0 : value > 255 ? 255 : value;
        }
        function colorFormater(value) {
            return isHex(value) ? hexFormater(value) : isObj(value) ? objFormater(value) : null;
        }
        (Color = function(color) {
            this.color = colorFormater(color);
        }).prototype = {
            brightness: function() {
                var color = this.color;
                if (!color) {
                    return null;
                }
                return (color.r * 299 + color.g * 587 + color.b * 114) / 1e3;
            },
            difference: function(color) {
                var color1 = this.color, color2 = colorFormater(color);
                if (!color1 || !color2) {
                    return null;
                }
                return max(color1.r, color2.r) - min(color1.r, color2.r) + (max(color1.g, color2.g) - min(color1.g, color2.g)) + (max(color1.b, color2.b) - min(color1.b, color2.b));
            }
        };
        context.color = function(value) {
            return new Color(value);
        };
    });
    ib.addMixin(function() {
        var context = this, Template;
        (Template = function(template) {
            var self = this;
            self.template = template;
            self.templateProperties = [];
        }).prototype = {
            encodeSideHead: /\{\{([\w]+)}}/g,
            htmlEncodeSideHead: /\{\$([\w]+)}/g,
            compile: function() {
                var self = this, template = self.template, templateProperties = self.templateProperties = [], fn, code;
                code = "var e = ib.htmlEncode;with(object||{}){return '" + self.getEncodeTemplate() + "';}";
                try {
                    fn = new Function("object", code);
                } catch (e) {
                    throw new Error("Template.complie() throw Exception");
                }
                return fn;
            },
            getEncodeTemplate: function() {
                var self = this, template = self.template;
                return template.replace(self.encodeSideHead, function($1, $2) {
                    self.templateProperties.push($2);
                    return "'+" + $2 + "+'";
                }).replace(self.htmlEncodeSideHead, function($1, $2) {
                    self.templateProperties.push($2);
                    return "'+(e(" + $2 + "))+'";
                });
            }
        };
        context.template = function(str) {
            return new Template(str);
        };
        context.htmlEncode = function(html) {
            return html.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };
    });
    ib.addMixin(function() {
        var that, console, Logger;
        that = this;
        console = that.window.console;
        (Logger = function(options) {
            this.options = {
                display: true,
                o: function() {
                    console.log.apply(console, ib.arraySlice.call(arguments, 0));
                }
            };
            ib.Object.merge(this.options, options);
        }).prototype = {
            log: function() {
                var that;
                that = this;
                if (that.options.display) {
                    that.options.o.apply(that, ib.arraySlice.call(arguments, 0));
                }
            }
        };
        that.logger = function(options) {
            return new Logger(options);
        };
    });
    ib.addMixin(function() {
        var context = this;
        context.ui = {
            plugin: function(uiComponent, prefix) {
                var base = context.ui, name, proto, camelName;
                proto = uiComponent.fn || uiComponent.prototype || uiComponent;
                name = (prefix || "") + (proto.options.NAME || "undefined");
                camelName = name.replace(/^\S/, function($1) {
                    return $1.toUpperCase();
                });
                base[name] = uiComponent;
                context.fn[name] = function(options) {
                    var self = this;
                    self.foreach(function() {
                        ib.cache._addData(this, name, ib.type(uiComponent) === "function" ? new uiComponent(this, options) : ib.Object.make(uiComponent, this, options));
                    });
                    return self;
                };
                context.fn["un" + camelName] = function() {
                    var self = this, c;
                    self.foreach(function() {
                        if (c = ib.cache._getData(this, name)) {
                            c._destroy && c._destroy();
                        }
                        ib.cache._removeData(this, name);
                    });
                    return self;
                };
                context.fn["get" + camelName] = function() {
                    return this.data(name);
                };
            }
        };
    });
})(window, window._ib || undefined);
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\modules/ib.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\modules/IBLicense.js

(function(H, L, l) {
          // 아래 한줄은 아이비스타 개발모드에서만 사용됨(한 줄 없으면 IBSheet Version incorrect 나옴 (빌드 전이므로 빌드날짜가 안들어가서 발생함)
          if(l.indexOf("%")>-1){var today = new Date();var mm = today.getMonth()+1;var dd = today.getDate();if(mm<10){mm='0'+mm;}if(dd<10){dd='0'+dd;}l = today.getFullYear()+mm+dd;}

          var D = "",
              c = [
                  [(0xDE < (58.90E1, 0x1E4) ? (46., 91) : (0x124, 44)), ((4.16E2, 30.) <= 0x172 ? (128., 73) : (13., 76.)), (0x231 > (72., 9.370E2) ? (56., 7) : (139.70E1, 28.8E1) < (0xD1, 125) ? (10.450E2, "v") : 53. >= (92., 25) ? (0x19B, 66) : (131.1E1, 88)), (63.90E1 > (4., 0xF) ? (0x19F, 32) : (0x207, 83) > (0x1A2, 23.40E1) ? (118, "O") : (1.04E2, 119.) < 72 ? (0x4F, 'k') : (95.2E1, 37.6E1)), (1.46E3 >= (50.40E1, 7.78E2) ? (0x1D6, 83) : (108.9E1, 4) >= (0x10D, 0x243) ? (0x180, 2.90E1) : (59., 126.80E1)), ((84., 2.7E2) > 0x1C ? (19., 104) : (0x16A, 77.)), (5.59E2 <= (72, 0x257) ? (0x226, 101) : (38, 8.9E1) <= 8.1E1 ? 88. : (48., 66.)), ((0x1B4, 0x64) >= (66, 78) ? (0x81, 101) : (25., 0x1BE)), ((1.8E2, 7.46E2) >= 0x15B ? (0x1A1, 116) : (0x1E6, 0x15D)), ((0x1C8, 138) <= (0x51, 1.76E2) ? (149, 32) : (68.7E1, 17.0E1)), ((0x88, 78) <= (116.5E1, 5.29E2) ? (127, 55) : (112, 1.3840E3)), ((5.100E2, 31.0E1) <= (0x158, 22) ? (0x93, "D") : (35.5E1, 0x141) >= 142 ? (82., 93) : (4.19E2, 0x30))],
                  [91, ((60., 22.6E1) >= 3.550E2 ? 81.60E1 : (0x9A, 149) < (13.9E2, 0x1B6) ? (33., 73) : (1.3760E3, 7.33E2)), (0xB1 <= (57.5E1, 0xA9) ? 0x1A8 : (120, 0x21C) >= (0x1DA, 0x1BB) ? (141., 66) : (1.288E3, 6.29E2)), (123. > (15, 0x1D7) ? 56 : 57.1E1 <= (12.780E2, 1.274E3) ? (0x253, 79) : (12., 1.217E3) > 1.358E3 ? 0x199 : (1.1500E3, 0xEF)), 114, 103, 35, 32, 51, 93],
                  [((0x1C3, 111.) <= 71. ? 94. : (0xA3, 48) <= 2.1E1 ? (30, "n") : (0x248, 80) > 42 ? (75, 91) : (0x1FC, 42)), 73, 66, 79, 114, ((95, 0x1F6) < 8.36E2 ? (102, 103) : (41., 4) >= (6.15E2, 0xDD) ? 30.90E1 : (11.36E2, 122.4E1) < 11. ? (0x198, 'T') : (0x135, 0xAD)), 35, 32, ((42., 139) > (78., 0x20C) ? '\0' : (0x120, 0xFF) > 13.18E2 ? (121.80E1, "k") : (11.4E2, 0x1CE) >= 15.4E1 ? (67., 53) : (0xD, 79)), 93]
              ],
              t = [
                  [(68.7E1 >= (60, 0x71) ? (117., 32) : (49, 0xFD)), (73 <= (3.75E2, 67.7E1) ? (0x108, 76) : (28, 0x1B2)), 105, ((7.67E2, 115.) >= 0xF6 ? 69 : (144, 14.63E2) > (0x247, 7.66E2) ? (59., 99) : (58.6E1, 0x243)), 101, 110, 115, 101, ((79., 0xD4) <= (34, 116) ? 74.10E1 : 0x13 > (0x2F, 2.2E1) ? (47.1E1, "T") : (86.10E1, 0x176) <= 0x1B7 ? (0x1A1, 32) : (19., 0x17A)), (0xC <= (92.4E1, 38.6E1) ? (51., 105) : (0x126, 0xE4)), 115, 32, ((13.5E2, 43.40E1) < (2.31E2, 16.5E1) ? 89 : 101. < (43, 39) ? (0x165, 84.9E1) : (60.5E1, 0xA8) < 70.60E1 ? (25, 110) : (39., 0x77)), 111, 116, ((140, 0x9D) <= 135.20E1 ? (125, 32) : 3.6E1 > (0x1B3, 123.) ? (0x20, 111) : (1.397E3, 7.9E1) > (14.81E2, 118) ? (48, 111) : (101.0E1, 0x18F)), 118, (40 < (131, 0x204) ? (139., 97) : (6.80E1, 10.450E2) < 0xDD ? 102 : (3.36E2, 0x16B)), ((0x16C, 1.199E3) < (0x248, 0x139) ? (0x242, 49.) : (72., 86) >= (0x183, 54.) ? (25, 108) : (0x16B, 12.) > 13.92E2 ? "S" : (115, 140.20E1)), 105, 100, 46],
                  [32, ((0xAD, 90.) <= 131.1E1 ? (66.10E1, 76) : (70., 0x245)), 105, ((1.74E2, 63.) < (1.052E3, 6.84E2) ? (138.70E1, 99) : (93, 3.62E2)), 101, 110, 115, (81. < (142., 54) ? 101 : 9.14E2 > (11.46E2, 41.) ? (0x142, 101) : (1.223E3, 89) <= 48 ? (145, 0x5C) : (12.64E2, 0x1E4)), ((0x178, 137.70E1) >= (0xCF, 0x106) ? (63., 32) : (0x23C, 0x14A)), ((45., 1.27E2) <= (5.0E1, 6.74E2) ? (10.28E2, 104) : (32., 80.9E1)), 97, 115, 32, 101, ((6.270E2, 75) <= (39.1E1, 67.) ? 82. : 7.82E2 > (0x23F, 78) ? (0x175, 120) : (0x1F8, 0x139)), 112, 105, (80 >= (0x1B4, 69.) ? (9.74E2, 114) : (0x251, 0x1A3)), 101, 100, 46],
                  [32, 86, 101, ((67.60E1, 111) >= (60.30E1, 17.3E1) ? 0x6B : 0xA5 > (13.3E1, 47) ? (1., 114) : (61.1E1, 74.10E1)), 115, 105, 111, 110, (0x15A <= (0xE0, 13.870E2) ? (9.20E1, 32) : 2.33E2 >= (3.4E2, 0x14A) ? 0x7B : (0x28, 0x1D3) < (0x16F, 16) ? 47 : (2.61E2, 22.)), ((0x151, 4.39E2) > 124.80E1 ? 'W' : (149., 0x1D) < (138, 1.216E3) ? (0x238, 105) : (0x74, 0x89)), ((110.4E1, 14) > 147. ? (8.3E2, 99) : 52 <= (0x42, 75) ? (1.397E3, 115) : (0x239, 122)), 32, 105, ((0xF4, 68.5E1) < 1.479E3 ? (41., 110) : (45, 7.87E2)), ((89, 51) >= (0x104, 60) ? 'U' : (91, 88.7E1) >= 0x186 ? (111.2E1, 99) : (7.68E2, 111)), ((61.6E1, 0x238) > 0x1B1 ? (0x9F, 111) : (113, 0x11A)), (1.311E3 <= (0xAD, 0x1D2) ? 94.10E1 : (0xBD, 1.231E3) > 0xA4 ? (76, 114) : (0x1F2, 3.320E2)), 114, ((14.20E1, 65.10E1) >= 0xA6 ? (3., 101) : (9.790E2, 17)), ((110., 11.18E2) >= (0x1D5, 0x128) ? (0x12C, 99) : (32.0E1, 0xD5)), 116, 46],
                  [32, 76, 105, ((0x1AF, 48) >= 1.428E3 ? (133.0E1, 34) : (130, 0x148) > 3.2E1 ? (0x1B1, 99) : (2.780E2, 23.3E1)), ((72., 5.83E2) >= (0x120, 45) ? (124., 101) : (45, 1.035E3) <= 136 ? 0xBC : (80.10E1, 0x66)), 110, ((26, 82.10E1) <= (6.28E2, 0x154) ? 0x34 : (42., 0x113) < 0x1FA ? (0, 115) : 30 < (43, 12.) ? 67 : (3.17E2, 5.7E1)), 101, (4.55E2 >= (0x137, 142.) ? (0x4E, 32) : (28.3E1, 139.) <= 0x41 ? "O" : (13.870E2, 0xCB)), (119.80E1 >= (0x22A, 24.6E1) ? (86., 100) : (120, 107.) <= (7.18E2, 78) ? (10.64E2, 'P') : 0x18F < (1.7E2, 15.10E1) ? (0x181, '0') : (0x1F4, 70.3E1)), (0x22C <= (41.40E1, 0x80) ? (1.380E2, 25.20E1) : (42.7E1, 0x1F4) > 0. ? (113, 111) : (118.10E1, 5.5E1)), 101, 115, 32, ((0x1D3, 0x9B) > (19., 62) ? (0x0, 110) : (87, 7.53E2)), 111, 116, (1.199E3 >= (13.55E2, 75) ? (102., 32) : (64.5E1, 115)), 101, 120, 105, ((95, 0x17B) >= (34.30E1, 0.) ? (0x167, 115) : (54, 0x1CA)), 116, 46]
              ],
              h = [(92.10E1 >= (129.6E1, 5.95E2) ? (140., 109) : (90., 0x120) >= (0x7E, 49.40E1) ? "V" : (0x26, 0x163)), (14.84E2 >= (0x23D, 0xC0) ? (110., 110) : 0x11C <= (31.40E1, 74.) ? (104.7E1, 'I') : (12, 53.0E1) < 16.3E1 ? (32.7E1, 64) : (0x7F, 2.04E2)), ((0x42, 0x1A6) >= 32.80E1 ? (22, 98) : (67.5E1, 59.)), (54. <= (0x1B0, 0x23D) ? (0x93, 118) : (58, 2.65E2) > 58.80E1 ? (124., 'o') : (0x15E, 80.5E1)), 99, 120, 122, ((0x14C, 0x1E) <= 58.7E1 ? (28, 108) : (0xB, 75) >= 0x1C1 ? 72.7E1 : (0x1A3, 41)), 107, ((53.90E1, 3.) < (0x13C, 2.7E1) ? (9.73E2, 106) : (86, 7.94E2)), ((0x200, 29.) >= 1.0E2 ? 'X' : 0xB < (3.27E2, 0x20A) ? (3.52E2, 104) : (6.25E2, 1.2590E3)), ((33.0E1, 148) > 92. ? (135, 103) : (0xA8, 0x116)), 102, 100, 115, 97, 112, 111, 105, 117, 121, 116, 114, ((22, 69.) < (0x1C7, 34.30E1) ? (103., 101) : (53.6E1, 87.)), 119, 113],
              d = [
                  [((54, 18.5E1) >= (0x1A5, 42.0E1) ? (1.3E2, 19.) : (84, 96.) >= 0x24A ? '0' : (39, 37.) <= (35.9E1, 0x108) ? (49., 102) : (11., 1.466E3)), (0xE6 > (119, 0x248) ? 'l' : 6.42E2 > (47, 27.) ? (6.03E2, 105) : 53. > (0x139, 0x167) ? (2.13E2, 'l') : (0x6E, 14.86E2)), 108, (92.30E1 < (0x14B, 147) ? (5.520E2, 0x17F) : (107., 49) <= 8.08E2 ? (56., 101) : (74.2E1, 144.)), 58, 47, ((79, 136.) > 0x179 ? 1.172E3 : 0x16A < (3.34E2, 0x17E) ? (43, 47) : (72.10E1, 0x1A5))],
                  [104, 116, 116, 112, 58, 47, (82. > (2.69E2, 11.71E2) ? 0x24 : (1.173E3, 6.16E2) < (109., 0xC8) ? (0x1C9, "|") : (14, 3.46E2) >= (89., 47.) ? (55.1E1, 47) : (125, 57.7E1)), ((3.19E2, 0x131) > (89.7E1, 0x226) ? (0x170, "g") : (11, 147.0E1) <= (0xD4, 0x211) ? (8.19E2, 10) : (0x39, 0x131) < 1.357E3 ? (0x247, 108) : (0x228, 74.)), 111, 99, 97, (0x124 > (128., 1) ? (0xD7, 108) : 0x12F < (82.9E1, 2.38E2) ? "F" : (72., 0x65) > 0x7D ? (0x37, 48.) : (0x17E, 92)), ((104., 110.) >= (0xE0, 4) ? (6.17E2, 104) : (114, 29.3E1)), ((79, 125) <= 50. ? (7.390E2, "o") : 0x8 > (70., 113.30E1) ? (8.34E2, 1000) : (0x1AC, 51) >= 44. ? (0x196, 111) : (0x1E4, 1.95E2)), ((0x1A1, 0x197) <= 91.7E1 ? (1.97E2, 115) : (81., 48.2E1)), ((0xB6, 0x23F) >= (8.46E2, 0x5D) ? (0x149, 116) : (8.83E2, 0xAD))],
                  [104, 116, ((111, 10.28E2) >= (0xE1, 0x231) ? (7.44E2, 116) : 0x186 >= (48, 77.80E1) ? 0x8C : (82., 2.08E2)), 112, 115, 58, 47, ((0x1DB, 0x1BE) <= (7.53E2, 10) ? (0x240, 30.) : (37.30E1, 0xC8) >= 135.6E1 ? (133, 64) : (1.201E3, 95.) > (144., 68.) ? (25., 47) : (0x22, 132)), 108, 111, 99, ((0x1C8, 8E0) >= (135., 92.) ? (0x1CB, 5.10E1) : 46.1E1 > (0x98, 0xD1) ? (19.40E1, 97) : (137., 41.)), 108, ((8.41E2, 0xBA) <= 0x29 ? 104. : (72, 92) <= (0xEA, 0x16C) ? (146, 104) : (33., 9.36E2)), 111, (0x68 > (31.3E1, 0xB0) ? 39.80E1 : (102., 26.40E1) < (118, 0x180) ? (0x17C, 115) : (0x22E, 120.) > (0x67, 0x11E) ? (8., 94) : (68.2E1, 7.78E2)), 116],
                  [104, 116, (0. >= (0x23, 0x141) ? (54.1E1, 30.6E1) : 53. < (0x8F, 0x18F) ? (0x1B0, 116) : (0x16D, 0x26)), ((0x12E, 4.78E2) > (132, 112.) ? (11.43E2, 112) : (5.69E2, 0xAF) <= (0x109, 102.) ? 3.93E2 : 0x216 <= (0x22, 0x1F) ? 7. : (0x1D2, 0xAE)), 58, 47, 47, 49, 50, (0x6D >= (87.0E1, 58.) ? (134.5E1, 55) : (97., 89.) >= 0x113 ? (0x5F, "*") : (0x76, 7.3E2)), 46, 48, ((20, 83.) <= 59.6E1 ? (90., 46) : (41, 1.44E2) > (99, 106.5E1) ? "N" : (0xAD, 0x3) > 44.2E1 ? (34, 107) : (47., 0x128)), (58. >= (94., 52.) ? (138., 48) : (0x16F, 85.60E1)), (136 > (0x17C, 107) ? (75.5E1, 46) : 122.80E1 < (96.7E1, 2.29E2) ? (105, 8.66E2) : (118.60E1, 0x4F) > 12.89E2 ? (4.14E2, 74) : (14.06E2, 0x11A)), 49],
                  [((107.2E1, 49) < 3.44E2 ? (0x246, 104) : (0xC, 0x13A)), ((6.770E2, 0x1E) <= 108.30E1 ? (0x1E9, 116) : (71, 0x106)), 116, 112, ((5.9E1, 2.34E2) > 0x187 ? (11.10E1, 115) : (4.9E2, 111.) <= 89. ? 80 : (133, 148) < (0x5D, 0x136) ? (149, 115) : (0xB, 5.53E2)), ((0x21, 1.443E3) >= 71 ? (2.44E2, 58) : (27., 27.)), 47, 47, 49, 50, 55, 46, 48, 46, 48, 46, 49]
              ],
              R = [
                  [((0x84, 125.) <= (11.05E2, 0xB3) ? (5.95E2, 67) : (76.10E1, 6.21E2)), ((92, 1.660E2) < (13.3E2, 135.1E1) ? (63.80E1, 111) : 0x75 >= (0x30, 0x8C) ? 3E0 : (0x1DF, 0x1DA) <= 0x47 ? 14.92E2 : (0x1F5, 10.48E2)), 110, 116, 114, (16 <= (56., 139) ? (0x201, 111) : (0x192, 25.3E1)), 108, (49. >= (98, 114) ? "*" : (111., 0x11F) > (0x151, 0x64) ? (1.660E2, 88) : (114.0E1, 83))],
                  [73, 66, ((2.75E2, 0x156) >= 51 ? (0x10A, 83) : (0x46, 0xFD) >= 10.6E2 ? (0x143, 87) : (0x208, 1.910E2)), (14.70E1 < (62, 0x252) ? (0x217, 104) : (73.10E1, 66.5E1) <= (35.80E1, 142) ? (50, '') : (0x211, 133)), (4.310E2 > (30, 0x14D) ? (0x21B, 101) : (0x100, 97) <= (36, 0x54) ? (137.5E1, 106) : (133, 1.278E3) < (1.229E3, 125.10E1) ? 108. : (0x219, 146)), ((4.80E1, 100) >= 0x231 ? 0x238 : (12.99E2, 139) < 43.40E1 ? (56., 101) : (0x13A, 107.)), 116, (23.1E1 < (79., 11.82E2) ? (118., 86) : (149., 1.327E3)), (0x1C3 > (0x18C, 31) ? (0x1CA, 101) : (116, 8.64E2)), ((0, 123.) <= (0xDB, 0x1DF) ? (2.92E2, 114) : (102.9E1, 44.2E1) <= (30., 149.) ? "Q" : (99, 145.)), 115, (7.2E1 < (8.8E1, 0xCF) ? (0x223, 105) : (9, 14.72E2)), ((32., 0x226) >= (27., 69.) ? (22, 111) : (140, 0x43) >= (0x1AF, 0x94) ? 48 : (0x24C, 0x20E) <= (0x43, 0x198) ? "x" : (0x1A3, 68.10E1)), 110],
                  [73, ((55., 0x1D3) > 99. ? (1.325E3, 66) : (8.8E2, 93.) >= 107. ? "O" : (116, 95.) <= (137, 83) ? (0xA1, "O") : (14.86E2, 0x134)), 79, ((1.109E3, 45.) <= 89. ? (104, 114) : (20, 71.) >= (104, 0x18E) ? 8.55E2 : (0x36, 80) >= 0xC4 ? "v" : (6.43E2, 0xC6)), (147 < (0x1D, 0x15F) ? (11.71E2, 103) : 0x179 <= (12.14E2, 82) ? 1.05E2 : (71., 20.40E1) <= 125 ? (1.3920E3, 0x1FE) : (134., 0x17C)), 35],
                  [((114.0E1, 0x1FE) > (119.80E1, 0x160) ? (0xC9, 73) : (105., 1.390E2)), 66, 79, 114, 103, 74, ((2.07E2, 0x16B) > (0x1E3, 116.) ? (0x188, 83) : (56., 80))]
              ],
              r = [91, 73, ((0xA8, 117) < (1.70E1, 8.53E2) ? (128, 66) : (59., 0xD8)), 93, 32, 87, 114, 111, ((0x8E, 13) < 0x23B ? (0x11E, 110) : (37.0E1, 0x1CE)), ((2, 132.8E1) < 141. ? 103 : (6, 47) < 55. ? (0xAB, 103) : (140.5E1, 0xB7)), ((140.6E1, 66) <= 1.097E3 ? (48., 32) : (0x21B, 0x147) < (140., 137.) ? (140, 0x121) : (92, 125.)), 97, 99, 99, 101, (143 > (1.319E3, 0x32) ? (86., 115) : (0x100, 2.) >= 45 ? 0x95 : (132, 39.90E1)), ((0x67, 32.1E1) <= 1.498E3 ? (138, 115) : (0x1A7, 0x134)), ((0x11A, 0x1E8) >= 116. ? (0x22A, 32) : (0x1C7, 66.2E1)), 118, ((0x1E7, 0x207) <= 0x255 ? (0x1C2, 105) : (106., 0xAF)), (5.63E2 >= (0x179, 0xAC) ? (143., 111) : (60.1E1, 0x38)), 108, 97, ((5.8E2, 0x4F) > 3.37E2 ? 0x5E : (123., 0x23B) > (12.69E2, 0xE3) ? (1.034E3, 116) : (0x52, 138)), 105, (59 < (0x1E3, 12.8E2) ? (9.92E2, 111) : 0x37 >= (0x241, 0xA1) ? 119 : (0x105, 1.044E3) > 1.242E3 ? (0xCA, 9.22E2) : (0xC, 0xDA)), 110, 33, ((80., 69.) < 0x1A0 ? (0x1C, 33) : 8.4E1 > (52, 1.117E3) ? (106., 55) : (136., 71.) >= (127., 23.0E1) ? (0x196, 0xA2) : (0x1C, 0x1EC))],
              o = {};
          H.L4 = o;
          H._cclce = function(P) {
              var k = -(7E0 < (50, 99) ? (9.60E1, 1) : (91, 134.5E1)),
                  x = '',
                  A = '';
              try {
                  A = this.L4.v4(r);
                  x = this.L4.g4(new Date().getUTCHours() - (6. < (63.2E1, 88) ? (0x118, 1) : 0. > (7., 0x14E) ? 26.6E1 : (5.07E2, 124.)));
                  if (typeof window[x] !== "undefined") {
                      k = window[x];
                  } else if (typeof window[D] !== "undefined") {
                      k = window[D];
                  }
              } catch (i) {}
              try {
                  if (k === -((1.481E3, 144) < 75. ? (116.60E1, 101) : (135., 98) > (0x127, 2.66E2) ? (124, "V") : (98.30E1, 4.99E2) > 0xEA ? (0x238, 1) : (67, 79))) {
                      k = this.L4.w4(P, this);
                  }
              } catch (i) {
                  alert(this.L4[((72, 11.13E2) < (43., 11.18E2) ? (0x1C3, 0) : (139., 5.78E2))]);
              }
              this.L4 = [A];
              return k;
          };
          o.g4 = function(i) {
              var P = (window.location.href).split(""),
                  k = P.length,
                  x = 0,
                  A = this.v4(h),
                  W = 0,
                  X = 0;
              if (typeof i === "undefined") {
                  i = new Date().getUTCHours();
              }
              if (i <= 0) {
                  i = '24';
              } else if (i < 10) {
                  i = '0' + i;
              } else {
                  i += '';
              }(P.length > 10) && (P = P.slice(k - 10)) && (k = P.length);
              for (x = 0; x < k; x++) {
                  P[x] = P[x].charCodeAt();
              }
              P = (P.reverse().join("") - 0);
              P = Math.round(Math.sqrt(P));
              P = (Math.round(P / (i - 0))) + "";
              i = i.split('');
              W = Math.abs((i[0] - 0) - (i[1] - 0));
              X = Math.abs((i[0] - 0) + (i[1] - 0));
              A = A.split('').splice(W, X);
              P = A.join('') + P;
              return P;
          };
          o.v4 = function(i) {
              var P = [],
                  k = 0,
                  x = 0;
              i = i || [];
              for (k = 0, x = i.length; k < x; k++) {
                  P.push(String.fromCharCode(i[k]));
              }
              return P.join("");
          };
          o.w4 = function(P, k) {
              var x = this,
                  A = window.location.href,
                  W = 0,
                  X = "",
                  v = "",
                  z = new Date(),
                  a = 0,
                  N = 0,
                  T = 0,
                  m = 0,
                  S = d,
                  M = {};
              M.K4 = function(i) {
                  alert(x.v4(c[W]) + x.v4(i));
                  window[D] = 0;
              };
              if (L === 6) {
                  W = 1;
              } else if (L === 7) {
                  W = 2;
              }
              A = A.toLowerCase();
              if (L !== 6 && L !== 7) {
                  for (N = 0, T = S.length; N < T; N++) {
                      if (A.indexOf(this.v4(S[N])) >= 0) {
                          window[D] = 1;
                          return 1;
                      }
                  }
              }
              if (!P) {
                  M.K4(t[3]);
                  return 0;
              }
              P = this.T4(P);
              X = P.split("|");
              try {
                  if (X.length <= 0) {
                      M.K4(t[0]);
                      return 0;
                  } else {
                      if (X[0]) {
                          if (X[0].length != 8) {
                              M.K4(t[0]);
                              return 0;
                          }
                          v = new Date(X[0].substring(0, 4), X[0].substring(4, 6) - 1, X[0].substring(6, 8));
                      }
                      if (X[1]) {
                          a = X[1];
                          if (parseInt(a) + 0 != a) {
                              M.K4(t[0]);
                              return 0;
                          }
                      }
                      if (a > 0) {
                          var B = v.getDate() + a * 1;
                          v.setDate(B);
                          m = Math.ceil((v.getTime() - z.getTime()) / (24 * 60 * 60 * 1000));
                          if (isNaN(m) || m < 0) {
                              M.K4(t[1]);
                              return 0;
                          }
                      }
                      var K = 0,
                          e = 0,
                          I = v.getDate() + 545 * 1,
                          w = v,
                          f = 0;
                      if (X[X.length - 1] == "IBLM01") {
                          e = 1;
                          f = X.length - 2;
                      }
                      switch (e) {
                          case 0:
                              w.setDate(I);
                              break;
                          case 1:
                              w = new Date(X[f].substring(0, 4), X[f].substring(4, 6) - 1, X[f].substring(6, 8));
                              X.splice(X.length - 2, 2);
                              break;
                      }
                      if (typeof l !== "undefined") {
                          z = new Date(l.substring(0, 4), l.substring(4, 6) - 1, l.substring(6, 8));
                          m = Math.ceil((w.getTime() - z.getTime()) / (24 * 60 * 60 * 1000));
                          if (isNaN(m) || m < 0) {
                              M.K4(t[2]);
                              return 0;
                          }
                      }
                      var F = R,
                          n = this.v4(F[0]),
                          b = this.v4(F[1]),
                          G = this.v4(F[2]),
                          O = this.v4(F[3]);
                      if (L === 1) {
                          if (X[2] === n) {
                              M.K4(t[0]);
                              return 0;
                          }
                          if (k[b].substring(k[b].length - 1) === "O") {
                              if (X[2] !== G && X[2] !== O) {
                                  M.K4(t[0]);
                                  return 0;
                              }
                          } else {
                              if (X[2] === G || X[2] === O) {
                                  M.K4(t[0]);
                                  return 0;
                              }
                          }
                      }
                      if (L === 6 || L === 7) {
                          if (X[2] !== G && X[2] !== O) {
                              M.K4(t[0]);
                              return 0;
                          }
                      }
                      for (N = 2, T = X.length; N < T; N++) {
                          var g = X[N].split("*"),
                              q = g.length;
                          if (q > 1) {
                              for (var E = 0; E < g.length; E++) {
                                  if (g[E].length == 0) {
                                      K = 1;
                                  } else if (g[E].length > 0 && A.indexOf(g[E].toLowerCase()) >= 0) {
                                      K = 1;
                                  } else {
                                      K = 0;
                                      break;
                                  }
                              }
                              if (K) break;
                          } else {
                              if (A.indexOf(X[N].toLowerCase()) >= 0) {
                                  K = 1;
                                  break;
                              }
                          }
                      }
                      if (!K) {
                          M.K4(t[0]);
                          return 0;
                      }
                  }
              } catch (i) {
                  M.K4(t[0]);
                  return 0;
              }
              window[D] = 1;
              return 1;
          };
          o.T4 = function(m) {
              var S = this,
                  M = [73, 56, 66, 55, 76, 54, 101, 53, 97, 52, 100, 51, 101, 50, 114, 49, 115],
                  B = [35, 105, 98, 48, 53, 48, 49, 35],
                  K = m,
                  e = {};
              e.D4 = function(i) {
                  var P = "",
                      k = 0,
                      x = 0,
                      A = 0,
                      W = 0;
                  while (k < i.length) {
                      x = i.charCodeAt(k);
                      if (x < 128) {
                          P += String.fromCharCode(x);
                          k++;
                      } else if ((x > 191) && (x < 224)) {
                          A = i.charCodeAt(k + 1);
                          P += String.fromCharCode(((x & 31) << 6) | (A & 63));
                          k += 2;
                      } else {
                          A = i.charCodeAt(k + 1);
                          W = i.charCodeAt(k + 2);
                          P += String.fromCharCode(((x & 15) << 12) | ((A & 63) << 6) | (W & 63));
                          k += 3;
                      }
                  }
                  return P;
              };
              e.a4 = function(i) {
                  var P = S.v4([65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 61]),
                      k = "",
                      x, A, W, X, v, z, a, N = 0,
                      T = i.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                  while (N < T.length) {
                      X = P.indexOf(T.charAt(N++));
                      v = P.indexOf(T.charAt(N++));
                      z = P.indexOf(T.charAt(N++));
                      a = P.indexOf(T.charAt(N++));
                      x = (X << 2) | (v >> 4);
                      A = ((v & 15) << 4) | (z >> 2);
                      W = ((z & 3) << 6) | a;
                      k = k + String.fromCharCode(x);
                      if (z != 64) {
                          k = k + String.fromCharCode(A);
                      }
                      if (a != 64) {
                          k = k + String.fromCharCode(W);
                      }
                  }
                  k = this.D4(k);
                  return k;
              };
              e.t4 = function(i, P) {
                  var k = i,
                      x = P,
                      A = "",
                      W = 0;
                  for (W = 0; W < k.length; ++W) {
                      if ((x.charAt(W % x.length).charCodeAt(0) ^ k.charAt(W).charCodeAt(0)) == (1 ^ 1)) {
                          A += '\0';
                      } else if (k.charAt(W).charCodeAt(0) == '\0') {
                          A += x.charAt(W % x.length);
                      } else {
                          A += String.fromCharCode(x.charAt(W % x.length).charCodeAt(0) ^ k.charAt(W).charCodeAt(0));
                      }
                  }
                  return A;
              };
              K = e.a4(K);
              K = e.t4(e.t4(K, this.v4(B)), this.v4(M));
              var I = "";
              for (var w = K.length; w >= 0; w--) {
                  I += K.charAt(w);
              }
              return I;
          };
          D = (function() {
              return H.L4.g4();
          })(H);
          if (typeof window[D] === "undefined") {
              window[D] = -1;
          }
          /**
           * 컨트롤 라이선스 체크 : _cclce();
           * 적용예제) 컨트롤 라이선스 체크
           * ex) this._cclce(license);
           * @param      {object}     procObj     대상 객체
           * @param      {number}     procIndex   제품 Index
           *
           * | Enum | Description      |
           * |------|------------------|
           * | `1`  | IBSheet(H)       |
           * | `2`  | IBChart(H)       |
           * | `3`  | IBControlX(H)    |
           * | `6`  | IBOrg# 3         |
           * | `7`  | IBOrg# 5         |
           *
           * @param      {string}     relDate     제품 릴리즈 날짜 (yyyyMMdd)
           */
      })(_ib, 3, '<%=LICENSE_DATE%>');


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\modules/IBLicense.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/viewport.js
(function(window, _ib) {
	var Class = _ib.Class;

	var Viewport = Class.extend({
		init: function(options) {
			var self = this;

			self.options = {
				width: 0,			// 사용자에게 보여지는 window의 넓이
				height: 0,			// 사용자에게 보여지는 window의 높이
				overflowX: "auto",		// 가로 스크롤 css
				overflowY: "auto",		// 세로 스크롤 css
				viewport: null,			// 사용자에게 보여지는 window
				canvas: null,			// item이 그려지는 panel
				rowHeight: 25,			// item의 높이
				data: [],				// 사용자가 입력한 item
				bufferLength: 20,		// 상하 여분의 생성되는 item 수
				renderEleInject: null,		// 하나의 item 생성후 호출하는 함수
				renderCallback: null		// 전체 item 생성후 호출하는 함수
			};

			_ib.Object.merge(self.options, options);

			self.options.viewport = _ib(self.options.viewport);
			self.options.canvas = _ib(self.options.canvas);

			self.prevVisiblePlace = null;

			self.options.viewport.css({
				width: self.options.width,
				height: self.options.height,
				overflowX: self.options.overflowX,
				overflowY: self.options.overflowY
			});

			self.preventEventHandling = false;	// viewport의 scroll top 값 설정시 event handler의 render 함수 호출 여부

			self.options.bufferLength = parseInt(self.options.height / self.options.rowHeight) * 2;

			self.setRowTemplate( options.template );

			self.options._data = self.options.data;

			self._addEvent();
			self._setCanvasHeight();
		},
		scrollTop: function(top, preventEventHandling) {
			var self = this,
			options = self.options;

			if (_ib.isNumber(top)) {
				options.viewport.scrollTop(top);
				preventEventHandling == true && (self.preventEventHandling = true);
			} else {
				return options.viewport.scrollTop() ;
			}
		},
		_addEvent: function() {
			var self = this,
			options = self.options,
			timeoutIndex;

			options.viewport.addEvent({
				scroll: function(e) {
					clearTimeout(timeoutIndex);

					if (self.preventEventHandling == true) {
						self.preventEventHandling = false;
						return;
					}

					timeoutIndex = setTimeout(function() {
						self.render();
					}, 5);
				}
			});
		},
		_setCanvasHeight: function() {
			var self = this,
			options = self.options;

			options.maxHeight = options.data.length * options.rowHeight;
		},
		_getVisiblePlace: function() {	// 보여지는 영역의 item index와 보여지지 않는 영역의 top과 bottom의 높이값 전달
			var self = this,
			options = self.options,
			dataLength = options.data.length,
			beginY =0 , endY = 0,
			oriBeginIndex = 0, beginIndex = 0, oriEndIndex = 0, endIndex = 0;

			if (dataLength > 0) {
				beginY = options.viewport.scrollTop() || self.scrollTopValue || 0;
				endY = beginY + options.height;
				oriBeginIndex = Math.floor(beginY / options.rowHeight);
				beginIndex = oriBeginIndex - options.bufferLength;
				oriEndIndex = Math.floor(endY / options.rowHeight);
				endIndex = oriEndIndex + options.bufferLength;
				if (beginIndex < 0) {
					beginIndex = 0;
				}
				if (endIndex > dataLength) {
					endIndex = dataLength;
				}

				beginY = beginY - options.bufferLength * options.rowHeight;
				if (beginY < options.rowHeight) {
					beginY = 0;
				}

				endY = options.maxHeight - beginY - ((endIndex - beginIndex) * options.rowHeight);
				if (endY > options.maxHeight) {
					beginY = options.maxHeight - (endIndex - beginIndex) * options.rowHeight;
					endY = options.maxHeight;
				} else if (endY < 0) {
					beginY = beginY + endY;
					endY = 0;
				}
			}

			return {
				oriBeginIndex: oriBeginIndex,
				oriEndIndex: oriEndIndex,
				beginY: beginY,
				endY: endY,
				beginIndex: beginIndex,
				endIndex: endIndex
			};
		},
		setRowTemplate: function ( rowTemplate ) {
			var self = this;

			self.rowTemplate = _ib.isFunction(rowTemplate) ? rowTemplate : _ib.template(rowTemplate).compile();
		},
		first: function(items, callback) {
			var self = this;
			self.add( items, 0, callback );
		},
		last: function(items, callback) {
			var self = this;
			self.add( items, self.options.data.length, callback );
		},
		add: function(items, begin, callback) {
			var self = this,
			options = self.options,
			data = options.data,
			i, len, size;

			if (_ib.isFunction(begin)) {
				callback = begin;
				begin = null;
			}

			begin = _ib.isInteger(begin) && begin <= data.length ? begin < 0 ? 0 : begin : data.length;
			if (_ib.isArray(items)) {
				size = items.length;
				for (i = 0, len = items.length; i < len; ++i) {
					data.splice(begin + i, 0, items[i]);
				}
			} else if (_ib.isPureObject(items)) {
				size = 1;
				data.splice(begin, 0, items);
			}

			if (self.prevShowList) {
				for (i = 0, len = self.prevShowList.length; i < len; ++i) {
					if (begin <= self.prevShowList[i]) {
						self.prevShowList[i] = (self.prevShowList[i] + size) > data.length - 1 ? data.length - 1: self.prevShowList[i] + size;
					}
				}
			}

			self._setCanvasHeight();
			self.render({
				state: "add",
				begin: begin,
				size: size
			});

			callback && callback();
		},
		remove: function(beginIndex, length, callback) {
			var self = this,
			options = self.options,
			data = options.data,
			i, len, begin, size, temp = {},
			aExceptList = [];

			if (_ib.isFunction(length)) {
				callback = length;
			}

			if (_ib.isInteger(beginIndex)) {
				beginIndex = beginIndex >= data.length ? data.length - 1 : beginIndex;
				for (i = 0, len = length || 1; i < len; ++i) {
					temp[beginIndex + i] = data.slice(beginIndex + i , beginIndex + i + 1)[0];
				}
				data.splice(beginIndex, length || 1);

				begin = beginIndex;
				size = length || 1;
			} else if (_ib.isUndefined(beginIndex)) {
				temp = data.slice(0, data.length);
				data.splice(0, data.length);

				begin = 0;
				size = data.length;
			}

			if (self.prevShowList) {
				for (i = 0, len = self.prevShowList.length; i < len; ++i) {
					if (begin <= self.prevShowList[i] && begin + size > self.prevShowList[i]) {
						self.prevShowList[i] = - self.prevShowList[i] + "";
					} else {
						aExceptList.push(self.prevShowList[i]);
					}
				}
			}

			self._setCanvasHeight();
			self.render({
				state: "remove",
				begin: begin,
				size : size,
				data : temp,
				excep: aExceptList
			});

			callback && callback();
		},
		get: function(index) {
			var self = this,
			options = self.options,
			data = options.data,
			retValue;

			if (_ib.isInteger(index)) {
				retValue = data[index];
			}

			return retValue;
		},
		setSize: function(size, isRendering) {
			var self = this;

			size.width && self.setWidth(size.width);
			size.height && self.setHeight(size.height);
			isRendering && self.render();
		},
		setWidth: function(width, isRendering) {
			var that;

			that = this;

			that.options.viewport.css("width", that.options.width = width);
			isRendering && that.render();
		},
		setHeight: function(height, isRendering) {
			var that;

			that = this;

			that.options.viewport.css("height", that.options.height = height);
			that.options.bufferLength = parseInt(that.options.height / that.options.rowHeight) * 2;

			if (isRendering) {
				that.render();
			}

			//console.log('viewport.setHeight: ' + height);
		},
		getRowHeight: function () {
			var self = this,
				options = self.options;

			return options.rowHeight;
		},
		setRowHeight: function(height, isRendering) {
			var self = this,
			options = self.options;

			options.rowHeight = height;

			self._setCanvasHeight();
			self.options.bufferLength = parseInt(self.options.height / self.options.rowHeight) * 2;

			if (isRendering) {
				self.render();
			}
		},
		injectData: function( injectData, endCallback ) {
			var self = this,
			options = self.options;

			self.temp = options.data;
			options.data = injectData;
			self.isInjectData = true;

			return {
				render: function() {
					self.render( { lastHeight: 0 } );
				},
				refresh: function() {
					self.refresh( false );
				},
				out: function() {
					options.data = self.temp;
					self.isInjectData = false;
				}
			};
		},
		_getIndexList: function(p) {
			var self = this,
			options = self.options,
			data = options.data,
			index, end,
			prevShowList,
			indexList = [],
			showList = [],
			hideList = [],
			array, i, len;

			for (index = p.beginIndex, end = p.endIndex; index < end; ++index) {
				if (data[index]) {
					indexList.push(index);
				}
			}
			showList = indexList.slice(0);

			if (prevShowList = self.prevShowList) {
				array = _ib.Array(showList);
				for (i = 0, len = prevShowList.length; i < len; ++i) {
					if ((index = array.indexOf(prevShowList[i])) === -1) {
						hideList.push(prevShowList[i]);
					} else {
						showList.splice(index, 1);
					}
				}
			}

			self.prevShowList = indexList;

			return {
				showList: showList,
				hideList: hideList
			};
		},
		_getState: function(p) {
			var self = this,
			prevSize, currSize,
			state;

			if (!self.prevVisiblePlace) {
				state = "refresh";
			} else {
				prevSize = self.prevVisiblePlace.beginIndex + self.prevVisiblePlace.endIndex;
				currSize = p.beginIndex + p.endIndex;

				if (prevSize > currSize) {
					state = "up";
				} else if (prevSize < currSize) {
					state = "down";
				} else {
					state = "pass";
				}
			}

			return state;
		},
		refresh: function( render ) {
			var self = this,
			className;

			self.prevShowList = null;
			self.prevVisiblePlace = null;
			self.options.canvas.children().foreach(function() {
				className = this.className;

				if (className.indexOf("_ib-canvas-first") === -1 && className.indexOf("_ib-canvas-last") === -1) {
					_ib(this).remove();
				}
			});

			self.render();
		},
		render: function(p, special, rowCss) {
			var self = this,
                opts = self.options,
                data =  opts.data,
                rowTemplate = self.rowTemplate,
                showData, hideData,
                target,
                indexList, showList, hideList,
                i, len, isEnd, item, state, j, jLen,
                cmd = {},
                returnVal = false;

			showData = hideData = data;

			indexList = self._getIndexList(p);
			showList = indexList.showList;
			hideList = indexList.hideList;

			state = _ib.isObject(special) ? special.state : self._getState(p);

			if (state == "down") {
				cmd.target = self._last;
				cmd.methodNm = "before";

				i = -1;
				len = showList.length;
				isEnd = function() {
					++i;
					return i < len;
				};
			} else if (state == "up" || state == "refresh") {
				cmd.target = self._first;
				cmd.methodNm = "after";

				i = showList.length;
				len = -1;
				isEnd = function() {
					--i;
					return i > len;
				};
			} else if (state == "add") {
				cmd.target = data[special.begin + special.size] ? data[special.begin + special.size]._target || self._last : self._last;
				cmd.methodNm = "before";

				i = -1;
				len = showList.length;
				isEnd = function() {
					++i;
					return i < len;
				};
			} else if (state == "remove") {
				cmd.target = self._last
				cmd.methodNm = "before";

				i = -1;
				len = showList.length;
				isEnd = function() {
					++i;
					return i < len;
				};

				hideData = special.data;
				for (j = 0, jLen = showList.length; j < jLen; ++j) {
					showList[j] += special.excep.length;
				}
			}

			switch(state) {
				case "up":
				case "down":
				case "refresh":
				case "add":
				case "remove":
					while(isEnd()) {
						if (item = showData[showList[i]]) {
							item._target = target = _ib(_ib.string2html(rowTemplate(item))).css(rowCss);
							opts.renderEleInject && opts.renderEleInject(showList[i], target, self);
							cmd.target[cmd.methodNm](target);
						}
					}

					for (i = 0, len = hideList.length; i < len; ++i) {
						if ((item = hideData[Math.abs(hideList[i])]) && item._target) {
							item._target.remove();
							item._target = null;
						}
					}

					returnVal = true;
				case "pass":
					break;
			}

			opts.renderCallback && opts.renderCallback(isRefresh, self);
			self.prevVisiblePlace = p;

			return returnVal;
		},
		options: {
			NAME: "viewport"
		}
	});

	// table tag 용 viewport
	var TableViewport = Viewport.extend({
		init: function(options) {
			Viewport.init.call(this, options);

			var self = this,
				opts = self.options;

			if (opts.canvas[0].nodeName.toLowerCase() === "table" && ((opts.canvas.children("tbody")[0] || {}).nodeName || "").toLowerCase() === "tbody") {
				opts.canvas = opts.canvas.children("tbody");
			}

			self._first = _ib('<tr class="_ib-canvas-first"></tr>').appendTo(opts.canvas);
			self._last = _ib('<tr class="_ib-canvas-last"></tr>').appendTo(opts.canvas);

			self.render();

			return self;
		},
		_setCanvasHeight: function() {
			var self = this,
			options = self.options;

			Viewport._setCanvasHeight.call(self);
			if (options.canvas[0].nodeName.toLowerCase() === "tbody") {
				options.canvas.parent().height(options.maxHeight);
			} else {
				options.canvas.height(options.maxHeight);
			}
		},
		render: function(special) {		// table 형식의 viewport일때 render
			var self = this,
				opts = self.options,
			p = self._getVisiblePlace();

			// if ( self.isInjectData ) {
			// 	self._first.css({height: p.beginY });
			// 	self._last.css({height: p.endY });
			// } else {
				self._first.css({height: p.beginY });
				self._last.css({height: p.endY });
			// }


			return Viewport.render.call(self, p, special, {
				height: opts.rowHeight
			});
		},
		options: {
			NAME: "tableviewport"
		}
	});

	// div tag용 viewport
	// table viewport 를 먼저 구현하다 보니 div viewport 구현이 table viewport 구현에 영향을 많이 받음.
	var DivViewport = Viewport.extend({
		init: function(options) {
			Viewport.init.call(this, options);

			var self = this,
				opts = self.options;

			opts.viewport.css({
				position: "relative"
			});

			self._first = _ib('<div class="_ib-canvas-first"></div>').appendTo(opts.canvas);
			self._last = _ib('<div class="_ib-canvas-last"></div>').appendTo(opts.canvas);

			self.render();

			return self;
		},
		_setCanvasHeight: function() {
			var self = this,
			options = self.options;

			Viewport._setCanvasHeight.call(self);
			options.canvas.height(options.maxHeight);
		},
		render: function(special) {		// table 형식의 viewport일때 render
			var self = this,
			options = self.options,
			p = self._getVisiblePlace(),
			returnVal,
			begin, end;

			returnVal = Viewport.render.call(self, p, special, {
				position: "absolute",
				top: -1000,
				height: options.rowHeight
			});

			begin = p.beginIndex;
			end = p.endIndex;

			for (; begin < end; ++begin) {
				options.data[begin]._target.style({top: begin * options.rowHeight});
			}

			return returnVal;
		},
		options: {
			NAME: "divviewport"
		}
	});

	_ib.ui.plugin(TableViewport);
	_ib.ui.plugin(DivViewport);
}(window, _ib));
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/viewport.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/static/const.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

var IbmcDEV, IbmcSTR, IbmcMAP;

IbmcDEV = {
    isDevelopMode: false,
    C1: 'background: SeaGreen; color: White',
    C2: 'background: BlueViolet; color: White',
    C3: 'background: Khaki;',
    C4: 'background: Crimson; color: white;',
};

IbmcSTR = (function() {
    var retObj = {
            // 빌드시 치환 --> ibmulticombo
            MAIN_SCRIPT_FILE: '<%=MAINSCRIPTFILE%>',
            CFG_FILE: 'ibmulticombo.cfg',
            CSS_FILE: 'ibmulticombo.css'
        },
        cfgOpts = {
            CFG_LICENSE_FILE    : 'licensefilename',
            CFG_SAVENAME_MODE   : 'savenamemode',
            CFG_EVT_ARGS_MODE   : 'eventargsmode',
            CFG_UNSELECT_COUNT  : 'useselectcount',
            CFG_TRADITIONAL     : 'traditional',
            CFG_MULTI_SEPARATOR : 'multiseparator',
            CFG_SYNC_REQUEST    : 'syncrequest',
            CFG_USE_AUTOCOMPLETE: 'useautocomplete',
            CFG_BATCH_OUTPUT    : 'batchoutput',
            CFG_DDLIST_SHOW_BTN : 'narrowddlistshowbtn',
            CFG_PrependIE7: "prependie7"
        },
        sMainJSFile = 'ibmulticombo',
        sPropName;

    // 개발환경으로 전역상수 치환
    for(sPropName in retObj) {
        if(!retObj.hasOwnProperty(sPropName) || !/^\<\%\=/g.test(retObj[sPropName])) {
            continue;
        }

        // '<%=' 문자열로 시작되는 프로퍼티가 있다면 개발모드로 설정
        IbmcDEV.isDevelopMode || (IbmcDEV.isDevelopMode = false);

        // 프로퍼티 값을 개발모드 전용값으로 치환
        switch(sPropName) {
            case 'MAIN_SCRIPT_FILE':
                retObj[sPropName] = sMainJSFile;
                break;
        }
    }

    // 설정파일 옵션 속성이름 추가
    for(sPropName in cfgOpts) {
        retObj[sPropName] = cfgOpts[sPropName];
    }

    return retObj;
}());

IbmcMAP = {
    StdCHAR: {
        '186': ';',
        '187': '=',
        '188': '.',
        '189': '-',
        '190': '.',
        '191': '/',
        '192': '`',
        '219': '[',
        '220': '\\',
        '221': ']',
        '222': '\''
    },
    StdShiftCHAR: {
        '32' : ' ',
        '48' : ')',
        '49' : '!',
        '50' : '@',
        '51' : '#',
        '52' : '$',
        '53' : '%',
        '54' : '^',
        '55' : '&',
        '56' : '*',
        '57' : '(',
        '186': ':',
        '187': '+',
        '188': '<',
        '189': '_',
        '190': '>',
        '191': '?',
        '192': '~',
        '219': '{',
        '220': '|',
        '221': '}',
        '222': '\''
    },
    NumberCHAR: {
        '96' : '0',
        '97' : '1',
        '98' : '2',
        '99' : '3',
        '100': '4',
        '101': '5',
        '102': '6',
        '103': '7',
        '104': '8',
        '105': '9',
        '106': '*',
        '107': '+',
        '109': '-',
        '110': '.',
        '111': '/'
    }
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/static/const.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/static/config.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

var IbmcCFG;

IbmcCFG = {
    // init
    Version    : '<%=VERSION%>',
    LicenseCode: -1,

    // setMainPath
    JSPath   : null,
    CFGPath  : null,
    AssetPath: null,
    CSSPath  : null,

    // setConfig (ibmulticombo.cfg 옵션)
    LicenseFileName: 'license',
    SaveNameMode   : null,
    EventArgsMode  : null,
    UseSelectCount : null,
    Traditional    : null,
    MultiSeparator : '|',
    SyncRequest    : null,
    UseAutoComplete: null,
    BatchOutput    : null,
    DDListShowBtn  : null,

    //
    ActiveElement: null,
    PrependIE7: true, // ie7 prepend  여부 20151023

    /**
     * MultiCombo 최초 생성시 단 한번만 수행
     * 1. ContentPath 설정
     * 2. ConfigFile 로드 및 설정
     * 3. License 체크
     * @private
     */
    __init: function() {
        var self = this,
            oSTR = IbmcSTR;

        self.setMainPath(_ib.searchDir(IbmcSTR.MAIN_SCRIPT_FILE));

        // Set User Config-file / LicenseFileName, SaveNameMode
        _ib.get({
            accept : 'xml',
            isAsync: false,
            url    : self.CFGPath,
            success: function (sXmlData) {
                var cfg, cfgObj;
                if (sXmlData && sXmlData.documentElement) {
                    if (cfg = _ib(_ib.string2xml((_ib.xml2string(sXmlData) || '').toLowerCase())).find('cfg')) {
                        cfgObj = cfg.attribute([
                            oSTR.CFG_LICENSE_FILE,
                            oSTR.CFG_SAVENAME_MODE,
                            oSTR.CFG_EVT_ARGS_MODE,
                            oSTR.CFG_UNSELECT_COUNT,
                            oSTR.CFG_TRADITIONAL,
                            oSTR.CFG_MULTI_SEPARATOR,
                            oSTR.CFG_SYNC_REQUEST,
                            oSTR.CFG_USE_AUTOCOMPLETE,
                            oSTR.CFG_BATCH_OUTPUT,
                            oSTR.CFG_DDLIST_SHOW_BTN,
                            oSTR.CFG_PrependIE7
                        ].join(','));
                    }
                }
                self.setConfig(cfgObj);
            }
        });

        // 라이센스 체크(로컬호스트 예외처리)
        self.licenseCheck();

        // 단 한번만 수행되도록 함수 재정의
        self.__init = function() {
            return false;
        };
    },

    licenseCheck: function() {
        var sUrl = location.href.toLowerCase(),
            self = this,
            aExceptUrls, fnCallback;

        // 'file://',
        // 'http://localhost',
        // 'https://localhost',
        // 'http://127.0.0.1',
        // 'https://127.0.0.1'
        aExceptUrls = ('1.0.'+'0.721'+'//:s'+'ptth|'+'1.0.'+'0.72'+'1//:'+'ptth'+'|tso'+'hlac'+'ol//'+':spt'+'th|ts'+'ohlac'+'ol//:'+'ptth'+'|//:'+'elif')
            .split('').reverse().join('').split('\|');

        for (var i = 0; i < aExceptUrls.length; i++) {
            if (sUrl.indexOf(aExceptUrls[i]) >= 0) {
                return;
            }
        }

        // 라이센스 체크
        if(_ib._cclce() < 0) {
            fnCallback = function(license) {
                self.LicenseCode = _ib._clce(license);
            };
            _ib.xRequest().sendRequest({
                isAsync: false,
                type   : 'get',
                accept : 'text',
                url    : self.getLicenseURL(),
                success: fnCallback,
                fail   : function() {
                    fnCallback && fnCallback('');
                }
            });
        }
    },

    /**
     * 기본경로 설정
     * @param sPath
     */
    setMainPath: function(sPath) {
        var self = this,
            assetRel, cfgRel;

        assetRel = cfgRel = '/';

        if (sPath == null || sPath === '' || sPath === '/') {
            sPath = "./";
        }

        sPath = sPath.slice(0, -1);

        if(IbmcDEV.isDevelopMode) {
            sPath = sPath.replace(/\/main$/g, '');
            assetRel += 'assets/';
            cfgRel += 'config/'
        }

        self.JSPath = self.CFGPath = self.AssetPath = sPath;
        self.CFGPath += cfgRel + IbmcSTR.CFG_FILE;
        self.AssetPath += assetRel;

        console.log('%cRootPath: ' + self.JSPath, IbmcDEV.C3);
        console.log('%cCFGPath: ' + self.CFGPath, IbmcDEV.C3);
        console.log('%cAssetPath: ' + self.AssetPath, IbmcDEV.C3);
    },
    /**
     * ibmulticombo.cfg 옵션을 설정
     * @param oTarget
     * @see IBTab
     */
    setConfig: function(oTarget) {
        /*
         LicenseFileName: 'license',
         SaveNameMode   : null,
         EventArgsMode  : null,
         UseSelectCount : null,
         Traditional    : null,
         MultiSeparator : '|',
         SyncRequest    : null,
         UseAutoComplete: null,
         BatchOutput    : null,
         DDListShowBtn  : null,
         */
        var self = this,
            oSTR = IbmcSTR,
            BOOLEAN = 'boolean',
            STRING  = 'string',
            sValueType,
            tName, tValue, sPropName;

        for(tName in oTarget) {
            if(!oTarget.hasOwnProperty(tName)) {
                continue;
            }
            tValue = oTarget[tName] || null;
            sValueType = BOOLEAN;
            switch(tName) {
                case oSTR.CFG_LICENSE_FILE:
                    sPropName = 'LicenseFileName';
                    sValueType = STRING;
                    break;
                case oSTR.CFG_SAVENAME_MODE:
                    sPropName = 'SaveNameMode';
                    break;
                case oSTR.CFG_EVT_ARGS_MODE:
                    sPropName = 'EventArgsMode';
                    break;
                case oSTR.CFG_UNSELECT_COUNT:
                    sPropName = 'UseSelectCount';
                    break;
                case oSTR.CFG_TRADITIONAL:
                    sPropName = 'Traditional';
                    break;
                case oSTR.CFG_MULTI_SEPARATOR:
                    sPropName = 'MultiSeparator';
                    sValueType = STRING;
                    break;
                case oSTR.CFG_SYNC_REQUEST:
                    sPropName = 'SyncRequest';
                    break;
                case oSTR.CFG_USE_AUTOCOMPLETE:
                    sPropName = 'UseAutoComplete';
                    break;
                case oSTR.CFG_BATCH_OUTPUT:
                    sPropName = 'BatchOutput';
                    break;
                case oSTR.CFG_DDLIST_SHOW_BTN:
                    sPropName = 'DDListShowBtn';
                    break;
                case oSTR.CFG_PrependIE7: //20151023
                    sPropName = "PrependIE7";
                    break;
            }
            if(sValueType === BOOLEAN) {
                tValue = (tValue == 1);
            } else { // STRING
                tValue = tValue || self[sPropName];
            }
            self[sPropName] = tValue;
        }
    },
    /**
     * 테마 이미지의 경로를 반환
     * @param sThemeName
     * @returns {string}
     */
    getThemePath: function(sThemeName) {
        return this.AssetPath + sThemeName + '/';
    },
    getCSSPath: function(sThemeName) {
        return this.getThemePath(sThemeName) + IbmcSTR.CSS_FILE;
    },
    getLicenseURL: function() {
        return this.JSPath + '/' + this.LicenseFileName;
    }

};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/static/config.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/static/tempOBJ.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

var IbmcTMP;

IbmcTMP = (function() {
    var _isIE67, _isMSiE,
        _sMcmbTemplate,
        _sMcmbListTmpl,
        _sMcmbListChkTmpl,
        _sMcmbListImgTmpl,
        _aDisplayDropdownList,
        _oKeyCode,
        _rText1, _rText2,
        _aExceptKeyList;

    _isMSiE = (_ib.Browser.name === 'msie');
    _isIE67 = (_isMSiE && parseInt(_ib.Browser.version) <= 7);

    _sMcmbTemplate = _ib.template('<div ibcb-name="{{id}}" class="MAINCTL_DIV" style="width:{{multiComboWidth}};">'+
        '<table ibcb-name="{{id}}_IBCBMainTbl" class="MAINCTL_TBL" cellpadding="0" cellspacing="0" style="width: {{multiComboWidth}}; height:{{multiComboHeight}}">'+
            '<tr class="MAINCTL_TBL_TR">'+
                '<td style="width: {{multiComboInputWidth}};">'+
                    '<div ibcb-name="{{id}}_selectedContainer" class="MAINCTL_SELTD_CONTAINER">'+
                        '<div ibcb-name="{{id}}_selectedList" class="MAINCTL_SELTD_LIST"></div>'+
                    '</div>'+
                    '<input id="{{id}}_text" name="{{id}}_text" ibcb-name="{{id}}_text" class="MAINCTL_TBL_EDIT" type="text" style="width: {{multiComboInputWidth}};" autocomplete="off" >'+
                '</td>'+
                '<td style="width:{{multiComboBtnWidth}};" align="right">'+
                    '<span ibcb-name="{{id}}_IBCBMainBtn" class="MAINCTL_TBL_BTN"></span>'+
                    // '<img ibcb-name="{{id}}_IBCBMainBtn" src="{{jsURL}}Main/c_combo2.gif" class="MAINCTL_TBL_BTN" align="absmiddle" />'+
                '</td>'+
            '</tr>'+
        '</table>'+
        '</div>').compile();

    // ie의 actvieX layout에 맞춰주기위한 iframe 추가
    // activeX는 ie의 모든 browser에 동작한다. ie11조차 activeX 동작 가능.
    // activeX를 layout으로 맞추기 위해서 iframe element를 추가하게 되는데 iframe element 영영에대한 event handlering을 따로해주어야 한다(재정신이 아닌 코드 작성).
    // ie와 상관없이 multicombo에서 iframe element가 가진 영역인 title 영역에 대한 event handlering을 요구하는 경우 iframe element를 삭제하여야 한다.
    // ie에서만 그러한 기능을 사용할 수 없으므로 ie 6/7 version에서만 activeX layout을 사용한다고 가정하겠다.
    // (_ib.Browser.name === "msie" ? ('<iframe id="{{id}}_on_activeX" style="width:100%; opacity: 0; filter: alpha(opacity=0); position: absolute; top: 0; left: 0; z-index: 99998;"></iframe>') : '')+
    _sMcmbListTmpl = _ib.template('<div id="{{id}}_DRL" ibcb-name="{{id}}_DRL" class="MAINCTL_DRL_DIV" style="z-index:999999;display: none;">'+
        (_isIE67 ? ('<iframe id="{{id}}_on_activeX" style="width:100%; opacity: 0; filter: alpha(opacity=0); position: absolute; top: 0; left: 0; z-index: 99998;"></iframe>') : '')+
        '<div ibcb-name="{{id}}_IBCBDropDownHead" class="DRL_HEADER_DIV DRL_DIV_BORDER" style="height: 100%">'+
            '<div ibcb-name="{{id}}_IBCBDropDownScroll" class="DRL_HEADER_DIV_SCROLL" style="z-index: 99999;border-width:1px;">'+
                '<table ibcb-name="{{id}}_IBCBDropDownHeaderTBL" class="DRL_HEADER_TBL MAINCTL_DRL_TBL" cellpadding="0" cellspacing="0">'+
                    '<thead>'+
                        '<tr id="{{id}}_IBCBDropDownHeaderTBLTR" ibcb-name="{{id}}_IBCBDropDownHeaderTBLTR"></tr>'+
                    '</thead>'+
                '</table>'+
            '</div>'+
        '</div>'+
        '<div ibcb-name="{{id}}_IBCBDropDown" id="{{id}}_IBCBDropDown" class="DRL_DIV">'+
            '<div ibcb-name="{{id}}_IBCBDropDownScroll" class="DRL_DIV_SCROLL DRL_DIV_BORDER" style="z-index: 99999;border-width:1px;">'+
                '<table ibcb-name="{{id}}_IBCBDropDownTBL" class="DRL_TBL MAINCTL_DRL_TBL' + (_isIE67 ? ' MAINCTL_DRL_TBL_IE67' : '') + '" cellpadding="0" cellspacing="0">'+
                    '<thead></thead><tbody></tbody>'+
                '</table>'+
            '</div>'+
        '</div>'+
        '</div>').compile();

    _sMcmbListChkTmpl = _ib.template('<th ibcb-name="{{id}}_CellTDCHK" align="center" valign="middle" style="width:{{fixedchkwidth}}px;" class="DRL_HEADER_TD DRL_DIV_BORDER">'+
        '<div id="{{id}}_IBCBDropDownHeaderTBLCHKDIV" ibcb-name="{{id}}_IBCBDropDownHeaderTBLCHKDIV" style="position:relative; z-index:98765432; vertical-align: middle; font-size: {{fontSize}}px; font-family: {{fontFamily}};">'+
            '<input type="checkbox" id="{{id}}_checkAll"  ibcb-name="{{id}}_AllCellCheck" style="display: none;" class="DRL_CHECK DRL_TD_CK" onclick="return false">'+
        '</div>'+
        '</th>').compile();

    _sMcmbListImgTmpl = _ib.template('<th ibcb-name="{{id}}_CellTDIMG" align="center" valign="middle" style="width:{{fixedimgwidth}}px;" class="DRL_HEADER_TD DRL_DIV_BORDER">'+
        '<div id="{{id}}_IBCBDropDownHeaderTBLIMGDIV" ibcb-name="{{id}}_IBCBDropDownHeaderTBLIMGDIV" style="vertical-align: middle; font-size: {{fontSize}}px; font-family: {{fontFamily}};">&nbsp;</div>'+
        '</th>').compile();

    _aDisplayDropdownList = _ib.Array([]);

    // keycode 모음
    _oKeyCode = {
        LEFT     : 37,
        UP       : 38,
        RIGHT    : 39,
        DOWN     : 40,
        ESC      : 27,
        ENTER    : 13,
        DELETE   : 46,
        BACKSPACE: 8,
        TAB      : 9
    };

    // validChar 사용시 참조할 정규식
    _rText1 = {
        "1": { pattern: "[a-z\\s]", option: "i"},
        "2": { pattern: "[A-Z\\s]" },
        "3": { pattern: "[a-z\\s]" },
        "4": { pattern: "[\\ㄱ-ㅎㅏ-ㅣ가-힣\\s]" },
        "5": { pattern: "[0-9\\s]" }
    };

    _rText2 = {
        "1": { pattern: "[0-9]" },
        "2": { pattern: "[\\!\\@\\#\\$\\^\\&\\%\\*\\(\\)\\+\\=\\-\\_\\[\\]\\\\\/\\{\\}\\|\\:\\;\\<\\>\\?\\,\\.\\~\\`\\'\\\"]" },
        "3": { pattern: "[0-9]|[\\!\\@\\#\\$\\^\\&\\%\\*\\(\\)\\+\\=\\-\\_\\[\\]\\\\\/\\{\\}\\|\\:\\;\\<\\>\\?\\,\\.\\~\\`\\'\\\"]" }
    };

    // BACKSPACE, TAB, ENTER, SHIFT, CTRL, ALT, ESC, LEFT, UP, RIGHT, DOWN, HOME, END, INSERT, DELETE, CAPS LOCK, NUM LOCK, DEAD_KEY
    _aExceptKeyList = _ib.Array( [8, 9, 13, 16, 17, 18, 27, 35, 36, 37, 38, 39, 40, 45, 46, 20, 144, 229] );

    return {
        isIE67 : _isIE67,
        // DropDown List
        DDList : _aDisplayDropdownList,
        RText1 : _rText1,
        RText2 : _rText2,
        KeyCODE: _oKeyCode,
        ExceptKeyCodes: _aExceptKeyList,

        CssOnLoadCallBack: [],

        ThemeBinder: {},
        Themes: {},

        MTCB_TMPL     : _sMcmbTemplate,
        MTCB_LIST_TMPL: _sMcmbListTmpl,
        MULTI_COMBO_LIST_CHK_TEMPLATE: _sMcmbListChkTmpl,
        MULTI_COMBO_LIST_IMG_TEMPLATE: _sMcmbListImgTmpl
    }
}());
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/static/tempOBJ.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/lib/tmpFunc.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

var TempFNC;

TempFNC = {
    // theme 사용으로 생성된 style tag 관리 및 multicombo 객체에 theme가 적용되도록 className 변경 작업 수행
    themeManage: function(sThemeName, cThemeName, pThemeName) {
        var self = this,
            oThemes = IbmcTMP.Themes,
            oThemeBinders = IbmcTMP.ThemeBinder;

        self.IBCBDRL.removeClass(pThemeName + 'MAINCTL_DRL_DIV').addClass(cThemeName + 'MAINCTL_DRL_DIV');
        self.IBCBMainDiv.removeClass(pThemeName + 'MAINCTL_DIV').addClass(cThemeName + 'MAINCTL_DIV');

        if (pThemeName !== sThemeName) {
            if (_ib.isInteger(oThemeBinders[pThemeName])) {
                oThemeBinders[pThemeName] -= 1;

                if (oThemeBinders[pThemeName] <= 0) {
                    if (oThemes[pThemeName]) {
                        // 더이상 사용하지 않는 Theme라면 해당 Theme에 대한 style tag를 삭제한다.
                        _ib(oThemes[pThemeName]).remove();
                        oThemes[pThemeName] = null;
                        oThemeBinders[pThemeName] = null;
                    }
                }
            }

            if (cThemeName !== '') {
                if (oThemeBinders[cThemeName]) {
                    oThemeBinders[cThemeName] += 1;
                } else {
                    oThemeBinders[cThemeName] = 1;
                }
            }
        }

        self.options.themeName = cThemeName;
    },
    setTheme: function(sName, isInit) {
        var self = this,
            opts = self.options,
            fnThemeManage = TempFNC.themeManage,
            fnCallback = IbmcTMP.CssOnLoadCallBack,
            oThemes = IbmcTMP.Themes,
            sThemeName, sPrefix, sCssPath;

        sThemeName = (sThemeName = sName.split(/\//))[sThemeName.length-1];
        sPrefix = sThemeName === 'Main' ? '' : sThemeName;

        if(oThemes[sThemeName]) {
            fnThemeManage.call(self, sThemeName, sPrefix, opts.themeName);
            self.__initMultiComboStyle();
        } else {
            sCssPath = IbmcCFG.getCSSPath(sName);
            _ib.get({
                isAsync: false,
                accept : 'text',
                url    : sCssPath,
                success: function(cssData) {
                    var tmpStyle;

                    console.log('%cExternal CSS File Loaded: ' + sCssPath, IbmcDEV.C3);
                    if(cssData) {
                        cssData = cssData.replace('{{ImagePath}}', IbmcCFG.AssetPath + sName);

                        //console.log('MultiCombo', MultiCombo != null);

                        if(!isInit) {

                            if (oThemes[sThemeName]) {
                                _ib(oThemes[sThemeName]).remove();
                                oThemes[sThemeName] = null;
                            }

                            fnThemeManage.call(self, sThemeName, sPrefix, opts.themeName);

                            cssData = cssData.replace(/MAINCTL_DIV/g, function($1) {
                                return sPrefix + $1;
                            }).replace( /MAINCTL_DRL_DIV/g, function($1) {
                                return sPrefix + $1;
                            });
                        }

                        tmpStyle = _ib.createStyle(cssData);

                        oThemes[sThemeName] = tmpStyle;

                        // ibmulticombo에서 css file을 javascript에서 로드함으로
                        // domLoaded된 후에도 element의 width와 heigt값을 정확하게 알수가 없으므로
                        // 임의의 cssLoaded callback을 호출한다.
                        if(_ib.isFunction(fnCallback)) {
                            fnCallback = [fnCallback];
                        }

                        if (_ib.isArray(fnCallback)) {
                            for (var i = 0, len = fnCallback.length; i < len; ++i) {
                                fnCallback[i]();
                            }
                        }
                        self.__initMultiComboStyle && self.__initMultiComboStyle();
                    }

                    //console.log('/// setTheme END');
                }
            });
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/lib/tmpFunc.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/lib/util.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

var Util;

Util = (function() {

    // RGB 문자열을 #ffffff 코드 형식으로 변환
    function _styleRgbToHex(sRGB) {
        var aRGB = sRGB.replace('rgb(', '').replace(')', '').split(',');
        return _RGBtoHex(aRGB[0],aRGB[1],aRGB[2]);
    }

    // #ffffff 코드 형식으로 만들기
    function _RGBtoHex(R, G, B) {
        return '#' + _toHex(R)+_toHex(G)+_toHex(B);
    }

    function _toHex(N) {
        if(N == null) {
            return '00';
        }
        N = parseInt(N);

        if(N == 0 || isNaN(N)) {
            return '00';
        }

        N = Math.max(0, N);
        N = Math.min(N, 255);
        N = Math.round(N);

        return '0123456789ABCDEF'.charAt((N - N % 16) / 16) + '0123456789ABCDEF'.charAt(N % 16);
    }

    return {
        /**
         * String Type의 값을 Boolean 값으로 변환
         * @param p1
         * @param p2
         * @param p3 기본값
         * @returns {*}
         */
        getStr2Bool: function(p1, p2, p3) {
            var bool;
            if(p1 != null) {
                bool = p1;
            } else if(p2 != null) {
                bool = p2;
            } else {
                bool = p3;
            }

            if(_ib.isString(bool)) {
                bool = (bool == '1' || bool == 'true') ? true : false;
            } else {
                bool = !!bool;
            }
            return bool;
        },
        convertColor: function(sColor) {
            if(_ib.isString(sColor) && sColor.indexOf('rgb') != -1){
                return _styleRgbToHex(sColor);
            } else {
                return sColor;
            }
        },
        string2color: function(str) {
            if (_ib.isString(str) && /(^[0-9A-F]{6}$)|(^[0-9A-F]{3}$)/i.test(str)) {
                return '#' + str;
            }
            return str;
        },
        mapKeyPressToActualCharacter: function(evt) {
            var sResult = '',
                oCharMAP = IbmcMAP,
                isShiftKey,
                tmpChar;

            isShiftKey = evt.shiftKey;
            tmpChar = evt.keyCode;

            if (tmpChar === 27
                || tmpChar === 8
                || tmpChar === 9
                || tmpChar === 20
                || tmpChar === 16
                || tmpChar === 17
                || tmpChar === 91
                || tmpChar === 13
                || tmpChar === 92
                || tmpChar === 18) {
                return false;
            }
            if (typeof tmpChar != "number") {
                return false;
            }

            if (isShiftKey) {
                if (tmpChar >= 65 && tmpChar <= 90) {
                    sResult = String.fromCharCode(tmpChar);
                } else {
                    sResult = oCharMAP.StdShiftCHAR[tmpChar];
                }
            } else {
                if (tmpChar >= 65 && tmpChar <= 90) {
                    sResult = String.fromCharCode(tmpChar).toLowerCase();
                } else {
                    sResult = oCharMAP.StdCHAR[ tmpChar ] || oCharMAP.NumberCHAR[ tmpChar ] || String.fromCharCode(tmpChar);
                }
            }
            return sResult;
        }
    };
}());
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/lib/util.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/object/McmbOption.js
/**
 * Created by Euiyeon on 2015-03-19.
 * MultiCombo Instance Options
 */

var McmbOption = function() {};

McmbOption.prototype = {

};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/object/McmbOption.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/MultiCombo.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

var MultiCombo, MultiComboFn = {};

MultiCombo = function(ele, userOpts) {
    var self = this,
        MIN_WIDTH = 22,
        width = userOpts.width,
        height= userOpts.height,
        cols = userOpts.cols,
        opts, elem, sName,
        widthUnit,
        mComboWidth,
        mComboInputWidth,
        mComboBttnWidth = 20;

    // control 생성에 기준이 되는 target element
    elem = self.element = _ib(ele);
    sName = elem.attribute('id');
    elem.attribute({
        'ibcb-delegate':true,
        name: IbmcCFG.SaveNameMode ? sName : sName + '_code'
    });

    if (widthUnit = _ib.unitSplitExp.exec(width)) {
        width = parseInt(widthUnit[1]);
        // px단위 로 width값 입력
        if (_ib.isInteger(width)) {
            if (widthUnit[2] === 'px' || !widthUnit[2]) {
                mComboWidth = (width < MIN_WIDTH ? MIN_WIDTH : width);
                mComboInputWidth = (mComboWidth - mComboBttnWidth) + 'px';

                mComboWidth += 'px';
                mComboBttnWidth += 'px';
            }
        }
    } else {
        mComboWidth = '100%';
        mComboInputWidth = '100%';
        mComboBttnWidth = '20px';
    }

    if (_ib.unitSplitExp.exec(height)) {
        !RegExp.$2 && (height += 'px');
    }

    opts = self.options = {
        // 포커스를 잃을 때 이벤트가 발생한다.
        onBlur: userOpts.onBlur,
        // 선택된 Item이 변경되었을 때 이벤트가 발생한다. 기존에 선택된 Item을 다시 선택했을때는 이벤트가 발생하지 않는다.
        onChange: userOpts.onChange,
        // MultiSelect를 이용하는 경우, 체크박스를 클릭시 발생한다.
        onCheckClick: userOpts.onCheckClick,
        // MultiSelect를 이용하는 경우, 헤더의 전체체크를 클릭시 발생한다.
        onCheckAllClick: userOpts.onCheckAllClick,
        // 모든 아이템이 삭제 되었을 때 이벤트가 발생한다. RemoveAll 함수 또는 DeleteItem 함수를 이용하여 아이템이 모두 삭제되면 이벤트가 발생한다.
        onClear: userOpts.onClear,
        // 포커스를 얻을 때 이벤트가 발생한다.
        onFocus: userOpts.onFocus,
        // 키보드의 키가 눌렸을 때 발생한다.
        onKeyDown: userOpts.onKeyDown,
        // MultiSelect 이면서 스크립트로 '|' 구분자를 통해 다중 선택하는 경우 설정한 값이 존재하지 않는 아이템일 때 발생한다.
        onMultiCheckError: userOpts.onMultiCheckError,
        // 아이템이 선택되었을 때 이벤트가 발생한다. OnChange 이벤트와 달리 OnSelect 이벤트는 같은 값을 선택하여도 이벤트가 발생한다.
        onSelect: userOpts.onSelect,

        // dropdown list에서 사용자가 선택한 item 목록
        selectedValue: _ib.Array([]),

        // dropdown list에서 사용자가 선택 가능한 item 수
        selectingCount: userOpts.maxSelect || 0,

        visible: true,      // control display 출력 여부
        Index : -1,
        id : sName,
        multiComboWidth : mComboWidth,
        multiComboInputWidth : mComboInputWidth,
        multiComboBtnWidth : mComboBttnWidth,
        multiComboHeight : height || '100%',

        //jsURL : IbmcCFG.JSPath,

        // 고정 cols(checkbox, imagebox)
        fixCols : 2,
        // 열 개수
        cols : cols,
        // 행 개수
        rows : 0,
        defaultColWidth : 100,

        // 최상위 element의 className에 추가되는 prefix 문자열
        themeName: '',

        ColBackColor : [],
        ColWidth : [],
        maxColWidth : [],
        maxColWidthText : [],
        ColAlign : [],

        // 드롭다운 및 아이템 높이 설정 관련
        dropWidth    : width || 200,
        totalWidthCap: 2,
        headerHeight : 21,
        minItemHeight: 21,
        itemHeight   : 21,
        oriDropHeight: userOpts.dropHeight || 105,
        dropHeight   : userOpts.dropHeight || 105,
        fixedchkwidth: 20,
        fixedimgwidth: 21,

        //폰트 관련
        fontSize     : 12,
        fontFamily   : 'Dotum',
        fontColor    : '#000000',
        headFontColor: '#000000',

        // ibmulticombo의 IBCBMain수정 가능여부
        editable: true,

        // ibmulticombo의 readOnly font color
        readOnlyFontColor: '#000000',

        // ibmulticombo의 readOnly background color
        readOnlyBackColor: '#F4F4F4',

        editFontBold   : 'normal',
        selectFontColor: '#000000',
        hoverFontColor : '#000',

        maxSelect : -1,
        fixMultiSeparator: '|',
        multiSeparator: IbmcCFG.MultiSeparator || '|',
        multiSelect   : Util.getStr2Bool(userOpts.multiSelect, null, false),
        useImage      : Util.getStr2Bool(userOpts.useImage, null, false),

        syncRequest: Util.getStr2Bool(IbmcCFG.SyncRequest, userOpts.syncRequest, false),

        //색상관련------------
        selectColor         : '#FFEEAA',
        hoverColor          : '#FEA',
        nonSelectColor      : '#FFFFFF',
        backColor           : '#FFFFFF',
        outLineColor        : '#99BCE8',
        dropDownOutLineColor: '#99BCE8',
        lineColor           : '#E0E0FF',
        disabledBackColor   : '#EBEBE4',
        ColFontColor        : [],

        // 사용자가 선택한 item에 대한 selected box UI 사용여부
        useSelectedBox: Util.getStr2Bool(userOpts.useSelectedBox, null, false),

        // selectedBox의 부모 element의 width
        editWidth: 0,

        // selectedBox에 키보드 조작에 사용되는 element의 width
        textEditWidth: 0,

        // 타이틀 배경색
        titleColor : '#c9e1f5',
        // dropdown list에서 header 출력여부
        titleVisible : Util.getStr2Bool(userOpts.titleVisible, null, false),
        // input에 최대 사용자가 입력가능한 문자열 길이
        maxLength : -1,
        // ibmulticombo 활성화 여부
        enable: true,

        // 사용자가 임의로 IBCBMainEdit에 준 값
        viewText: '',
        // 선택한 item의 text 표기 대신 선택 한 건수 표기 사용여부
        useSelectCount : Util.getStr2Bool(IbmcCFG.UseSelectCount, userOpts.useSelectCount, false),
        // 건수 표시 prefix
        allCountKor: '선택 ',
        // 건수 표기 postfix
        NumberKor: '건',
        // PlaceHolder4CheckAll
        placeHolder4CheckAll: '',

        // 값 필수 입력 체크(브라우저에 위임함)
        required: false,
        // form tag로 하위 element의 name으로 값 가져오기 위한 구닥다리방법
        savename: '',
        // event handler의 첫번째 인자에 control 전달여부
        //eventArgsMode: IbmcCFG.EventArgsMode || userOpts.eventArgsMode || false,
        traditional: Util.getStr2Bool(IbmcCFG.Traditional, userOpts.traditional, false),
        // ie전용 keyboard 입력키 강제
        imeMode: 'auto',
        // inputbox에 편집한 글자 유지 여부
        useEdit: false,
        // inputbox에 글자 입력하면 문자열 체크 후 출력 해당 아이템 dropdown list에 출력
        useAutoComplete: Util.getStr2Bool(userOpts.useAutoComplete, IbmcCFG.UseAutoComplete, false),
        // tradAutoComplete: false,

        // 사용자가 dropdown list에서 선택하면 input에 output 될 col의 index
        showCol: userOpts.showCol || 0,

        wrappingHtml: userOpts.wrappingHtml,

        // outputMainEdit 에서 출력시 역순 출력
        batchOutput: Util.getStr2Bool(userOpts.batchOutput, IbmcCFG.BatchOutput, false),

        narrowDDListShowBtn: Util.getStr2Bool(userOpts.narrowDDListShowBtn, IbmcCFG.DDListShowBtn, false),

        delegateTextExp: userOpts.delegateTextExp,
        // scroll 사용시 head(title) element의 marginRight
        scrollMarginRight: userOpts.scrollMarginRight || 17,
        // IE서 active-X랑 같이 사용시 active-X control 상위에 오기위해 iframe 사용여부
        displayOnIframe: _ib.isUndefined(userOpts.displayOnIframe),
        AllowEvent4CheckAll: true, //2015.10.20 전체선택시 이벤트 여부
        AllowEvent4Flag : true,
        prependIE7: Util.getStr2Bool(userOpts.prependIE7, IbmcCFG.PrependIE7,   false), //20151023
        Skip4CheckAll: false //20151029 위세요청 속도문제로 전체클릭시 단순히 placeHolder만 출력되도록 처리

    };

    //console.log('opts.useSelectCount', opts.useSelectCount);

    if (userOpts.init !== false) {
        if (document && document.readyState) {
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                self.Init(opts.showCol, userOpts);
            }
        } else {
            self.Init(opts.showCol, userOpts);
        }
    }

    //console.log('%c1-1 ' + sName + '.MultiCombo End', IbmcDEV.C2);
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/MultiCombo.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/autoSelectForMulti.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._autoSelectForMulti = function ( value ) {
    var self,
        options,
        selectText,
        i, len,
        invalidValues,
        pass;

    self = this;
    options = self.options;
    selectText = self.GetSelectText();
    invalidValues = [];

    // 사용자가 입력한 값이 전부다 입력되거 안되거나
    if ( selectText !== value ) {
        if ( value !== "" ) {
            value = value.split( options.multiSeparator );
            for ( i = 0, len = value.length; i < len; ++i ) {
                if ( self.FindItem( value[ i ], options.showCol, true ) < 0 ) {
                    invalidValues.push( value[ i ] );
                    pass = true;
                }
            }
        }

        if ( pass ) {
            if ( value.length > 0 ) {
                self._eventCaller('multicheckerror')(invalidValues.join(self.options.fixMultiSeparator));
            }
        } else {
            selectText = selectText.split( options.multiSeparator );

            for ( i = 0, len = selectText.length; i < len; ++i ) {
                if ( selectText[ i ] !== "" && _ib.Array( value ).indexOf( selectText[ i ] ) < 0 ) {
                    self._itemSelect( selectText[ i ], false, "text", undefined, true, false);
                }
            }
            for ( i = 0, len = value.length; i < len; ++i ) {
                if ( value[ i ] !== "" && _ib.Array( selectText ).indexOf( value[ i ] ) < 0 ) {
                    self._itemSelect(value[ i ], true, "text", undefined, true, false);
                }
            }
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/autoSelectForMulti.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/blurTran.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._blurTran = function ( isEvent ) {
    var self,
        options;

    self = this;
    options = self.options;

    if ( options.focusHighlightColor ) {
        self.IBCBMainTbl.css("borderColor", options.outLineColor);
    }
    self.IBCBMainTbl.removeClass("MAINCTL_FOCUS");
    if ( _ib.isBoolean( isEvent ) ) {
        isEvent && self._eventCaller('blur')();
    } else {
        self._eventCaller('blur')();
    }

    setTimeout( function () {
        var tempValue = self.IBCBMainEdit.value();
        self.IBCBMainEdit.value("");
        setTimeout( (function() {
            return function() {
                return self.IBCBMainEdit.value(tempValue);
            };
        }( tempValue )), 20 );
    }, 0 );
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/blurTran.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/deleteValue.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// 사용자가 선택한 값 초기화
MultiComboFn._deleteValue = function(ele) {               
    var self = this,
        options = self.options,
        id = options.id,
        // 사용자가 선택한 값
        selectedValue = options.selectedValue,
        data;

    if (ele && _ib.isElement(ele[0]) && ele.length === 1) {
        if (data = ele.data("cell_data")) {
            if (selectedValue.indexOf(data) > -1) {
                selectedValue.remove(data);
                self._outputMainEdit();
            }

            --options.rows;
            ele.remove();
        }
    }

    if (options.rows === 0) {
        window[id + "_OnClear"] ? window[id + "_OnClear"]() : options.onClear && options.onClear();
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/deleteValue.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/destroy.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// IBCBClearObj
MultiComboFn._destroy = function() {
    var self = this,
        id = self.options.id,
        ele;
    try {
        // self.elementPreviousSibling.after(self.element);
        if ((ele = self.IBCBMainDiv.previous()).length) {
            ele.after(self.element);
        } else if ((ele = self.IBCBMainDiv.next()).length) {
            ele.before(self.element);
        } else if ((ele = self.IBCBMainDiv.parent())) {
            ele.append(self.element);
        }
    } catch(e){}

    window[id + "_OnBlur"] &&  (window[id + "_OnBlur"] = null);
    window[id + "_OnChange"] &&  (window[id + "_OnChange"] = null);
    window[id + "_OnCheckClick"] &&  (window[id + "_OnCheckClick"] = null);
    window[id + "_OnCheckAllClick"] &&  (window[id + "_OnCheckAllClick"] = null);
    window[id + "_OnClear"] &&  (window[id + "_OnClear"] = null);
    window[id + "_OnFocus"] &&  (window[id + "_OnFocus"] = null);
    window[id + "_OnKeyDown"] &&  (window[id + "_OnKeyDown"] = null);
    window[id + "_OnMultiCheckError"] &&  (window[id + "_OnMultiCheckError"] = null);
    window[id + "_OnSelect"] &&  (window[id + "_OnSelect"] = null);
    window[self.options.id] instanceof _ib.ui.multicombo && (window[self.options.id] = null);

    self.IBCBMainDiv.remove();
    self.IBCBDRL.remove();

    self.element.show();

    self.element.removeData("multicombo").removeAttribute("required disabled readonly");
};

// ie전용 iframe element 삭제
MultiComboFn.destroyActiveXLayout = function () {
    _ib( "#" + this.options.id + "_on_activeX" ).remove();
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/destroy.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/dropdownProcess.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._dropdownProcess = function(flag, isEvent, postView, isBlurEvent, autoSelect) {
    var self = this,
        opts = self.options,
        id = opts.id,
        target = self.IBCBMainTbl,
        list = self.IBCBDRL,
        offset,
        maxColWidth = opts.maxColWidth,
        IBCBDropDownHeaderTBLTR = self.IBCBDropDownHeaderTBLTR,
        tdEle,
        isScroll,
        value,
        oldData,
        oldText,
        newIndex,
        newText,
        newCode,
        newValue,
        tempHeight;

    if (flag) {
        offset = target.offset();

        opts.headerHeight = opts.headerHeight < opts.minItemHeight ? opts.minItemHeight : opts.headerHeight; // header height 기본값 유지
        opts.itemHeight = opts.itemHeight < opts.minItemHeight ? opts.minItemHeight : opts.itemHeight;       // item height 기본값 유지

        self.IBCBDropDownBodyScroll.css("height", opts.dropHeight);

        isScroll = self._hasScroll();
        self._setDropHeight("");
        self.IBCBDropDownBodyScroll.css({overflowY: isScroll ? "auto" : "hidden"})

        if (self.IBCBDropDownHeaderTBLTR.css("height") !== opts.headerHeight) {
            self.IBCBDropDownHeaderTBLTR.css("height", opts.headerHeight);
        }
        opts.itemHeight !== self.viewport.options.rowHeight && self.viewport.setRowHeight(opts.itemHeight);

        self._openDropdown( list, offset.left, offset.top + target.outerHeight() +1, isScroll, opts.dropWidth );

        // Object 상위 출력용 꼼수 panel의 높이 설정
        if (self.panelOnObject) {
            self.panelOnObject.css({height: opts.dropHeight + (opts.titleVisible ? opts.headerHeight : 0)});
        }

        list.show();
        IbmcTMP.DDList.indexOf( self ) < 0 && IbmcTMP.DDList.push( self );

        self.viewport.refresh();
        self.reserveRefresh = false;

        if ( self.reserveDropHeight ) {
            console.log('DropDownProc._setTempDropHeight: ' + self.options.oriDropHeight);
            self._setTempDropHeight( self.options.oriDropHeight );
            self.reserveDropHeight = false;
        }

        if ( _ib.isInteger( self._prevScrollTop ) ) {
            self.IBCBDropDownBodyScroll.scrollTop( self._prevScrollTop );
        }

        var viewPost = _ib(postView || window);
        var heightViewPost = window.innerHeight || document.documentElement.clientHeight;
        var scrollTopViewPost = viewPost.scrollTop();
        var targetOuterHeight = target.outerHeight();
        var listHeight1 = self.IBCBDropDownBodyScroll.height();
        var listHeight2 = self.IBCBDropDownHeadScroll.height();

        if (heightViewPost <= offset.top - scrollTopViewPost + listHeight1 + listHeight2 + targetOuterHeight + 1 && scrollTopViewPost <= offset.top - listHeight1 - listHeight2  - 1) {
            list.offset({top: offset.top - listHeight1 - listHeight2 - 4});
        } else {
            list.offset({top: offset.top + targetOuterHeight +1});
        }

        var widthViewPost = window.innerWidth || document.documentElement.clientWidth;
        var scrollLeftViewPost = viewPost.scrollLeft();
        var targetOuterWidth = target.outerWidth();
        var listWidth1 = self.IBCBDropDownBodyScroll.width();

        if (widthViewPost <= offset.left - scrollLeftViewPost + listWidth1 + 1 && scrollLeftViewPost <= offset.left - listWidth1 + targetOuterWidth - 1) {
            list.offset({left: offset.left - listWidth1 - 2 + targetOuterWidth});
        } else {
            list.offset({left: offset.left});
        }

        if (_ib.Browser.name == "chrome" && self.IBCBDropDownTBL.children(1).length > 0) {
            self.IBCBDropDownTBL.children(1).children().foreach(function(index) {
                self.IBCBDropDownHeaderTBL.children(0).children(index).width(_ib(this).width());
            });
        }

        self.IBCBMainDiv.attribute("ibcb-active", true);
        IbmcCFG.ActiveElement = self.IBCBMainDiv;
    } else {
        // Object 상위 출력용 꼼수 panel의 높이 설정
        if (self.panelOnObject) {
            self.panelOnObject.css({height: 0});
        }

        self._prevScrollTop = self.IBCBDropDownBodyScroll.scrollTop();

        list.hide();
        IbmcTMP.DDList.remove( self );


        self.IBCBMainDiv.removeAttribute("ibcb-active");
        IbmcCFG.ActiveElement = null;

        newValue = self.GetSelectText();

        if (!opts.multiSelect && !opts.useSelectedBox && opts.useEdit) {
            oldData = self.options.selectedValue.array[0];
            newText = self.IBCBMainEdit.value();
            oldText = oldData ? oldData.text : "";

            // console.log("oldText: " + self._oldUseEditText, "newText: " + newText);
            // 사용자가 입력하지 않은 데이터를 임의로 편집 하였다면 change callback 호출
            if ( isEvent !== false && self._oldUseEditText !== newText && ( newText !== "" || oldText !== "" ) ) {
                // multiSelect 사용하지 않고 useEdit 사용하고  useSelectedBox 사용하지 않을때 편집한 글자를 유지함

                oldText = self._oldUseEditText == null ? oldText : self._oldUseEditText;
                var oldIndex = self.FindItem( oldText, opts.showCol, true ) + "";
                var oldCode = self.FindItem( oldText, opts.showCol, true );
                oldCode < 0 && (oldCode = "");
                oldCode += "";

                newIndex = self.GetSelectIndex();
                newCode = self.GetSelectCode();

                if ( autoSelect != false ) {
                    result = self._hasText2( newText );
                    if ( result === 1 ) {
                        self._fullSelectText = newText;
                        self.SetSelectText( newText, true );
                    }

                    //self._eventCaller('change')(
                    //    oldIndex,
                    //    oldText,
                    //    oldCode,
                    //    newIndex,
                    //    newText,
                    //    newCode
                    //);
                    // 2015.10.02  checkAllClick 이벤트 보다 change / select 이벤트가 더 빨리 발생하지 않도록 변경  **************//
                    setTimeout(function() {
                        self._eventCaller('change')(
                            oldIndex,
                            oldText,
                            oldCode,
                            newIndex,
                            newText,
                            newCode
                        );
                    },1);
                //*******************************************//
                }
            }
            self._oldUseEditText = newText;
        }

        if (opts.viewText && !opts.useSelectedBox) {
            // viewText를 사용하고 useSelectedBox를 사용하지 않을때 사용자가 임의로 값주면 blur되도 text값 수정안함.
            opts.viewText = undefined;
        }  else {
            if ( !opts.useEdit ) {
                value = self.IBCBMainEdit.value();
                if ( !self.options.multiSelect ) {
                    var value,
                        result;

                    result = self._hasText2( value );

                    if ( result === -1 ) {
                        if ( opts.selectedValue.length() > 0 ) {
                            self._itemSelect( opts.selectedValue.get( 0 ).code, false );
                        }
                    } else if ( result === 0 ) {
                        if ( _ib.isInteger( self.selectingItem ) ) {
                            self._itemSelect( self.selectingItem, true );
                        }
                    } else if ( result === 1 && autoSelect !== false && self._fullSelectText !== value) {
                        self._fullSelectText = value;
                        self.SetSelectText( value, true );
                    }
                } else {
                    if ( opts.useSelectCount == false ) {
                        self._autoSelectForMulti( value );
                    }
                }
                self._outputMainEdit();
            } else {
                if ( opts.multiSelect ) {
                    self._outputMainEdit();
                }
            }
        }

        if ( isBlurEvent !== false ) {
            self._blurTran( isEvent );
        }
    }
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/dropdownProcess.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/eventAssign.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._assignListener = function() {
    var self = this,
        options = self.options,
        id = options.id,
        activeDropdownFlag,
        input = self.IBCBMainTbl,
        editbox = self.IBCBMainEdit,
        list = self.IBCBDRL,
        dropdownTbl = self.IBCBDropDownTBL.parent(),
        isChanged = false,
        isEmpty,
        btarget,
        selection,
        selection2,
        selectedItem,               // selectedbox 사용시 selectedbox의 list중 에서 사용자가 보고있는 item
        selectedValue = options.selectedValue,  // 사용자가 선택한 코드 저장소
        prevValue2,
        prevValue,              // keydown 시 dropdown list fiter 이전값
        indexTimeout,           // keydown 시 dropdown list filter timeout
        keydownChars = [],
        keydownFlag = false,
        paste,
        isBlur;

    input.delegate("tr,input[ibcb-name=" + id + "_text],img[ibcb-name=" + id + "_IBCBMainBtn],.MAINCTL_SELTD_ITEM_CANCEL", "mousedown", function(e) {
        if ( self._isRightClick( e ) ) {
            return;
        }
        // dropdown list를 show, hide 하는 display 동기화
        btarget = (e.target === self.IBCBMainBtn[0] || e.selector === "tr" || e.selector === ".MAINCTL_SELTD_ITEM_CANCEL");
    });

    input.delegate("tr,input[ibcb-name=" + id + "_text],img[ibcb-name=" + id + "_IBCBMainBtn],.MAINCTL_SELTD_ITEM_CANCEL", "mouseup", function(e) {
        var ele, data,
            display = list.css("display"),
            value;

        if ( self._isRightClick( e ) ) {
            return;
        }

        // multicombo 비활성 상태에서 event handling 안함.
        if (!options.enable) {
            return;
        }

        // // 사용자가 list를 열때 focus 주며 닫을때에는 focus 주지 않음
        if ( btarget ) {
            editbox.focus();
            btarget = false;
        }

        if (e.selector === ".mainctl-seltd-item-cancel") {      // item 삭제 버튼
            ele = _ib(e.target).parent();
            data = ele.data("link");

            if (data) {
                options.multiSelect ? self._selectItem(data, data.ele, true, false) : self._selectItem(data, undefined, undefined, false);
            }
        } else {
            if ( options.narrowDDListShowBtn === true && e.target.nodeName !== "SPAN" ) {
                return;
            }

            self._dropdownProcess(self.dropdownListFlag, true, undefined, false );
            self.dropdownListFlag = !self.dropdownListFlag;

            value = _ib.String(editbox.value()).trim();
            if ( !options.multiSelect ) {
                if (options.useAutoComplete) {
                    indexTimeout && clearTimeout(indexTimeout);
                    self._itemFilter(true);

                    if (!self.dropdownListFlag) {
                        if ( value === "" || !self._hasText(value)) {
                            self._moveSelectingItemFocus(true);
                        } else {
                            self._moveSelectingItemFocus();
                            self.selectingItem = self._moveSelectingItem(self.selectingItem, 0);
                        }
                    }
                } else
                {
                    if ( self.viewport.options.data == null || self.viewport.options.data.length === 0 ) {
                        //console.log('eventAssign._setTempDropHeight-1: ' + self.options.oriDropHeight);
                        self._setTempDropHeight( self.options.oriDropHeight );
                    }
                    var result = self._hasText2( value );
                    if ( value !== "" ) {
                        if ( result === 1 ) {
                            self._moveSelectingItemFocus();
                            self.selectingItem = self._moveSelectingItem(self.selectingItem, 0);
                        }
                    }
                }
            } else {
                if ( self.viewport.options.data == null || self.viewport.options.data.length === 0 ) {
                    //console.log('eventAssign._setTempDropHeight-2: ' + self.options.oriDropHeight);
                    self._setTempDropHeight( self.options.oriDropHeight );
                }
                if ( value !== "" ) {
                    self._moveSelectingItemFocus();
                    if ( self.selectingItem != null ) {
                        self.selectingItem = self._moveSelectingItem(self.selectingItem, 0);
                    }
                }
            }
        }
    });

    var isAllCellCheck = false;
    self.IBCBHeaderChkDiv.addEvent( {
        click: function(evt) {
            //if(evt.target.id==id+"_chkAll"){
            //    setTimeout(function () {self._eventCaller("checkallclick")(evt.target.checked) }, 1);
            //}
        },
        mousedown: function ( evt ) {
            btarget = dTarget = true;
            if ( evt.target.nodeName === "INPUT" ) {
                isAllCellCheck = true;
                if(options.Skip4CheckAll==true){ return ;}
                if( self.options.AllowEvent4CheckAll==true ) self._eventCaller("checkallclick")(!evt.target.checked);
                else self.options.AllowEvent4Flag= false;
                //self._eventCaller("checkallclick")(!evt.target.checked);

            }
        },
        mouseup: function ( evt ) {
            var target;

            target = evt.target;
            if(options.Skip4CheckAll==true){
                if (isAllCellCheck && evt.target.nodeName === "INPUT") {
                    if(target.checked){
                        target.checked = !target.checked;
                        editbox.value("");
                    }else{
                        target.checked = !target.checked;
                        editbox.value(options.placeHolder4CheckAll);
                    }

                }
                return ;
            }
            if ( isAllCellCheck && evt.target.nodeName === "INPUT" ) {
                self.SetSelectIndex( target.checked = !target.checked );
            }
            if (btarget) {
                editbox.focus();
                btarget = false;
                dTarget !== undefined && self.IBCBDRL.hide();
            }
            isAllCellCheck = false;
        }
    } );

    if (!_ib.isSmartDevice) {
        editbox.addEvent("keydown", function(e) {
            var oKeyMAP = IbmcTMP.KeyCODE,
                ele, value, keyCode, data, tmpChar;

            keyCode = e.keyCode;

            if (keyCode == oKeyMAP.TAB) {
                if (self.IBCBDRL.css("display") === "block") {
                    setTimeout(function () {
                        self.IBCBMainEdit.trigger("keydown",{keyCode:13});
                    }, 0);
                    return false;
                }
            }

            value = _ib.String(editbox.value()).trim();

            self._reserveBlur = true;
            switch(keyCode) {
                case oKeyMAP.LEFT:
                case oKeyMAP.RIGHT:
                    e.stopPropagation();
                    break;
                case oKeyMAP.DOWN:
                    e.preventDefault();
                    e.stopPropagation();

                    if (self.dropdownListFlag) {
                        self._dropdownProcess(true);
                        self.dropdownListFlag = false;

                        if ( !options.multiSelect ) {
                            if ( options.useAutoComplete ) {
                                indexTimeout && clearTimeout(indexTimeout);
                                self._itemFilter(true);

                                if ( value === "" || !self._hasText(value) ) {
                                    self._moveSelectingItemFocus( true );
                                } else {
                                    self._moveSelectingItemFocus();
                                    self.selectingItem = self._moveSelectingItem(self.selectingItem, 0);
                                }
                            } else
                            {
                                if ( self.viewport.options.data == null || self.viewport.options.data.length === 0 ) {
                                    console.log('eventAssign._setTempDropHeight-3: ' + self.options.oriDropHeight);
                                    self._setTempDropHeight( self.options.oriDropHeight );
                                }
                                var result22 = self._hasText2( value );
                                if ( value !== "" ) {
                                    if ( result22 === 1 ) {
                                        self._moveSelectingItemFocus();
                                        self.selectingItem = self._moveSelectingItem(self.selectingItem, 0);
                                    }
                                }
                            }
                        } else {
                            if ( self.viewport.options.data == null || self.viewport.options.data.length === 0 ) {
                                //console.log('eventAssign._setTempDropHeight-4: ' + self.options.oriDropHeight);
                                self._setTempDropHeight( self.options.oriDropHeight );
                            }
                            self._moveSelectingItemFocus();
                            if ( self.selectingItem != null ) {
                                self.selectingItem = self._moveSelectingItem(self.selectingItem, 0);
                            }
                        }
                    } else {
                        self.selectingItem = self._moveSelectingItem(self.selectingItem, 1);
                    }
                    break;
                case oKeyMAP.UP:
                    e.preventDefault();
                    e.stopPropagation();
                    if (self.dropdownListFlag ) {

                    } else if ( self.selectingItem == null ) {
                        self._dropdownProcess(false);
                        self.dropdownListFlag = true;
                    } else {
                        self.selectingItem = self._moveSelectingItem(self.selectingItem, -1);
                        if ( self.selectingItem == null ) {
                            self._setNonSelectColor( 0 );
                        }
                    }
                    break;
                case oKeyMAP.TAB:
                    if ( self.selectingItem != null || prevValue === undefined ) {
                        self._reserveBlur = false;
                    }

                    if ( options.multiSelect ) {
                        break;
                    }
                case oKeyMAP.ENTER:
                    var enterEvent = true,
                        autoSelect = true;

                    if ( !self.dropdownListFlag ) {
                        if ( _ib.isInteger( self.selectingItem ) ) {
                            data = self.viewport.options.data[self.selectingItem];
                            options.multiSelect ? self._selectItem(data, data.ele, true, undefined, true) : self._selectItem(data, undefined, undefined, true, true);
                            enterEvent = false;
                            autoSelect = false;
                            self._reserveBlur = false;

                            // TODO 20150428-김의연-# reserveDropHeight 속성 관련 로직 분석 및 이슈 처리
                            // 이슈보고: 기술지원팀, 신명호 대리
                            // 이슈내용: 리스트 필터링시 엔터를 쳐서 값을 선택했을 경우,
                            //   재 편집(재 필터링)시에 리스트영역 높이가 필터링된 아이템 개수에 따라
                            //   알맞게 줄어들지 않는 현상 수정요청
                            // 관련 메소드: dropdownProcess.js#_dropdownProcess
                            self.reserveDropHeight = true;
                        }

                        else if(options.multiSelect) {
                            self._autoSelectForMulti( value );
                            self._outputMainEdit();
                        }
                    }

                    if ( self.prevKeyDownKeyCode == oKeyMAP.ENTER ) {
                        self._reserveBlur = false;
                    } else {
                        if (options.multiSelect === false && keyCode !== oKeyMAP.TAB) {
                            self._dropdownProcess(false, enterEvent, undefined, false, autoSelect);
                            self.dropdownListFlag = true;
                        }
                    }
                    break;
                case oKeyMAP.ESC:
                    if (self.dropdownListFlag === false) {
                        self._dropdownProcess(false, false, undefined,false, false);
                        self.dropdownListFlag = true;
                    }
                    break;
            }
            if (options.useSelectedBox && options.editable) {
                switch(keyCode) {
                    case oKeyMAP.LEFT:
                        selectedItem = self._moveSelectItem(ele, selectedItem, "previous", "last");
                        break;
                    case oKeyMAP.RIGHT:
                        selectedItem = self._moveSelectItem(ele, selectedItem, "next", "first");
                        break;
                    case oKeyMAP.DELETE:
                        if (selectedItem && _ib.isElement(selectedItem.parent()[0]) && (data = selectedItem.data("link"))) {
                            options.multiSelect ? self._selectItem(data, data.ele, true, false) : self._selectItem(data, undefined, undefined, false);
                        }
                        break;
                    case oKeyMAP.BACKSPACE:
                        if (!self.IBCBMainEdit.value() && ele.children().length > 0 && (data = ele.last().data("link"))) {
                            options.multiSelect ? self._selectItem(data, data.ele, true, false) : self._selectItem(data, undefined, undefined, false);
                        }
                        break;
                }
            }

            self.prevKeyDownKeyCode = e.keyCode;
            // 키보드의 키가 눌렸을 때 발생한다.
            self._eventCaller('keydown')(keyCode, e.shiftKey? e.shiftKey : false, e.ctrlKey? e.ctrlKey: false);

            // welcome to madness key event mechanism
            // text validChar 처리
            selection = self._selection();
            if ( self.rText ) {

                if ( IbmcTMP.ExceptKeyCodes.indexOf( e.keyCode ) < 0 )  {
                    self.prevKeyCode = e.keyCode;
                } else {
                    e.keyCode === 8 && keydownChars.push( e.keyCode );
                }

                if ( !keydownFlag ) {
                    prevValue2 = editbox.value();
                    selection2 = selection;

                    keydownFlag = true
                }

                if ( ( e.ctrlKey && e.keyCode === 86 ) || ( e.shiftKey && e.keyCode === 45 ) ) {
                    paste = true;
                } else {
                    maxLength = parseInt( options.maxLength );
                    if ( parseInt( maxLength ) > 0 ) {
                        if ( maxLength <= value.length ) {
                            return;
                        }
                    }

                    if ( IbmcTMP.ExceptKeyCodes.indexOf( keyCode ) < 0 ) {
                        var rExceptValidChar,
                            maxLength;

                        tmpChar = Util.mapKeyPressToActualCharacter( e );
                        // validChar1이 소문자 또는 대문자 구분자 일때 pass
                        if ( self.validChar1 == 1 || self.validChar1 == 2 || self.validChar1 == 3 ) {
                            if ( self.validChar2 ) {
                                if ( self.validChar2 == 1 ) {
                                    rExceptValidChar = /^[a-z0-9]+$/i;
                                } else if ( self.validChar2 == 2 ) {
                                    rExceptValidChar = /^[\sa-z\!\@\#\$\^\&\%\*\(\)\+\=\-\_\[\]\\\/\{\}\|\:\;\<\>\?\,\.\~\`\'\"]+$/i;
                                } else if ( self.validChar2 == 3 ) {
                                    rExceptValidChar = /^[\sa-z0-9\!\@\#\$\^\&\%\*\(\)\+\=\-\_\[\]\\\/\{\}\|\:\;\<\>\?\,\.\~\`\'\"]+$/i;
                                }
                            } else {
                                rExceptValidChar = /^[a-z]+$/i;
                            }

                            if ( rExceptValidChar && rExceptValidChar.test && rExceptValidChar.test( tmpChar ) ) {
                                keydownChars.push( tmpChar );
                            } else {
                                return false;
                            }
                        } else if ( self.validChar1 == 4 ) {
                            if ( self.validChar2 ) {
                                if ( self.validChar2 == 1 ) {
                                    rExceptValidChar = /^[\sa-z\!\@\#\$\^\&\%\*\(\)\+\=\-\_\[\]\\\/\{\}\|\:\;\<\>\?\,\.\~\`\'\"]+$/i;
                                } else if ( self.validChar2 == 2 ) {
                                    rExceptValidChar = /^[a-z0-9]+$/i;
                                } else if ( self.validChar2 == 3 ) {
                                    rExceptValidChar = /^[a-z]+$/i;
                                }
                            } else {
                                rExceptValidChar = /^[\sa-z0-9\!\@\#\$\^\&\%\*\(\)\+\=\-\_\[\]\\\/\{\}\|\:\;\<\>\?\,\.\~\`\'\"]+$/i;
                            }


                            if ( rExceptValidChar && rExceptValidChar.test && rExceptValidChar.test( tmpChar ) ) {
                                return false;
                            } else {
                                keydownChars.push( tmpChar );
                            }
                        } else if ( self.validChar1 == 5 ) {
                            if ( self.validChar2 ) {
                                if ( self.validChar2 == 1 ) {
                                    rExceptValidChar = /^[0-9]+$/i;
                                } else if ( self.validChar2 == 2 ) {
                                    rExceptValidChar = /^[\s0-9\!\@\#\$\^\&\%\*\(\)\+\=\-\_\[\]\\\/\{\}\|\:\;\<\>\?\,\.\~\`\'\"]+$/i;
                                } else if ( self.validChar2 == 3 ) {
                                    rExceptValidChar = /^[\s0-9\!\@\#\$\^\&\%\*\(\)\+\=\-\_\[\]\\\/\{\}\|\:\;\<\>\?\,\.\~\`\'\"]+$/i;
                                }
                            } else {
                                rExceptValidChar = /^[0-9]+$/i;
                            }

                            if ( rExceptValidChar && rExceptValidChar.test && rExceptValidChar.test( tmpChar ) ) {
                                keydownChars.push( tmpChar );
                            } else {
                                return false;
                            }
                        }

                        prevValue = value;
                    } else {
                        if ( self.prevKeyDownKeyCode === 8 ) {
                            return;
                        }
                        if ( self.validChar1 != 4 && e.keyCode === 229 ) {
                            return false;
                        }
                        prevValue = value;
                    }
                }
            } else {
                prevValue = value;
            }
        });

        var caseTimeout,
            smashKeyboardFn;
        editbox.addEvent("keyup", function(e) {
            var value,
                relValue,
                oriValue,
                inputChar,
                data,
                bIndex,
                keyCode,
                pass, isAlpabet,
                tempKeydownChars;

            keydownFlag = false;

            // welcome to madness key eventargsmodeent handler
            relValue = value = _ib.String( oriValue = editbox.value() ).trim();
            // console.log( keydownChars.join(",") );
            if ( self.rText ) {
                tempKeydownChars = _ib.Array( keydownChars );
                tempKeydownChars.unique();

                if ( keydownChars.length > 0 && tempKeydownChars.indexOf( 8 ) > -1 ) {
                    tempKeydownChars.remove( 8 );
                    if ( tempKeydownChars.length() > 0 ) {
                        // 갈기는데 제대로 입력 될리가 있나
                        // 이때 갈기는건 alpabet만 누르는게 아니라 command 키까지 같이 누름
                        if ( self.rText.test && !self.rText.test( inputChar ) ) {
                            isAlpabet = /[a-z]/i.test( inputChar );
                            if ( isAlpabet ) {
                                // validChar1이 대문자 또는 소문자 구분자 일때 문자 전부 대소문자 처리
                                if ( self.validChar1 == 2 ) {
                                    prevValue = prevValue2.toUpperCase();
                                } else if ( self.validChar1 == 3 ) {
                                    prevValue = prevValue2.toLowerCase();
                                }
                            }

                            editbox.value( value = prevValue );
                            self._selection( selection2.begin );
                            invalid = true;
                            prevValue = "";
                        }
                    }

                    keydownChars = [];
                } else {
                    keyCode = IbmcTMP.ExceptKeyCodes.indexOf( e.keyCode ) > -1 ? self.prevKeyCode : e.keyCode;

                    // console.log( IbmcTMP.ExceptKeyCodes.indexOf( keyCode ) < 0, selection2, prevValue, relValue );
                    // text validChar 처리
                    // console.log( keyCode, "11111111111111 keyCode", prevValue !== relValue, value, selection2 );
                    if ( IbmcTMP.ExceptKeyCodes.indexOf( keyCode ) < 0 && selection2 && prevValue !== relValue ) {
                        var invalid;

                        if (paste) {
                            if ( selection2.begin === selection2.end ) {
                                var postStr = prevValue2.substr(0, selection2.begin);
                                var endStr = prevValue2.substr(selection2.begin, prevValue2.length);
                                var tValue = oriValue.replace( new RegExp("^" + postStr), "" ).replace( new RegExp( endStr + "$"), "");

                                inputChar = tValue.charAt(0);
                                for( var i = 0, len = tValue.length; i < len; ++i ) {
                                    keydownChars.push( tValue.charAt( i ) );
                                }
                            } else {
                                var postStr = prevValue2.substr(0, selection2.begin);
                                var endStr = prevValue2.substr(selection2.end, prevValue2.length);
                                var tValue = oriValue.replace( new RegExp("^" + postStr), "" ).replace( new RegExp( endStr + "$"), "");

                                inputChar = tValue.charAt(0);
                                for( var i = 0, len = tValue.length; i < len; ++i ) {
                                    keydownChars.push( tValue.charAt( i ) );
                                }
                            }
                        } else {
                            inputChar = value.substr( selection2.begin, 1 );
                        }

                        // console.log(self.rText.test, inputChar );
                        if ( self.rText.test && !self.rText.test( inputChar ) ) {
                            isAlpabet = /[a-z]/i.test( inputChar );
                            if ( isAlpabet ) {
                                // console.log( prevValue2, inputChar, keydownChars.join(""), selection2, paste );
                                // validChar1이 대문자 또는 소문자 구분자 일때 문자 전부 대소문자 처리
                                if ( self.validChar1 == 2 ) {
                                    if ( selection2.begin !== selection2.end ) {
                                        if ( selection2.end - selection2.begin === 1 ) {
                                            (keydownChars[0]||"").toUpperCase() === (inputChar||"").toUpperCase() && keydownChars.shift();
                                        } else if ( selection2.end - selection2.begin > 1 || paste ) {
                                            (keydownChars[0]||"").toUpperCase() === (inputChar||"").toUpperCase() && keydownChars.shift();
                                        }

                                        prevValue = prevValue2.substr(0, selection2.begin) + inputChar.toUpperCase() + (keydownChars.join("")).toUpperCase() + prevValue2.substr(selection2.end, prevValue2.length);
                                        selection2.begin += 1 + keydownChars.join("").length;
                                    } else {
                                        prevValue = prevValue2.substr(0, selection2.begin) + (keydownChars.join("")).toUpperCase() + prevValue2.substr(selection2.end, prevValue2.length);
                                        selection2.begin += keydownChars.join("").length;
                                    }
                                    // console.log( prevValue2.substr(0, selection2.begin)+", ", (keydownChars.join("")).toUpperCase()+", ", prevValue2.substr(selection2.end, prevValue2.length)+", " );
                                } else if ( self.validChar1 == 3 ) {
                                    // console.log( selection2, inputChar, keydownChars, prevValue2, prevValue );
                                    if ( selection2.begin !== selection2.end ) {
                                        if ( selection2.end - selection2.begin === 1 ) {
                                            (keydownChars[0]||"").toUpperCase() === (inputChar||"").toUpperCase() && keydownChars.shift();
                                        } else if ( selection2.end - selection2.begin > 1 || paste ) {
                                            // console.log((keydownChars[0]||"").toUpperCase(), (inputChar||"").toUpperCase() );
                                            (keydownChars[0]||"").toUpperCase() === (inputChar||"").toUpperCase() && keydownChars.shift();
                                        }

                                        prevValue = prevValue2.substr(0, selection2.begin) + inputChar.toLowerCase() + (keydownChars.join("")).toLowerCase() + prevValue2.substr(selection2.end, prevValue2.length);
                                        selection2.begin += 1 + keydownChars.join("").length;
                                        // console.log(prevValue, selection2);
                                    } else {
                                        prevValue = prevValue2.substr(0, selection2.begin) + (keydownChars.join("")).toLowerCase() + prevValue2.substr(selection2.end, prevValue2.length);
                                        selection2.begin += keydownChars.join("").length;
                                    }
                                } else if (self.validChar1 == 4 || self.validChar1 == 5) {
                                    prevValue = prevValue2;
                                }
                            } else {
                                prevValue = prevValue2;

                                if ( new RegExp( IbmcTMP.RText1[ "4" ].pattern ).test( inputChar ) ) {
                                    prevValue = prevValue2;
                                }
                                // console.log(prevValue, "====================");
                            }
                            // console.log(prevValue);
                            editbox.value( value = prevValue );
                            self._selection( selection2.begin );
                            invalid = true;
                            prevValue = "";
                        }
                    }
                    keydownChars = [];
                }
            }

            paste = false;

            var temp;
            if ( options.multiSelect ) {
                temp = value.split( options.multiSeparator);
                value = temp[ temp.length - 1 ] || "";
            }

            if ( value !== prevValue ) {
                isChanged = true;
            } else {
                isChanged = false;
            }

            isEmpty = !self._hasText(value);
            // console.log("convert");

            // item 문자열 filtering
            if (( IbmcTMP.ExceptKeyCodes.indexOf( e.keyCode ) === -1 || e.keyCode === 8 || e.keyCode === 46 ) ) {
                if ( !options.multiSelect ) {
                    indexTimeout && clearTimeout(indexTimeout);

                    if (options.useAutoComplete && self.isFilteringText( value )) {

                        if (isChanged && !isEmpty) {

                            // indexTimeout = setTimeout(function() { // dropdown list item을 입력시 마다 빠르게 계산 방지
                            indexTimeout = undefined;
                            // keydown시 입력값을 keyup시 입력값과 비교하기 위해 _itemFilter에 전달
                           // self.selectingItem = 0;

                            self._itemFilter(value);
                            self._dropdownProcess(true);
                            self.dropdownListFlag = false;

                            self.IBCBDropDownTBL.children("tr[ibcb-name=" + options.id + "_RowTR]").foreach( function () {
                                self._setNonSelectColor2( _ib( this ) );
                            } );

                            self._moveSelectingItemFocus( undefined, true );
                            self.viewport.scrollTop(0 , true);
                         //   self.selectingItem = self._moveSelectingItem(0, 0);
                            // }, 10);
                        } else if ( isEmpty ) {
                            self._itemFilter(value);

                            self._dropdownProcess(true);
                            self.dropdownListFlag = false;
                            self._moveSelectingItemFocus( true );
                        }
                    } else if ( !options.useAutoComplete && isEmpty ) {
                        self._itemFilter(true);

                        self._dropdownProcess(true);
                        self.dropdownListFlag = false;
                        self._moveSelectingItemFocus( true );
                    }
                }
            }

            if (smashKeyboardFn) {
                smashKeyboardFn();
                smashKeyboardFn = undefined;
            }
        });
        var keyupEditboxText;

        editbox.addEvent( {
            focus: function () {
                self._selection( self.IBCBMainEdit.value().length );
                if ( self.preventFocus != null ) {
                    if ( !self.preventFocus ) {
                        if ( options.focusHighlightColor ) {
                            self.IBCBMainTbl.css("borderColor", options.focusHighlightColor);
                        }
                        self.IBCBMainTbl.addClass("MAINCTL_FOCUS");
                        self._eventCaller('focus')();

                    }
                    self.preventFocus = null;
                } else {
                    if ( options.focusHighlightColor ) {
                        self.IBCBMainTbl.css("borderColor", options.focusHighlightColor);
                    }
                    self.IBCBMainTbl.addClass("MAINCTL_FOCUS");
                    //포커스를 얻을 때 이벤트가 발생한다.
                    !isBlur && self._eventCaller('focus')();
                }
                isBlur = true;
            },
            blur: function ( e ) {
                // validChar 상태 변수 초기화
                keydownFlag = false;
                selection2 = null;

                if ( self.preventBlur != null ) {
                    keydownChars = [];
                    if ( !self.preventBlur ) {
                        self._blurTran();
                    }
                    self.preventBlur = null;
                    isBlur = false;
                } else {
                    // dropdown list를 show, hide 하는 display 동기화
                    if (!btarget) {
                        isBlur = false;
                        // IBCBMainEdit에 blur event

                        self._dropdownProcess(false, true, undefined, true, self._reserveBlur );
                        self.dropdownListFlag = true;

                        // selectedItem 초기화
                        if (selectedItem) {
                            _ib.isElement(selectedItem.parent()[0]) && selectedItem.removeClass("MAINCTL_SELTD_ACTIVE");
                            selectedItem = undefined;
                        }
                        editbox.value( keyupEditboxText );
                    }
                }
                self.injectData && self.injectData.out();
            }
        } );

        // dropdownlist에서 mouseover시 highlight 처리
        list.delegate("tr[ibcb-name=" + id + "_RowTR]","mouseover", function(e) {
            //if ( self.hoverItem !== self._getRowIndex( _ib( e.delegateTarget ) ) ) {
            //    self.hoverItem = self._hoverItem( self.hoverItem, _ib( this ) );
            //}

            if(options.useAutoComplete==true) {
                if (self.hoverItem !== self._getRowIndex2(_ib(e.delegateTarget))) {
                    self.hoverItem = self._hoverItem2(self.hoverItem, _ib(this));
                }

            }else{
                if (self.hoverItem !== self._getRowIndex(_ib(e.delegateTarget))) {
                    self.hoverItem = self._hoverItem(self.hoverItem, _ib(this));
                }
            }


        });
        self.IBCBDropDownTBL.parent().addEvent("mouseleave", function (e) {
            if ( e.delegateTarget === e.target ) {
                if ( self.hoverItem != null ) {
                    self._hoverItem( self.hoverItem );
                    self.hoverItem = null;
                }
            }
        });

        // dropdownlist의 값 선택 및 show/hide 처리
        // 값 선택 처리시 mousedown과 mouseup 한 tr element가 동일할 때에만 값 선택한 것으로 처리한다.
        var dblclickTick = 200, dblclickInterval = 0, prevClick = 0, isdblclick;    // multiSelect시 item 더블 클릭하면 값 선택 되고 dropdown list 사라짐 처리 변수
        var multiSelectFlag = false,                        // multiSelect 사용여부
            dTarget;
        list.delegate("tr[ibcb-name=" + id + "_RowTR],tr[ibcb-name=" + id + "_IBCBDropDownHeaderTBLTR],div[ibcb-name=" + id + "_IBCBDropDown]", "mousedown", function(e) {
            if ( self._isRightClick( e ) ) {
                return;
            }

            if (e.selector === "tr[ibcb-name=" + id + "_RowTR]") {  // dropdown list의 body 부분 mousedown
                dTarget = e.delegateTarget;
            } else {                            // dropdown list의 body를 제외한 부분 mousedown
                dTarget = undefined;

                // ie 전용 scrolling
                e.selector === "div[ibcb-name=" + id + "_IBCBDropDown]" && setTimeout(function() {
                    editbox.focus();
                    btarget = false;
                }, 100);
            }

            !options.multiSelect && (self.dropdownListFlag = false);
            btarget = true;

        });

        list.delegate("tr[ibcb-name=" + id + "_RowTR],tr[ibcb-name=" + id + "_IBCBDropDownHeaderTBLTR],div[ibcb-name=" + id + "_IBCBDropDown]","mouseup", function(e) {
            var isAutoCheck,    // check box 선택 여부
                data,               // 선택한 element의 code, text를 load함
                multiSelect,        // multiSelect 여부
                selectingCount,     // selecting 가능 수
                selectedCount,      // 선택한 item 수
                tempVal,            // editbox 출력용 뱅열
                istDuplicate;       // 선택한 row 여부

            if ( self._isRightClick( e ) ) {
                return;
            }

            // multiSelect에서 item 더블클릭하면 item 선택 후 dropdown list 사라짐
            // ie 구형 브라우저는 기능 포함 안함
            dblclickInterval = (new Date()).getTime() - prevClick;
            if (dblclickInterval <= dblclickTick) {
                dblclickInterval = 0;
                isdblclick = true;
            } else {
                prevClick = (new Date()).getTime();
                isdblclick = false;
            }

            if (dTarget === e.delegateTarget) {
                dTarget = _ib(dTarget);

                isAutoCheck = (e.target.nodeName || "").toLowerCase() === "input" ? false : true;
                data = dTarget.data("cell_data");
                multiSelect = options.multiSelect;
                selectingCount = options.selectingCount || options.rows;
                selectedCount = selectedValue.length();
                tempVal = [];

                if (data) { // text, code 존재하는지 여부
                    self._reserveBlur = false;
                    if (multiSelect) {      // multiselect 사용
                        if (isdblclick) {
                            multiSelectFlag = false;
                            self.dropdownListFlag = true;
                        } else {
                            prevClick = (new Date()).getTime();

                            self._selectItem(data, dTarget, isAutoCheck, undefined, true);

                            // select highlight clear
                            self._setNonSelectColor( self.selectingItem );

                            self.selectingItem = self._getRowIndex( dTarget );

                            // select highlight
                            self._setSelectColor( dTarget );

                            dTarget = self.IBCBMainBtn[0];
                            multiSelectFlag = true;
                        }
                    } else {
                        self.prevKeyDownKeyCode = 13;
                        self._selectItem(data, undefined, undefined, true, true);
                        self._oldUseEditText = data.text;
                        multiSelectFlag = false;
                        self.dropdownListFlag = true;
                    }
                }
            }

            if (btarget) {
                editbox.focus();
                btarget = false;
                !multiSelectFlag && dTarget !== undefined && self.IBCBDRL.hide();
            }
        });
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/eventAssign.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/eventCaller.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._eventCaller = function(name) {
    var self = this,
        opts = self.options,
        id = opts.id,
        global = window,
        eventMap = {
            blur   : global[id + "_OnBlur"]   ? global[id + "_OnBlur"]   : opts.onBlur,
            change : global[id + "_OnChange"] ? global[id + "_OnChange"] : opts.onChange,
            clear  : global[id + "_OnClear"]  ? global[id + "_OnClear"]  : opts.onClear,
            focus  : global[id + "_OnFocus"]  ? global[id + "_OnFocus"]  : opts.onFocus,
            keydown: global[id + "_OnKeyDown"]? global[id + "_OnKeyDown"]: opts.onKeyDown,
            select : global[id + "_OnSelect"] ? global[id + "_OnSelect"] : opts.onSelect,
            checkclick     : global[id + "_OnCheckClick"]      ? global[id + "_OnCheckClick"]      : opts.onCheckClick,
            checkallclick  : global[id + "_OnCheckAllClick"]   ? global[id + "_OnCheckAllClick"]   : opts.onCheckAllClick,
            multicheckerror: global[id + "_OnMultiCheckError"] ? global[id + "_OnMultiCheckError"] : opts.onMultiCheckError

        }, fn, args;

    fn = eventMap[name] || function(){};

    if(IbmcCFG.EventArgsMode) {
        args = [self];
    } else {
        args = [];
    }

    return function() {
        return fn.apply(global, args.concat(_ib.arraySlice.call(arguments, 0)));
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/eventCaller.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getBoolean.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._isRightClick = function ( e ) {
    var rightClick;

    if ( e.originEvent.which ) {
        rightClick = (e.originEvent.which == 3);
    } else if ( e.originEvent.button ) {
        rightClick = (e.originEvent.button == 2);
    }
    return rightClick;
};

MultiComboFn._hasScroll = function() {
    var self = this,
        viewport = self.viewport;

    return viewport.options.data.length * viewport.options.rowHeight > self.options.dropHeight;
};

MultiComboFn.isFilteringText = function (text) {
    for(var i = 0; i < text.length; i++){
        var chr = text.substr(i,1);
        chr = escape(chr);
        if(chr.charAt(1) == "u"){
            chr = chr.substr(2, (chr.length - 1));
            if((chr < "AC00") || (chr > "D7A3"))
                return false;
        }
    }
    return true;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getBoolean.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getData.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._getData = function(type) {
    var self = this,
        options = self.options,
        selectedValue = options.selectedValue,
        viewportData,
        i, val,
        j, jLen,
        data = [];

    // 20150306-김의연-#5108 초기화 이전에 GetSelectCode 호출시 오류 예외처리/1
    if(!self.viewport) {
        return null;
    }

    viewportData = self.viewport.options._data;

    if ( options.useEdit && !options.multiSelect ) {
        val = self.IBCBMainEdit.value();
        if ( type === "text" ) {
            data.push( val );
        } else if ( type === "code" ) {
            self._searchData( "text", val, function ( index, value ) {
                data.push( value.code );
            } );
        } else if ( type === "index" ) {
            self._searchData( "text", val, function ( index, value ) {
                data.push( index );
            } );
        }
    } else {
        if ( type === "index" ) {
            for (i = 0; val = selectedValue.get(i++); ) {
                for (j = 0, jLen = viewportData.length; j < jLen; ++j) {
                    if ( val === viewportData[ j ] ) {
                        data.push( j );
                        break;
                    }
                }
            }
        } else {
            self._searchData( type, val )
            for (i = 0; val = selectedValue.get(i++); ) {
                if (val[type]) {
                    data.push(val[type]);
                }
            }
        }
    }

    return data;
};

MultiComboFn._searchData = function ( propNm, value, fn ) {
    var self,
        viewportData,
        i, len;

    self = this;
    viewportData = self.viewport.options._data;

    for ( i = 0, len = viewportData.length; i < len; ++i ) {
        if ( viewportData[ i ][ propNm ] === value ) {
            fn( i, viewportData[ i ] );
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getData.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getDelegateText.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._getDelegateText = function(data) {
    var self = this,
        options = self.options,
        delegateTextExp = options.delegateTextExp,
        showCol = options.showCol;

    if (delegateTextExp) {
        return delegateTextExp.replace(/(?:\$([0-9]))+/g, function() {
            var index = arguments[1];
            return data["text" + index];
        });
    } else {
        return data["text" + showCol];
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getDelegateText.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getHtml.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._getUserHtml = function () {
    var that,
        userHtml,
        cols,
        col,
        id;

    that = this;
    cols = that.options.cols;
    id = that.options.id;

    userHtml = that._getFixHtml(true);
    for (col = 0; col < cols; col++ ) {
        userHtml += '<td ibcb-name="' + id + '_CellTD' + col + '" class="DRL_TD" valign="middle" '+
        ' style="border-color: {{lineColor}}; ' +
        'background-color: {{colBackColor' + col + '}};' + '" ' +
        'align="{{colAlign' + col + '}}" >' +
        '<div class="DRL_CELL_TEXT" style="font-size: {{fontSize}}px; font-family: {{fontFamily}};color: {{colFontColor' + col + '}}; text-align: {{colAlign' + col + '}}; white-space: inherit;" >{{text' + col + '}}</div>' +
        '</td>';
    }
    userHtml += '</tr>';

    return userHtml;
};

MultiComboFn._getFixHtml = function(justString) {     // 행에 고정된 column인 check, img 의 html string을 반환한다.
    var self = this,
        options = self.options;
    if (justString) {
        return '<tr id="' + options.id + '_RowTR" ibcb-name="' + options.id + '_RowTR" >'+
            '<td ibcb-name="' + options.id + '_CellTDCHK" class="DRL_TD_CK DRL_TD" valign="middle" style="{{multiSelect}};border-color: {{lineColor}};">'+
            '<input type="checkbox" ibcb-name="' + options.id + '_CellCheck" class="DRL_CHECK" onclick="return false" {{checked}} />'+
            '</td>'+
            '<td ibcb-name="' + options.id + '_CellTDIMG" class="DRL_TD_CK DRL_TD" valign="middle" style="{{useImage}};border-color: {{lineColor}};">'+
            '<div ibcb-name="' + options.id + '_CellIMGDIV" style="vertical-align: middle;">'+
            '{{imgUrl}}'+
            '</div>'+
            '</td>';
    } else {
        return _ib.template('<tr id="{{id}}_RowTR" ibcb-name="{{id}}_RowTR" style="height:{{itemHeight}}px;">'+
        '<td ibcb-name="{{id}}_CellTDCHK" class="DRL_TD_CK DRL_TD" valign="middle" style="' + (options.multiSelect ? "": "display: none;") + ';border-color: {{lineColor}};">'+
        '<input type="checkbox" ibcb-name="{{id}}_CellCheck" class="DRL_CHECK" onclick="return false"/>'+
        '</td>'+
        '<td ibcb-name="{{id}}_CellTDIMG" class="DRL_TD_CK DRL_TD" valign="middle" style="' + (options.useImage ? "": "display: none;") + ';border-color: {{lineColor}};">'+
        '<div ibcb-name="{{id}}_CellIMGDIV" style="vertical-align: middle; font-size: {{fontSize}}px; font-family: {{fontFamily}}; color: {{fontColor}};"></div>'+
        '</td>'+
        '</tr>').compile()(this.options);
    }
};

MultiComboFn._getImageEleString = function(imgUrl) {
    var self = this,
        options = self.options;

    return '<img ibcb-name="' + options.id + '_CellIMG" src="' + imgUrl + '" align="absmiddle" width="' + options.fixedimgwidth + '" height="20" />';
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getHtml.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getIndex.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._getRowIndex = function(row) {
    var self = this,
        data = self.viewport.options._data,
        rowData;

    if (!row) {
        return undefined;
    }

    if (_ib.isFunction(row.data)) {
        rowData = row.data("cell_data");
    } else {
        rowData = row;
    }

    for (var i = 0, len = data.length; i < len; ++i) {
        if (data[i] === rowData) {
            return i;
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getIndex.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getIndex2.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._getRowIndex2 = function(row) {
    var self = this, data = self.viewport.options.data, rowData;
    if (!row) {
        return undefined;
    }
    if (_ib.isFunction(row.data)) {
        rowData = row.data("cell_data");
    } else {
        rowData = row;
    }
    for (var i = 0, len = data.length; i < len; ++i) {
        if (data[i] === rowData) {
            return i;
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getIndex2.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getWidth.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// _getStringPixelWidthSingle 에서는 한번 호출 될때마다 dom 생성,수정,삭제가 이루어 지므로 연속된 stringWidth값을 get할때에는
// 작업시간이 오래 걸리게 된다. 그러므로 _getStringPixelWidthMulti에서는 dom 삭제를 호출한 곳에서 할 수 있도록 위임하여
// 작업시간을 줄인다.
MultiComboFn._getStringPixelWidthMulti = function(str) {
    var self = this,
        options = self.options,
        tempDiv,
        size;

    tempDiv = _ib("#ibcb-string-pixel-width");

    if (!tempDiv[0]) {
        tempDiv = _ib('<div id="ibcb-string-pixel-width"></div>').appendTo("body").css({position:"absolute", "float": "left", "white-space":"nowrap","visibility":"hidden"});
        tempDiv.css({"font-family": options.fontFamily, "font-size": options.fontSize});
    }

    tempDiv.text(str);
    size = tempDiv.size();

    return {
        width: size.width,
        height: size.height,
        Destroy: function() {
            tempDiv.remove();
            tempDiv = null;
        }
    };
};

// 스트링의 픽셀의 너비 구하기
MultiComboFn._getStringPixelWidthSingle = function(str) {
    var self = this,
        options = self.options,
        tempDiv = _ib("<div></div>"),
        width;

    tempDiv.text(str);
    tempDiv.css({'position': 'absolute', 'float': 'left', 'white-space': 'nowrap', 'visibility': 'hidden', 'font-family': options.fontFamily, 'font-size': options.fontSize});

    _ib("body").append(tempDiv);

    width = tempDiv.width();

    tempDiv.remove();
    tempDiv = null;
    return width;
};

// 2 ==> 겉에 테이블 보다 좌 우 필셀값 값
MultiComboFn._getTotalWidthCap = function() {
    var self = this,
        options = self.options,
        totalWidthCap;

    totalWidthCap = options.cols + 2;

    options.multiSelect && (++totalWidthCap);
    options.useImage && (++totalWidthCap);

    return (options.totalWidthCap = totalWidthCap);
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/getWidth.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/hasText.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._hasText = function ( text ) {
    var self, rOpts,
        viewportData,
        i, len, data, r;

    self = this;
    // 20150302-김의연-#5091 AutoComplete Ignore UpperCase
    rOpts = self.options.useAutoCompleteIUC ? 'i' : '';
    viewportData = self.viewport.options._data;
    text = text.replace( new RegExp ( IbmcTMP.RText2[2].pattern, "g"), function ($1) { return "\\" + $1; } );
    r = new RegExp( "^" + text + "[\s\S]*", rOpts );

    if ( r && r.test ) {
        for ( i = 0, len = viewportData.length; i < len; ++i ) {
            data = viewportData[ i ];

            if (  r.test( data.text ) && text !== "" ) {
                return true;
            }
        }
    }

    return false;
};

MultiComboFn._hasText2 = function ( text ) {
    var self,
        options,
        viewportData,
        i, len,
        data,
        r,
        result,
        exp;

    self = this;
    options = self.options;
    viewportData = self.viewport.options._data;
    exp = text.replace( new RegExp ( IbmcTMP.RText2[2].pattern, "g"), function ($1) { return "\\" + $1; } );
    r = new RegExp( "^" + exp + "[\s\S]*" );
    result = -1;

    for ( i = 0, len = viewportData.length; i < len; ++i ) {
        data = viewportData[ i ];

        if ( r && r.test && r.test( data.text ) && text !== "" ) {
            result = 0;
        }

        if ( text === data.text ) {
            result = 1;
            break;
        }
    }

    return result;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/hasText.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/hoverItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._hoverItem = function ( prevHoverIndex, hoverItem ) {
    var self = this,
        opts = self.options, i;

    if ( prevHoverIndex != null ) {
        if ( prevHoverIndex === self.selectingItem && self.viewport.options.data[ self.selectingItem ] && self.viewport.options.data[ self.selectingItem ].ele ) {
            self._setSelectColor( self.viewport.options.data[ self.selectingItem ].ele );
        } else {
            self._setNonSelectColor( prevHoverIndex );
        }
    }

    if ( hoverItem ) {
        i = 0 - opts.fixCols;

        hoverItem.children().foreach(function() {
            var ele = _ib(this);

            ele.css({backgroundColor: opts.hoverColor || opts.nonSelectColor });
            ele.find(".DRL_CELL_TEXT").css({color: opts.hoverFontColor || opts.nonSelectColor });

            i++;
        });
    }

    return self._getRowIndex( hoverItem );
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/hoverItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/hoverItem2.js
/**
 * Created by Euiyeon on 2015-03-19.
 */


MultiComboFn._hoverItem2 = function(prevHoverIndex, hoverItem) {
    var self = this, opts = self.options, i;
    if (prevHoverIndex != null) {
        if (prevHoverIndex === self.selectingItem && self.viewport.options.data[self.selectingItem] && self.viewport.options.data[self.selectingItem].ele) {
            self._setSelectColor(self.viewport.options.data[self.selectingItem].ele);
        } else {

            self._setNonSelectColor(prevHoverIndex);


        }
    }
    if (hoverItem) {
        hoverItem.children().css({  backgroundColor: opts.hoverColor || opts.nonSelectColor})
    }
    return self._getRowIndex2(hoverItem);
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/hoverItem2.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/initMultiComboStyle.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// multicombo 객체에 적용되는 style은 class를 사용해서 각 element에 style을 부여하는 방법이 아니라
// 직접 element에 적용될 style을 선언 하도록 되어 있다. 그런데 css에 따라 각 element에 style을 부여하도록 하기 위해(Theme기능 제공 요청)
// 현재 multicombo가 기존에 제공했던 기능을 유지한 체로 처리하려면 css rule이 실제로 적용되어야 할 multicombo를 구성하는 element가 아닌 다른 element에
// style을 적용하고 이것을 실제로 적용 되어야할 element에 반영하는 식으로 구현되어야 한다. 이것을 처리하기 위해 __initMultiComboStyle이 존재한다.
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.__initMultiComboStyle = function() {
    var self = this,
        opts = self.options,
        aMainTableStyles,
        sTitleColor,
        aDDListStyles,
        sDDListBorderColor,
        oFontStyles,
        oSelectedColor,
        oHoverStyles,
        i, len;

    aMainTableStyles = self.IBCBMainTbl.css('backgroundColor,borderColor');

    // multicombo의 배경색
    opts.backColor = aMainTableStyles.backgroundColor;

    // multicombo의 바깥선 색
    opts.outLineColor = aMainTableStyles.borderColor;

    // dropdown list의 각 열의 색
    self.IBCBDropDownHeadTBL.children().last().addClass('DRL_TD');
    aDDListStyles = self.IBCBDropDownHeadTBL.find('.DRL_TD').css('backgroundColor,borderColor,fontFamily,color');

    for(i = 0, len = opts.ColBackColor.length; i < len; ++i) {
        self.SetColBackColor( i, aDDListStyles.backgroundColor );
    }

    // dropdown list의 item이 선택 되지 않았을때 색
    opts.nonSelectColor = aDDListStyles.backgroundColor;

    // dropdown list의 안쪽 선색
    self.SetLineColor( aDDListStyles.borderColor );
    // options.lineColor = dropdownStyles.borderColor;

    // dropdown list의 폰트 종류
    opts.fontFamily = aDDListStyles.fontFamily;

    // dropdown list의 각 열이 사용할 글자색
    for(i = 0, len = opts.ColFontColor.length; i < len; ++i) {
        opts.ColFontColor[ i ] = aDDListStyles.color;
    }

    // dropdown list의 전체 글자색
    opts.fontColor = aDDListStyles.color;
    self.IBCBDropDownHeadTBL.children().last().removeClass('DRL_TD');

    sDDListBorderColor = self.IBCBDropDownBodyScroll.css('borderColor');
    // dropdown list의 바깥쪽 선색
    opts.dropDownOutLineColor = sDDListBorderColor;

    oFontStyles = self.IBCBMainEdit.css('fontWeight');
    // 텍스트 input element의 weight
    opts.editFontBold = oFontStyles.fontWeight;

    oSelectedColor = self.IBCBDropDownHeadTBL.find('.DRL_SELECTED_ITEM').css('color,backgroundColor');
    // 선택된 아이템의 배경색
    opts.selectColor = oSelectedColor.backgroundColor;
    // 선택된 아이템의 글자색
    opts.selectFontColor = oSelectedColor.color;

    oHoverStyles = self.IBCBDropDownHeadTBL.find('.DRL_HOVER_ITEM').css('color,backgroundColor');
    // hover 아이템의 배경색
    opts.hoverColor = oHoverStyles.backgroundColor;
    // hover 아이템의 글자색
    opts.hoverFontColor = oHoverStyles.color;

    // title의 배경색
    opts.titleColor = self.IBCBDropDownHead.css('backgroundColor');

    sTitleColor = self.IBCBDropDownHeadTBL.find('.DRL_HEADER_DIV_FONT').css('color,fontFamily');
    // title의 글자색
    opts.headFontColor = sTitleColor.color;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/initMultiComboStyle.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/insertItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// json, xml 등 연속된 데이터 item insert
MultiComboFn._insertItem = function(data, isXml, begin) {
    var self = this,
        items,
        code, text;

    if (!_ib.isInteger( begin ) || begin === -1) {
        begin = self.options.rows;
    }

    if (isXml) {
        if ((items = data.children().children().children()).length) {
            items.foreach(function (index) {
                var target = _ib(this);

                self.InsertItem(begin + index, target.text() || "", target.attribute("code") || target.attribute("Code") || target.attribute("CODE") || "")
            });
        }
    } else {
        if (items = data.data || data.Data || data.DATA) {
            for(var i = 0, item; item = items[i++]; ) {
                code = item.code || item.Code || item.CODE || "";
                text = item.text || item.Text || item.TEXT || "";

                self.InsertItem(begin + i - 1, text+"", code+"");
            }
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/insertItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/itemFilter.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._itemFilter = function(value) {
    var self = this,
        editBox = self.IBCBMainEdit,
        ele,
        isFirst = true,
        filteringItem,
        viewportData = self.viewport.options.data,
        data,
        filteringListHeight;


    value = value != null ? value : _ib.String( editBox.value() ).trim();

    self.injectData && self.injectData.out();

    self.IBCBDropDownTBL.hide();

    if (value === true) {
        self.viewport.refresh();

        if ( self.viewport.options.data == null || self.viewport.options.data.length === 0 ) {
            //console.log('_itemFilter._setTempDropHeight: ' + self.options.oriDropHeight);
            self._setTempDropHeight( self.options.oriDropHeight );
        }
    } else {

        self.injectData = self.viewport.injectData( self._setDropHeight( value ) );
    }

    self.viewport._setCanvasHeight();
    self.IBCBDropDownTBL.show();

    return value;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/itemFilter.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/itemSelect.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._itemSelect = function (nIdx, bFlag, type, proc, isEvent, outputMainEdit) {
    var self = this,
        options = self.options,
        //id = options.id,
        //selectedValue = options.selectedValue,
        //eles, loop,
        ele, data,
        oldIndex, oldText, oldCode,
        newIndex, newText, newCode,
        indexs, i, j, len,
        inValData,
        viewportData = self.viewport.options.data;

    //console.log('_itemSelect', nIdx, bFlag);

    // event callback 발생 여부
    isEvent = _ib.isUndefined(isEvent) ? true : isEvent;

    self.reserveRefresh = true;

    // 선택된 아이템이 없도록 설정
    // v59 에서 code ""도 선택가능하게 해달라고 해서 수정했지만
    // SetSelectIndex SetSelectCode SetSelectText와 동작 맞추기 위해 "" 일경우 아이템 해제 되도록 다시 변경
    if(nIdx === -1 || nIdx === "") {
        nIdx = false;
    }

    if (_ib.isBoolean(nIdx)) {      // item 전체 선택 / 해제
        bFlag = nIdx;
        for (i = 0, len = viewportData.length; i < len; i++) {
            self._itemSelect(i, bFlag, undefined, undefined, isEvent, outputMainEdit);
        }
    } else if (type === "index" || _ib.isInteger(nIdx)) {       // index
        oldIndex = self.GetSelectIndex();
        oldText = self.GetSelectText();
        oldCode = self.GetSelectCode();

        indexs = (nIdx + "").split(self.options.multiSeparator);
        inValData = [];

        if (_ib.isInteger( bFlag )) {
            bFlag = (bFlag === 1) ? true : !(bFlag === 0);
        }

        for (i = 0; nIdx = indexs[i++];) {
            if (data = viewportData[nIdx]) {

                isEvent && (self.selectingItem = parseInt(nIdx));  // highlight 되는 item

                if (proc) {
                    return proc(data);
                } else {
                    self._selectItem(data, data.ele, true, bFlag , isEvent, false);
                }
            } else {
                inValData.push(nIdx);
            }
        }

        newIndex = self.GetSelectIndex();
        newText = self.GetSelectText();
        newCode = self.GetSelectCode();

        if (isEvent && options.multiSelect && inValData.length > 0 && indexs.length > 0) {
            self._eventCaller('multicheckerror')(inValData.join(self.options.fixMultiSeparator));
        }

        if (isEvent && oldIndex !== newIndex) {
        //    self._eventCaller('change')(oldIndex, oldText, oldCode, newIndex, newText, newCode);  2015.10.02  checkAllClick 이벤트 보다 change / select 이벤트가 더 빨리 발생하지 않도록 하기.
            setTimeout(function() {
                // self._eventCaller("change")(oldIndex, oldText, oldCode, newIndex, newText, newCode); //2015.10.20 전체클릭시 이벤트 옵션처리
                if( self.options.AllowEvent4Flag==true ) self._eventCaller("change")(oldIndex, oldText, oldCode, newIndex, newText, newCode);}, 1); //20151023
        }
    } else if (_ib.isString(nIdx)) {    // code / text
        oldIndex = self.GetSelectIndex();
        oldText = self.GetSelectText();
        oldCode = self.GetSelectCode();

        indexs = (nIdx + "").split(self.options.multiSeparator);
        //inValData = [];

        for (i = 0, len = viewportData.length; i < len; i++) {
            data = viewportData[i];
            for (j = 0; j < indexs.length; j++) {
                nIdx = indexs[j];
                if (data[type || "code"] === nIdx) {
                    if (proc) {
                        return proc(data);
                    } else {
                        indexs.splice(j, 1);
                        j--;
                        self._selectItem(data, data.ele, true, bFlag, isEvent, false, outputMainEdit);
                        break;
                    }
                }
            }

            if (indexs.length === 0) {
                break;
            }
        }

        newIndex = self.GetSelectIndex();
        newText = self.GetSelectText();
        newCode = self.GetSelectCode();

        if (isEvent && options.multiSelect && indexs.length > 0 ) {
            self._eventCaller('multicheckerror')(indexs.join(self.options.fixMultiSeparator));
        }

        if (isEvent && oldIndex !== newIndex) {
            self._eventCaller('change')(oldIndex, oldText, oldCode, newIndex, newText, newCode);
        }
    } else if (_ib.isObject(nIdx)) {
        // _insertItems 에서 library wrapping 된 element 를 전달할때 처리함.
        ele = nIdx;

        self._selectItem(ele.data("cell_data"), ele, true, bFlag, true, isEvent);
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/itemSelect.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/openDropdown.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._openDropdown = function(list, absLeft, absTop, isScroll, dropWidth) {
    var self = this,
        options = self.options,
        id = options.id,
        IBCBDropDownHead = self.IBCBDropDownHead,
        isTitleVisible = options.titleVisible,
        isMultiSelect = options.multiSelect,
        isUseImage = options.useImage,
        chkWidth = 0, imgWidth = 0, scrollWidth = 0,        // drl (dropdown list의 width 보정 값)
        tempScrollbarTd,
        eles,
        controlWidth,
        mainDRLWidth;

    // browser 마다 틀리게 출력되는 dropdown list의 width를 맞추기 위해 check box 출력 여부를 확인한다.
    if (isMultiSelect) {
        chkWidth = 20;
    }

    // browser 마다 틀리게 출력되는 dropdown list의 width를 맞추기 위해 image box 출력 여부를 확인한다.
    if (isUseImage) {
        imgWidth = 21;
    }

    // scrollbar show/ hide;
    if (isScroll && !self.myScroll) {
        self.IBCBDropDownHeadScroll.css({marginRight: self.options.scrollMarginRight});

        // ie6에서 scroll 발생시 dropdown list의 body cell 영역이 header와 async 되는 width 문제
        scrollWidth = self.options.scrollMarginRight - 1;
    } else {
        self.IBCBDropDownHeadScroll.css({marginRight: 0})
        self.myScroll && (scrollWidth = 5);
    }

    if (isTitleVisible) {
        IBCBDropDownHead.show();
    } else {
        IBCBDropDownHead.hide();
    }

    // dropdown list의 width값이 사용자에게 text 입력을 받는 input box control 보다 작다면
    // input box control과 같은 width 값으로 설정함.
    mainDRLWidth = self.IBCBMainDiv.width() - 2;    // IBCBMainDRL의 border값 빼기
    controlWidth = dropWidth + chkWidth + imgWidth + scrollWidth + (IbmcTMP.isIE67 ? -1 : 0);

    var IBCBDropDownHeadTBL = self.IBCBDropDownHeadTBL.children(0);
    var IBCBDropDownHeaderTBLTR = self.IBCBDropDownHeaderTBLTR;


    IBCBDropDownHeaderTBLTR.children(0).css({width: chkWidth});
    IBCBDropDownHeadTBL.children(0).css({width: chkWidth+1});
    IBCBDropDownHeaderTBLTR.children(1).css({width: imgWidth});
    IBCBDropDownHeadTBL.children(1).css({width: imgWidth+1});

    var tempMaxColWidth = [];
    for (var i = 0, len = options.maxColWidth.length; i < len; i++) {
        tempMaxColWidth[i] = options.maxColWidth[i];
    }

    // dropWidth가 control 너비보다 작을때
    if (!options.isCalledSetColWidth && mainDRLWidth > controlWidth ) {
        var compare = mainDRLWidth - controlWidth + 2;
        controlWidth += compare + (IbmcTMP.isIE67 && !isScroll ? -1 : 0);
        tempMaxColWidth[0] += compare;
    }

    for (var i = 0, len = tempMaxColWidth.length; i < len; i++) {
        IBCBDropDownHeaderTBLTR.children(options.fixCols + i).css({width: tempMaxColWidth[i]});
        IBCBDropDownHeadTBL.children(options.fixCols + i).css({width: tempMaxColWidth[i] + (IbmcTMP.isIE67 ? 2 : 1)});
    }

    self.IBCBDRL.css("width",controlWidth);
    self.viewport.setSize({width: controlWidth});
    IbmcTMP.isIE67 && isScroll && self.IBCBDropDownTBL.parent().css({display:"block", width:dropWidth + chkWidth + imgWidth-1 });
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/openDropdown.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/options.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// license 및 선언된 multicombo control을 저장함.
MultiComboFn.options = {
    //gIBCAL: -1,
    //gCBIds: [],
    //VERSION: "<%=VERSION%>",
    NAME: "multicombo"
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/options.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/outputMainEdit.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// options.selectedValue에 할당된 값 IBCBMainEdit element에 출력함.
MultiComboFn._outputMainEdit = function(isRemoveProc, oldData, newData, isSelect) {
    var self = this,
        options = self.options,
        editbox = self.IBCBMainEdit,
        selectedValue = options.selectedValue,
        tempVal = [],tempCode = [], temp,
        i, val, len,
        ele,
        viewElePosition, viewEleWidth;

    if ( options.batchOutput === true ) {
        temp = [];

        for ( i = 0, len = self.viewport.options.data.length; i < len; ++i ) {
            if ( self.viewport.options.data[ i ].checked === "checked" ) {
                temp.push( self.viewport.options.data[ i ] );
            }
        }

        for (i = 0, len = temp.length; i < len; ++i ) {
            tempCode.push( temp[ i ].code );
            tempVal.push( temp[ i ].text );
        }
    } else {
        for (i = 0 ; val = selectedValue.get( i++ ); ) {
            tempCode.push( val.code );
            tempVal.push( val.text );
        }
    }

    if (options.useSelectCount && options.multiSelect) {    // 건수 표기 사용
        editbox.value(options.allCountKor + tempVal.length + options.NumberKor);
    } else if (options.useSelectedBox && isRemoveProc !== undefined) {
        tempVal.length ? self.IBCBMainSelectedContainer.show() : self.IBCBMainSelectedContainer.hide();

        // selected item delete / insert
        if (isRemoveProc && oldData && !_ib.isEmptyObject(oldData)) {    // 삭제
            if (ele = oldData.viewEle) {
                viewElePosition = ele.position();
                viewEleWidth = ele.outerWidth();
                ele.remove();
            }
        }

        // single select or item delete 가 아니면 item 추가.
        if (isSelect || (!isRemoveProc && newData)) {
            isRemoveProc = false;
            newData.viewEle = _ib('<div class="MAINCTL_SELTD_ITEM"><span>' + newData.text + '</span><span class="MAINCTL_SELTD_ITEM_CANCEL" style="background-image:url( ' + IbmcCFG.AssetPath + 'Main/cross.png)">cancel</span></div>').appendTo(self.IBCBMainSelectedList[0]);
            newData.viewEle.data("link", newData);

            viewElePosition = newData.viewEle.position();
            viewEleWidth = newData.viewEle.outerWidth();
        }

        self._setSelectedItemPosition(isRemoveProc, viewElePosition, viewEleWidth);
    } else if (!options.useSelectedBox) {
        editbox.value(tempVal.length === 1? tempVal[0]: tempVal.join(options.multiSeparator));
    }

    // placeHolder4CheckAll 지정시 전체선택시에만 placeHolder 텍스트 보여줌
    if (options.placeHolder4CheckAll!=""){
        if(tempVal.length>0 && self.viewport.options.data.length===tempVal.length){
            editbox.value(options.placeHolder4CheckAll);
        }
    }
    if(options.Skip4CheckAll==true &&  self.IBCBHeaderChkBtn[0].checked==true  ){
        editbox.value(options.placeHolder4CheckAll);
    }


    // 선택한 값의 code값을 control 생성시 입력한 element인 input element value에 출력함.
    self.element.value( self.GetSelectCode() );
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/outputMainEdit.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectColor.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._setSelectColor = function(elem) {
    var self = this,
        opts = self.options,
        SELECTED_BACK_COLOR = opts.selectColor,
        SELECTED_FONT_COLOR = opts.selectFontColor;

    //console.log('_setSelectColor');

    if(elem && elem.children()) {
        elem.children().css({backgroundColor: SELECTED_BACK_COLOR});
        elem.find(".DRL_CELL_TEXT").css({color: SELECTED_FONT_COLOR});
    }

};

MultiComboFn._setNonSelectColor = function ( nIdx ) {
    var self = this,
        opts = self.options,
        curEle, viewport, i;

    viewport = self.viewport;

    if (_ib.isInteger(nIdx) && viewport.options.data[nIdx] && (curEle = viewport.options.data[nIdx].ele) ) {
        i = 0 - opts.fixCols;

        curEle.children().foreach(function() {
            var ele = _ib(this);
            //console.log('_setNonSelectColor', i);
            ele.css({backgroundColor: opts.ColBackColor[i] || opts.nonSelectColor});
            ele.find(".DRL_CELL_TEXT").css({color: opts.ColFontColor[i] || opts.nonSelectColor});
            i += 1;
        });
    }
};

MultiComboFn._setNonSelectColor2 = function ( ele ) {
    var self = this,
        opts = self.options,
        i = 0 - opts.fixCols;

    ele.children().foreach(function() {
        var ele = _ib(this);

        ele.css({backgroundColor: opts.ColBackColor[i] || opts.nonSelectColor});
        ele.find(".DRL_CELL_TEXT").css({color: opts.ColFontColor[i] || opts.nonSelectColor});

        i++;
    });
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectColor.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selection.js
/**
 * Created by Euiyeon on 2015-03-19.
 */


MultiComboFn._selection = function(begin, end, target) {
    var ele = target || this.IBCBMainEdit[0],
        selection,
        temp;
    if (_ib.isInteger(begin)) {  // set
        _ib.isUndefined(end) && (end = begin);
        if ("setSelectionRange" in ele) {
            ele.setSelectionRange(begin, end);
        } else {
            selection = ele.createTextRange();
            selection.collapse();
            selection.moveStart("character", begin);
            selection.moveEnd("character", (end - begin));

            selection.select();
        }
    } else {        // get
        if ("setSelectionRange" in ele) {
            begin = ele.selectionStart;
            end = ele.selectionEnd;
        } else if (document.selection && document.selection.createRange) {
            selection = document.selection.createRange();

            begin = 0 - selection.duplicate().moveStart( "character", -100000 );
            end = begin + selection.text.length;
        }

        return {
            begin: begin,
            end: end
        };
    }
};

MultiComboFn._selectionClear = function ( nIdx ) {
    var self = this;
    console.log('_selectionClear', nIdx);
    self.viewport.render();
    self._setNonSelectColor( nIdx );
    self.selectingItem = undefined;
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selection.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// data: 선택한 data
// target: 선택한 element
// isAutoCheck: checkbox element에 자동 체크
// isSelect: item 선택 또는 선택 해제
// isEvent: 이벤트 발생하여 호출되었는지 여부
MultiComboFn._selectItem = function (oData, eTarget, isAutoCheck, isSelect, isEvent, hasChangeCallback, outputMainEdit) {
    var self = this,
        opts = self.options,
    //id = options.id,
        bMultiSelect = opts.multiSelect,
        sSelectedValue = opts.selectedValue,
        nSelectingCnt = opts.selectingCount || opts.rows,
        nSelectedValCnt = sSelectedValue.length(),
    // selectedValue 값 삭제 수행 하였는지 여부
        isRemoveProc = false,
        oldData = {},
        nOldIndx = self.GetSelectIndex(),
        sOldText = self.GetSelectText(),
        nOldCode = self.GetSelectCode(),
        useEditOldData = self.options.selectedValue.array[0],
        nNewIndx, sNewText, nNewCode,
        isDuplicate, nRowIndex,
        i, j, val, jLen;

    //================================================================================
    // useEdit==true 시 단일항목 OldIndex 를 얻기 위해서 사용 AM2015-0623
    //================================================================================
    var nOldIndx_UseEditTrue = -1;
    viewportData = self.viewport.options._data;
    for (i = 0; val = sSelectedValue.get(i++);) {
        for (j = 0, jLen = viewportData.length; j < jLen; ++j) {
            if (val === viewportData[j]) {
                nOldIndx_UseEditTrue = j;
                break;
            }
        }
    }

    if (oData != null) {
        nRowIndex = self._getRowIndex(oData);
    } else {
        return;
    }

    // 아이템이 선택되었을 때 이벤트가 발생한다.
    // OnChange 이벤트와 달리 OnSelect 이벤트는 같은 값을 선택하여도 이벤트가 발생한다.
    if (!opts.traditional && isEvent) {
        setTimeout(function() {
         //   self._eventCaller('select')(nRowIndex, oData.text, oData.code);
            if( self.options.AllowEvent4Flag==true ) self._eventCaller("select")(nRowIndex, oData.text, oData.code);
        },1);
    }

    if (bMultiSelect) {
        isDuplicate = (sSelectedValue.indexOf(oData) === -1);
        if (isDuplicate || isSelect) {
            if (nSelectedValCnt >= nSelectingCnt) {
                return false;
            }

            if (isDuplicate && isSelect !== false) {
                oData.checked = "checked";
                sSelectedValue.push(oData);
                eTarget && eTarget.children(0).children().property("checked", true);
            }
        } else {
            //console.log('_selectItem.deselect', data.index, data);
           //self._setSelectColor(oData.ele, true); // 20151026 전체선택 해제시 색상변화

            isRemoveProc = true;
            oData.checked = "";
            oldData = sSelectedValue.remove(oData)[0];
            eTarget && eTarget.children(0).children().property("checked", false);
        }

        //전체 선택 Btn check 여부
        self.IBCBHeaderChkBtn[0].checked = (sSelectedValue.length() === self.viewport.options.data.length);
        if (outputMainEdit !== false) {
            self._outputMainEdit(isRemoveProc, oldData, oData, isSelect);
        }


    } else {
        isDuplicate = (sSelectedValue.indexOf(oData) === -1);
        if (isDuplicate || isSelect) {
            isRemoveProc = true;
            oldData = sSelectedValue.shift() || {};

            if (oldData) {
                oldData.checked = '';
            }

            if (isSelect !== false) {
                oData.checked = "checked";
                sSelectedValue.push(oData);
            }
        } else {
            isRemoveProc = true;
            oData.checked = "";
            oldData = sSelectedValue.remove(oData)[0];
        }

        if (outputMainEdit !== false) {
            self._outputMainEdit(isRemoveProc, oldData, oData, isSelect);
        }
    }

    nNewIndx = self.GetSelectIndex();
    sNewText = self.GetSelectText();
    nNewCode = self.GetSelectCode();

    // 아이템이 선택되었을 때 이벤트가 발생한다. OnChange 이벤트와 달리 OnSelect 이벤트는 같은 값을 선택하여도 이벤트가 발생한다.
    if (opts.traditional && isEvent) {
        setTimeout(function() {
           //   self._eventCaller("select")(nRowIndex, oData.text, oData.code); //2015.10.20 전체클릭시 이벤트 옵션처리
            if( self.options.AllowEvent4Flag==true ) self._eventCaller("select")(nRowIndex, oData.text, oData.code); }, 1); //20151023
    }

    if (isEvent && bMultiSelect && nOldIndx !== nNewIndx) {
       // self._eventCaller("checkclick")(nRowIndex, oData.code, self.viewport.options.data[nRowIndex].checked === "checked"); //2015.10.20 전체클릭시 이벤트 옵션처리
        if( self.options.AllowEvent4Flag==true )  self._eventCaller("checkclick")(nRowIndex, oData.code, self.viewport.options.data[nRowIndex].checked === "checked");//20151023

    }

    // 선택된 Item이 변경되었을 때 이벤트가 발생한다. 기존에 선택된 Item을 다시 선택했을때는 이벤트가 발생하지 않는다
    if (isEvent && hasChangeCallback !== false) {
        if (self.options.useEdit) {



            //================================================================================
            // AM 2015-0626 useEdit==True 시 배열값 넘어오는 현상의 패치
            //================================================================================
            if (!opts.multiSelect) { //multiSelect=T 일때에는 배열로 여전히 나와야 됨.

                sOldText = useEditOldData ? useEditOldData.text : "";
                sOldText = self._oldUseEditText == null ? sOldText : self._oldUseEditText;

                nOldIndx = self.FindItem(sOldText, opts.showCol, true) + "";
                nOldCode = self.FindItem(sOldText, opts.showCol, true);
                nOldCode < 0 && (nOldCode = "");
                nOldCode += "";

                viewportData = self.viewport.options._data;
                for (i = 0; val = sSelectedValue.get(i++);) {
                    for (j = 0, jLen = viewportData.length; j < jLen; ++j) {
                        if (val === viewportData[j]) {
                            nNewIndx = j;
                            break;
                        }
                    }
                }
                nOldIndx = nOldIndx_UseEditTrue;
                nOldCode = this.GetIndexCode(nOldIndx);
                nNewCode = this.GetIndexCode(nNewIndx);
            }

            setTimeout(function() {
                self._eventCaller('change')(nOldIndx, sOldText, nOldCode, nNewIndx, sNewText, nNewCode);
            },1);
        } else if (nOldIndx !== nNewIndx) {
            setTimeout(function() {
                self._eventCaller('change')(nOldIndx, sOldText, nOldCode, nNewIndx, sNewText, nNewCode);
            },1);
        }
    }

    // ie8에서 dropdown list를 show/hide시 이전 상태의 scroll 값이 사라짐
    //20151023 하위값 선택 후 스크롤 올리면 공백 생기므로 주석처리함
    //if (_ib.Browser.name === "msie" && _ib.Browser.version == 8) {
    //    self.viewport.scrollTopValue = self.viewport.scrollTop();
    //}

};




//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectMove.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// active item 이동
MultiComboFn._moveSelectItem = function(list, selectedItem, siblingType, firstEle) {
    var self = this, siblingEle;

    if (list.children().length > 0) {
        if (selectedItem && !_ib.isElement(selectedItem.parent()[0])) {
            selectedItem = undefined;
        }

        if (selectedItem) {
            siblingEle = selectedItem[siblingType]();
            if (siblingEle[0]) {
                selectedItem.removeClass("MAINCTL_SELTD_ACTIVE");
                selectedItem = siblingEle;
                selectedItem.addClass("MAINCTL_SELTD_ACTIVE");
            }

        } else {
            selectedItem = list[firstEle]();
            selectedItem.addClass("MAINCTL_SELTD_ACTIVE");
        }
        self._setSelectedItemPosition(false, selectedItem.position(), selectedItem.outerWidth());
    }

    return selectedItem;
};

MultiComboFn._moveSelectingItemFocus = function( none, preventSelectingHighlight ) {
    var self,
        options,
        selectingData;

    self = this;
    options = self.options;

    if ( none ) {
        // ie8에서 dropdown list를 show/hide시 이전 상태의 scroll 값이 사라짐
        if ( _ib.Browser.name === "msie" && _ib.Browser.version == 8 ) {
            self.viewport.scrollTopValue = 0;
        }
        self.viewport.scrollTop(0 , true);
        self._selectionClear( self.selectingItem || 0 );
    } else {
        if ( options.selectedValue.length() > 0 ) {
            selectingData = options.selectedValue.get(options.selectedValue.length() - 1);

            // 이전 선택한 item으로 dropdown list의 scroll top 이동
            if ( preventSelectingHighlight !== true ) {
                self.selectingItem = self._getRowIndex(selectingData);

                self.viewport.scrollTop( self.selectingItem * self.viewport.getRowHeight(), true);
            }

        } else {
            self.viewport.scrollTop(0 , true);
        }

        self.viewport.refresh();
    }
};

MultiComboFn._moveSelectingItem = function(index, next, preventSelectingPosition, preventSelectingHighlight) {
    var self = this,
        options = self.options,
        viewport = self.viewport,
        viewportEle = viewport.options.viewport,
        viewportData = viewport.options.data,
        nextIndex, nextEle;

    if (_ib.isInteger(next)) {
        nextIndex = _ib.isInteger(index) ? index + next : 0;

        if (nextIndex < 0) {
            self._dropdownProcess(false);
            self.dropdownListFlag = true;
            return;
        } else if (nextIndex >= viewportData.length) {
            return index;
        }

        viewport.render();
    } else {
        nextEle = next;
        nextIndex = self._getRowIndex(next);
    }

    if (_ib.isInteger(nextIndex)) {
        if (nextEle = viewport.options.data[nextIndex].ele ) {
            if (!preventSelectingPosition) {
                self._setSelectingItemPosition(self.IBCBDropDownBodyScroll, nextEle);
            }

            if (nextEle.parent().length === 0) {
                if (_ib.isInteger(self.selectingItem) && self.dropdownListFlag === false) {
                    self.viewport.scrollTop(parseInt((self.selectingItem - (self.viewport.options.bufferLength / 4) + 1) * self.viewport.options.rowHeight) , true);
                    self.viewport.render();
                    self._moveSelectingItem(index, next, preventSelectingPosition, preventSelectingHighlight);
                    return index;
                }
            }

            self._setNonSelectColor( index );

            if ( index != null ) {
                if (!preventSelectingHighlight) {
                    self._setSelectColor( nextEle );
                }
                return nextIndex;
            } else if ( nextIndex == 0 ) {
                self._setSelectColor( nextEle );
                return nextIndex;
            }
        }

    } else {
        return index;
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectMove.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectPosition.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// selected item을 담은 list element에 left값 조정 하여 사용자에게 선택된 item에 focus를 주는 느낌을 설정함.
MultiComboFn._setSelectedItemPosition = function(isRemoveProc, viewElePosition, viewEleWidth) {
    var self = this,
        options = self.options,
        editWidth = options.editWidth,
        textEditWidth = options.textEditWidth,
        selectedBoxEditWidth, totalSelectedBoxEditWidth = 0,
        left;

    // selected container width update
    self.IBCBMainSelectedList.children().foreach(function() {
        totalSelectedBoxEditWidth += _ib(this).outerWidth();     // selectedBox item 들의 총 width
    });

    if (totalSelectedBoxEditWidth + textEditWidth > editWidth) {
        selectedBoxEditWidth = editWidth - textEditWidth;
    } else {
        selectedBoxEditWidth = totalSelectedBoxEditWidth;
    }
    self.IBCBMainSelectedContainer.width(selectedBoxEditWidth);

    if (viewElePosition && viewEleWidth && selectedBoxEditWidth) {
        if (isRemoveProc) {
            left =  parseInt(self.IBCBMainSelectedList.css("left")) + viewEleWidth;
        } else {
            left = selectedBoxEditWidth - viewEleWidth - (viewElePosition.left || 0);
        }

        left > 0 && (left = 0);
        self.IBCBMainSelectedList.css("left", left);
    }
};

MultiComboFn._setSelectingItemPosition = function(listContainer, item){
    var self = this,
        offset, scroll, elementHeight, itemHeight;

    if (self._hasScroll(listContainer)) {
        if (item.parent().length === 0) {
            item = null;
            return;
        }

        var itempaddingTop = item.css('paddingTop').replace('px','');
        var listborderTop = listContainer.css('borderTopWidth').replace('px','');
        var listpaddingTop = listContainer.css('paddingTop').replace('px','');
        var balance = /*- itemborderTop*/ - itempaddingTop - listborderTop - listpaddingTop;

        offsetTop = item.offsetTop() - listContainer.offsetTop();
        scrollTop = listContainer.scrollTop();

        listHeight = listContainer.outerHeight();
        itemHeight = item.outerHeight();

        if ( offsetTop < 0 ) {
            self.viewport.scrollTop(scrollTop + offsetTop + balance, true);
        } else if ( offsetTop + itemHeight > listHeight ) {
            self.viewport.scrollTop(scrollTop + offsetTop - listHeight + itemHeight - balance, true);
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/selectPosition.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setDDListHeight.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._setDropHeightForFilteringData = function ( value ) {
    this.viewport.setHeight( this.options.dropHeight = parseInt( value ) );
    //console.log('_setDropHeightForFilteringData: ' + value);

};

MultiComboFn._setTempDropHeight = function ( value ) {
    this.viewport.setHeight( value );
    //console.log('_setTempDropHeight: ' + value);
};

MultiComboFn._setDropHeight = function(value) {
    var self = this,
        opts = self.options,
        oViewport = self.viewport,
        vOpts = oViewport.options,
        rOpts, filteringItem,
        filteringListHeight,
        item, i, len, r;

    if (vOpts.data == null || vOpts.data.length === 0) {
        //console.log('_setDropHeight[viewport.data=0]._setTempDropHeight: ' + opts.oriDropHeight);
        self._setTempDropHeight( opts.oriDropHeight );
    } else {
        filteringItem = [];

        // value 내의 특수문자 처리
        value = value.replace(
            new RegExp ( IbmcTMP.RText2[2].pattern, "g"),
            function ($1) {
                return "\\" + $1;
            }
        );

        // 20150302-김의연-#5091 AutoComplete Ignore UpperCase
        rOpts = opts.useAutoCompleteIUC ? 'i' : '';

        r = new RegExp(value + "[sS]*", rOpts); //20151006 부분검색되도록 수정

        if ( r && r.test ) {
            for (i = 0, len = vOpts.data.length; i < len; ++i) {
                item = vOpts.data[i];
                if (r.test(item.dataFull)) { //20151006 컬럼 전체 검색으로 변경
                    filteringItem.push(item);
                }
            }
        }

        if ((filteringListHeight = filteringItem.length * self.GetItemHeight()) < opts.oriDropHeight) {
            self._setDropHeightForFilteringData( filteringListHeight );
        } else {
            self._setDropHeightForFilteringData( opts.oriDropHeight );
        }
    }

    return filteringItem;
};


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setDDListHeight.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setEventArgsMode.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._setEventArgsMode = function(bool) {
    if(bool == null) {
        bool = false;
    } else if(!_ib.isBoolean(bool)) {
        if(bool != '1' || bool != 'true') {
            bool = false;
        }
    }

    // value 가 1이면 모든 이벤트 핸들러에 현재 control object를 전달한다.
    IbmcCFG.EventArgsMode = bool;

    //this.options.eventArgsMode = bool;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setEventArgsMode.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setOutputMainEditOption.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// selectedbox를 화면에 출력하기 위해 text 형태로 출력하던 element들 style 변경
MultiComboFn._setOutputMainEditOption = function(textEditDis) {
    var self = this,
        options = self.options,
        editWidth,
        textEditWidth;

    if (editWidth = self.IBCBMainSelectedContainer.parent().width()) {

        // selectedItemBox에 margin 값을 줘서 여백을 주고 그만큼 editWidth를 빼준다.
        // IE6은 marginLeft 값이 과하게 먹으므로 10을 더뺌
        self.IBCBMainSelectedContainer.css('margin', '0 0 0 5px');
        if (_ib.Browser.name === 'msie' && _ib.Browser.version == '6') {
            editWidth -= 15;
        } else {
            editWidth -= 5;
        }

        textEditWidth = parseInt(editWidth / textEditDis);

        if (textEditWidth > 40) {
            textEditWidth = 40;
        } else if (textEditWidth <10) {
            textEditWidth = 0;
            self.IBCBMainEdit.hide();
        }
        options.editWidth = editWidth;
        // 뒤에 4를 더한 이유 IE에서 1행을 유지 못하더라 editWidth와 outerWidth 구하는게 브라우저마다 틀려서
        options.textEditWidth = self.IBCBMainEdit.css({
                marginTop: '3px',
                width: textEditWidth,
                display: 'block'
            }).outerWidth() + 4;
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setOutputMainEditOption.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setViewport.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._setViewport = function(items) {
    var self = this,
        options = self.options,
        userHtml,
        colAlign, colAlignVal, colAlignStr, colBackColor,
        data;

    userHtml = self._getUserHtml();

    self.viewport = _ib.Object.make(_ib.ui.tableviewport, {
        viewport: self.IBCBDropDownBodyScroll[0],
        canvas: self.IBCBDropDownTBL.parent()[0],
        template: userHtml,
        overflowX: "hidden",
        overflowY: "auto",
        width: "100%",
        height: options.dropHeight,
        rowHeight: options.itemHeight < options.minItemHeight ? options.minItemHeight : options.itemHeight,
        renderEleInject: function(index, target, viewport) {
            var data = viewport.options.data[index];

            if (data) {
                data.ele = target;

                if(self.selectingItem === index) {
                    self._setSelectColor( data.ele );
                }

                target.data("cell_data", data);
            }
        }
    });
};

MultiComboFn._addViewportData = function(items, begin, isCalColWidth) {
    var self = this,
        data = self._convertToViewportData(items, isCalColWidth);

    if (begin === -1) {
        self.viewport.last( data );
    } else if (begin === 0) {
        self.viewport.first( data );
    } else {
        self.viewport.add( data, begin );
    }

    // viewport refresh 예약
    self.reserveRefresh = true;
};

MultiComboFn._removeViewportData = function(beginIndex, endIndex) {
    this.viewport.remove(beginIndex, endIndex);
};

MultiComboFn._convertToViewportData = function(items, isCalColWidth) {    // multicombo에서 사용하기 위해 입력하는 data format을 Viewport에서 사용하는 data format으로 변경함.
    var self = this,
        options = self.options,
        isIE67 = IbmcTMP.isIE67,
        cols = options.cols, col,
        colText, colWidth, stringWidthObj,
        i, item, arrText, text, code,
        data = [], temp;

    for (i = 0; item = items[i]; ++i) {
        text = item.text || item.Text || item.TEXT || "";
        code = item.code || item.Code || item.CODE;

        data.push({});
        temp = data[data.length-1];
        temp.dataFull = "";
        for (col = 0; col < cols; col++ ) {
            arrText = text.split(options.fixMultiSeparator);
            colText = arrText[col] || "";

            if (isCalColWidth && colText) {
                colWidth = (stringWidthObj = self._getStringPixelWidthMulti(colText)).width + 12;  // 컬럼에 들어간 border, margin, padding의 보정값 12를 더해줌

                if ((options.maxColWidth[col] || 0) < colWidth) {
                    options.maxColWidth[col] = colWidth;        // dropdown list의 width 값 수정시 참조할 각 col별 최대로 큰 width 값
                    options.maxColWidthText[col] = colText;     // dropdown list의 width 값 수정시 참조할 각 col별 최대로 긴 문자열
                }
            }

            temp["text" + col] = colText || "";
            temp["colBackColor" + col] = options.ColBackColor[col] ? options.ColBackColor[col] : options.nonSelectColor;
            temp["colAlign" + col] = options.ColAlign[col];
            temp["colFontColor" + col] = options.ColFontColor[col];
            temp.dataFull+=colText; //20151006전체검색을 위해 추가
        }
        temp.index = i;
        temp.checked = "";
        temp.code = code || "";
        temp.text = self._getDelegateText(temp);
        temp.imgUrl = items.imgUrl || "";
        temp.multiSelect = "display: " + (options.multiSelect ? (isIE67 ? ";" : "table-cell;") : "none;");
        temp.useImage = "display: " + (options.useImage ? (isIE67 ? ";" : "table-cell;") : "none;");
        temp.lineColor = options.lineColor;
        temp.fontSize = options.fontSize;
        temp.fontFamily = options.fontFamily;
        temp.fontColor = options.fontColor;

        ++options.rows;
    }
    stringWidthObj && stringWidthObj.Destroy();
    self._setDropDownWidth( isCalColWidth ? false : true );

    return data;
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setViewport.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setWidth.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn._setDropDownWidth = function(nonCalTextWidth, moreBigger) {                          // dropdown list의 width으로 사용될 값 계산
    var self = this,
        options = self.options,
        colWidth,
        colHeight = 0,
        maxColWidth = options.maxColWidth,
        maxColWidthText = options.maxColWidthText,
        totalColWidth = 0,
        stringWidthObj;

    for (var i = 0, len = maxColWidthText.length; i < len; i++) {
        colWidth = (stringWidthObj = self._getStringPixelWidthMulti(maxColWidthText[i])).width + 12;    // padding, margin, border에 대한 보정값 12

        colHeight = colHeight < stringWidthObj.height ? stringWidthObj.height : colHeight;

        if (!nonCalTextWidth) {
            if (moreBigger) {
                if (maxColWidth[i] < colWidth) {
                    maxColWidth[i] = colWidth;
                }
            } else {
                maxColWidth[i] = colWidth;
            }
        }
        totalColWidth += maxColWidth[i];
    }

    if (stringWidthObj) {
        stringWidthObj && stringWidthObj.Destroy();
    }
    !options.isCalledSetItemHeight && (options.headerHeight = options.itemHeight = self.viewport.options.rowHeight = colHeight < options.minItemHeight ? options.minItemHeight : colHeight);

    totalColWidth += self._getTotalWidthCap();
    options.dropWidth = totalColWidth;

    return self;
};

MultiComboFn._redefineMaxColWidth = function(tr, trData, maxColWidth, maxColWidthText, indexCol, text, isHeader) {
    var self = this,
        showCol = self.options.showCol,
        fixCols = self.options.fixCols,
        width = self._getStringPixelWidthSingle(text);

    if (maxColWidthText[indexCol] === trData["text" + indexCol]) {
        trData.text = self._getDelegateText(trData);
        isHeader && (trData["text" + indexCol] = text);

        maxColWidth[indexCol] = -1;
        tr.foreach(function() {
            var ele = _ib(this),
                text = ele.children(fixCols+indexCol).text(),
                width = self._getStringPixelWidthSingle(text);

            if (width +12 > maxColWidth[indexCol]) {    // 12 : td element의 margin, padding, border 보정값
                maxColWidth[indexCol] = width +12;
                maxColWidthText[indexCol] = text;
            }
        });
    } else if (width +12 > maxColWidth[indexCol]) {
        !isHeader && (trData.text = self._getDelegateText(trData));

        maxColWidth[indexCol] = width +12;          // 12 : td element의 margin, padding, border 보정값
        maxColWidthText[indexCol] = text;
    } else {
        !isHeader && (trData.text = self._getDelegateText(trData));
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/internal/setWidth.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/BlurMainEdit.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// input text box에 blur event trigger
// 13.12.2 : refactoring 후 기능 불필요로 인한 메뉴얼 삭제
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.BlurMainEdit = function() {
    var self = this;

    if (self.IBCBMainEdit.css("display") !== "none") {
        self.IBCBMainEdit.trigger("blur");
    } else {
        // close
        self.dropdownListFlag = true;
        self._dropdownProcess(false, true);
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/BlurMainEdit.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/DeleteItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.DeleteItem = function(nIdx, isCode) {       // item 삭제
    var self = this,
        options = self.options,
        //nSelectingIdx = parseInt(self.selectingItem),
        nSelectedIdx = parseInt(self.GetSelectIndex()),
        sPrevText, sPrevCode;

    if (isCode) {
        nIdx = self.FindItem(nIdx);
    }

    if (options.rows - 1 < nIdx) {
        return;
    }

    if(nIdx === self.selectingItem) {
        self.selectingItem = undefined;
    }

    // 20150429-김의연-# 현재 선택된 아이템이 제거될때 OnChange 이벤트가 발생하지 않는 오류 수정
    if (nIdx === nSelectedIdx) {
        //console.log('DeleteItem.SetSelectIndex()');

        sPrevText = self.GetSelectText();
        sPrevCode = self.GetSelectCode();

        self.SetSelectIndex('', false);
        self._eventCaller('change')(
            nIdx, sPrevText, sPrevCode,
            self.GetSelectIndex(), self.GetSelectText(), self.GetSelectCode());
    }

    self._deleteValue(self.viewport.options.data[nIdx].ele);
    self.viewport.remove( nIdx );
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/DeleteItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/DisplayDDList.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// Drop-down list의 출력 여부 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.DisplayDropDownList = function(isDisplay, isEvent) {
    var self = this;

    if ( self.options.visible ) {
        if (isDisplay) {
            // open
            clearTimeout( self.DDDListID );
            self.DDDListID = setTimeout( (function (isEvent) {
                return function () {
                    self._dropdownProcess(true, isEvent);

                    self.preventFocus = !!isEvent ? false : true;
                    self.IBCBMainEdit.focus();
                };
            }( isEvent )), 10 );
        } else {
            // close
            clearTimeout( self.DDDListID );
            self.DDDListID = setTimeout( (function (isEvent) {
                return function () {
                    // self.dropdownListFlag = true;
                    self._dropdownProcess(false, isEvent, undefined, false);

                    self.preventBlur = !!isEvent ? false : true;
                    self.IBCBMainEdit.blur();
                };
            }( isEvent )), 10 );
        }
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/DisplayDDList.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/FindItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 아이템 찾기
//특정 컬럼에서 해당하는 문자열과 동일한 Item을 찾아 bIsIndex=true 이면 행 Index 리턴 bIsIndex=false 이면 행 Code 리턴
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.FindItem = function(sText, Col, bIsIndex) {
    var self = this,
        options = self.options,
        isIndex,
        itemIndex = -1,
        viewportData = self.viewport.options._data,
        data,
        type;

    if ( bIsIndex === 0 ) {
        bIsIndex = false;
    } else if ( bIsIndex === 1 ) {
        bIsIndex = true;
    }

    if (bIsIndex != null) {
        if (options.cols - 1 < Col) {
            return;
        }
        type = 'text' + Col;
    } else {
        bIsIndex = Col;
        type = 'code';
    }

    isIndex = bIsIndex === false || bIsIndex === "false" ? false : true;

    for (var i = 0, len = viewportData.length; i < len; ++i) {
        if ((data = viewportData[i]) && data[type]  === sText) {
            itemIndex = i;
            break;
        }
    }

    return itemIndex > -1 ? (isIndex ? itemIndex : (data ? data.code : -1)) : -1;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/FindItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/Focus.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.Focus = function() {
    this.IBCBMainEdit.focus();
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/Focus.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/GetIndexText.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 인덱스로 특정 컬럼의 글자 얻기 개발자 guide 문서에는 추가하지 않음
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetIndexText = function ( index, col ) {
    var self;

    if ( _ib.isInteger( index = parseInt( index ) ) ) {
        col = parseInt( col );
        return this.GetText( index - 1 , col - 1 );
    }
};

MultiComboFn.GetIndexCode = function (index) {
    if (_ib.isInteger(index = parseInt(index))) {
        var result = this.GetCode(index);
        if (result == undefined) {
            return "";
        } else {
            return result;
        }
    }
};


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/GetIndexText.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/GetItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.GetItem = function(accept, url, param, callback) {
    if (accept === "json") {
        this.GetItemJson(url, param, callback, true);
    } else if (accept === "xml") {
        this.GetItemXml(url, param, callback);
    }
};

//========================================================================================================================
// Ajax 통신으로 Json 가져와서 콤보 아이템 설정하는 함수
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetItemJson = function(url, param, callback, clear, begin, reqHeaders, jsonSyntax) {
    var self = this,
        opts = self.options,
        isCalledSetColWidth;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return;
    }

    isCalledSetColWidth = !opts.isCalledSetColWidth;

    if(_ib.isObject( url )) {
        param = url.param;
        callback = url.callback;
        clear = url.clear;
        begin = url.begin;
        reqHeaders = url.reqHeaders;
        jsonSyntax = url.jsonSyntax;
        url = url.url;
    }

    if (clear != false) {
        self.RemoveAll(false);
    }

    if (_ib.isFunction(param)) {
        callback = param;
    }

    _ib.get({
        isAsync: opts.syncRequest ? false : true,
        accept: "json",
        url: url,
        reqHeaders: reqHeaders,
        param: param || "",
        nonSyntaxCheckJson: true,
        success: function(json) {
            var data;
            if (json) {
                data = json.data || json.DATA || json.Data;
                if (jsonSyntax) {
                    // InsertItem에서 json 문법이 올바르지 않아도 data 처리하기때문에
                    // jsonSyntax를 두어 문법 맞는 data를 받아 연속으로 list에 item을 insert 한다.
                    if (_ib.isArray(data)) {
                        self._addViewportData(data, begin, isCalledSetColWidth);
                    }
                } else {
                    if (_ib.isArray(data)) {
                        self._addViewportData(data, begin, isCalledSetColWidth);
                    }
                }
                callback && callback(json);
            }
        }
    });
};
//========================================================================================================================
// Json 문자열 가져와서 콤보 아이템 설정하는 함수
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetItemJsonString = function(jsonStr, clear, begin) {
    var self = this,
        opts = self.options;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return;
    }

    if (_ib.isObject( jsonStr )) {
        clear = jsonStr.clear;
        begin = jsonStr.begin;
        jsonStr = jsonStr.jsonStr;
    }

    if (clear != false) {
        self.RemoveAll(false);
    }

    if (_ib.isString( jsonStr )) {
        self._insertItem(_ib.json.parse(jsonStr, true) || {}, undefined, begin);
    } else if (_ib.isObject( jsonStr )) {
        self._insertItem( jsonStr, undefined, begin );
    }
};

//========================================================================================================================
// Ajax 통신으로 Xml 가져와서 콤보 아이템 설정하는 함수
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetItemXml = function(url, param, callback, clear, begin, reqHeaders) {
    var self = this,
        opts = self.options;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return;
    }

    if (_ib.isObject( url )) {
        param = url.param;
        callback = url.callback;
        clear = url.clear;
        begin = url.begin;
        url = url.url;
        reqHeaders = url.reqHeaders;

    }

    if (clear != false) {
        self.RemoveAll(false);
    }

    if (_ib.isFunction(param)) {
        callback = param;
    }

    _ib.get({
        isAsync: opts.syncRequest ? false : true,
        accept: "xml",
        url: url,
        param: param,
        reqHeaders: reqHeaders,

        success: function(xml) {
            if (xml) {
                self._insertItem(_ib(xml), true, begin);
                callback && callback(xml);
            }
        }
    });
};
MultiComboFn.GetItemXmlString = function(xmlStr, clear, begin) {
    var self = this,
        opts = self.options;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return;
    }

    if (_ib.isObject( xmlStr )) {
        clear = xmlStr.clear;
        begin = xmlStr.begin;
        xmlStr = xmlStr.xmlStr;
    }

    if (clear != false) {
        self.RemoveAll(false);
    }

    self._insertItem(_ib(_ib.string2xml(xmlStr)), true, begin);
};


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/GetItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/HeaderCreate.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// dropdown list 의 header create
MultiComboFn.HeaderCreate = function() {
    var self = this,
        multi_combo_header_template = "",
        multi_combo_head_body_template = '<th style="width: {{fixedchkwidth}}px;display:none;" class="DRL_SELECTED_ITEM"></th>'+
            '<th style="width: {{fixedimgwidth}}px;display:none;" class="DRL_HEADER_DIV_FONT"><div class="DRL_HOVER_ITEM" style="display:none;"></th>',
        opts = self.options,
        cols = opts.cols,
        oTmpl = IbmcTMP,
        colWidth,
        totalColWidth = 0;

    self.IBCBDropDownHeaderTBLTR.css("height", opts.itemHeight);
    self.IBCBDropDownHeaderTBLTR.empty();
    for (var i =0; i < cols; i++) {
        totalColWidth += colWidth;

        multi_combo_header_template += '<th ibcb-name="{{id}}_IBCBDropDownHeaderTBLTD' + i + '" align="center" valign="middle" class="DRL_HEADER_TD DRL_DIV_BORDER" >'+
        '<div ibcb-name="{{id}}_IBCBDropDownHeaderTBLDIV' + i + '" class="DRL_HEADER_TD_DIV DRL_HEADER_DIV_FONT" style="overflow: hidden; vertical-align: middle; font-size:{{fontSize}}px;">'+ i +'</div>'+
        '</th>';

        // data부분 col생성시 style 참고
        opts.ColWidth[i] = -1;
        opts.maxColWidth[i] = -1;
        opts.maxColWidthText[i] = "";
        opts.ColFontColor[i] = opts.fontColor;
        opts.ColBackColor[i] = opts.nonSelectColor;
        opts.ColAlign[i] = "left";

        multi_combo_head_body_template += '<th class="DRL_FONT"></th>';
    }

    totalColWidth += self._getTotalWidthCap();

    var multiComboListChkElements = _ib(oTmpl.MULTI_COMBO_LIST_CHK_TEMPLATE(opts));
    var multiComboListImgElements = _ib(oTmpl.MULTI_COMBO_LIST_IMG_TEMPLATE(opts));
    var multiComboHeaderElements  = _ib(_ib.template(multi_combo_header_template).compile()(opts));
    var multiComboHeadBodyElements  = _ib(_ib.template('<tr>' + multi_combo_head_body_template + '</tr>').compile()(opts));

    // header element create
    self.IBCBDropDownHeaderTBLTR.append(multiComboListChkElements[0]);
    self.IBCBDropDownHeaderTBLTR.append(multiComboListImgElements[0]);
    self.IBCBDropDownHeaderTBLTR.append(multiComboHeaderElements);
    self.IBCBDropDownHeadTBL.append(multiComboHeadBodyElements);

    self.IBCBDropDownHeaderTBLTR.css({height: opts.itemHeight});

    // header element style
    self.IBCBHeaderChkTd = multiComboListChkElements;
    self.IBCBHeaderChkDiv = multiComboListChkElements.children();
    self.IBCBHeaderChkBtn = self.IBCBHeaderChkDiv.children();
    self.IBCBHeaderImgTd = multiComboListImgElements;
    self.IBCBHeaderImgDiv = multiComboListImgElements.children();
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/HeaderCreate.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/Initialize.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.Init = function(showCol, userOpts) {
    var self = this,
        opts = self.options,
        sCompId = opts.id,
        oTmpl = IbmcTMP,
        isIE67 = oTmpl.isIE67,
        wrappEl, wrappHtml, wrappTmpl,
        mtcbEls, mtcbListEls;

    opts.showCol = showCol != null ? showCol : opts.showCol != null ? opts.showCol : 0;

    // Init 중복 호출방지
    if(opts.bInitialize) {
        return;
    } else {
        opts.bInitialize = true;
    }

    userOpts = userOpts || {};

    if (_ib.isHtml.test( wrappHtml = opts.wrappingHtml )) {
        if ( /{{maindiv}}/g.test( wrappHtml ) ) {
            wrappTmpl = _ib.template( opts.wrappingHtml ).compile();
            wrappEl = _ib( wrappTmpl( {maindiv: oTmpl.MTCB_TMPL( opts )} ) );
        } else {
            wrappEl = _ib( wrappHtml ).append( oTmpl.MTCB_TMPL( opts ) );
        }

        mtcbEls = self.multiComboElements = wrappEl.find( 'div[ibcb-name='+ sCompId +']' );
        self.IBCBMainDiv = mtcbEls;
    } else {
        mtcbEls = self.multiComboElements = _ib( oTmpl.MTCB_TMPL( opts ) );
        wrappEl = self.IBCBMainDiv = mtcbEls;
    }

    mtcbListEls = self.multiComboListElements = _ib( oTmpl.MTCB_LIST_TMPL( opts ) );

    self.IBCBMainTbl = mtcbEls.find("*[ibcb-name=" + sCompId + "_IBCBMainTbl]");

    self.IBCBMainEdit = mtcbEls.find("*[ibcb-name=" + sCompId + "_text]");
    self.IBCBMainSelectedContainer = mtcbEls.find("*[ibcb-name=" + sCompId + "_selectedContainer]").css("display","none");
    self.IBCBMainSelectedList = self.IBCBMainSelectedContainer.children();
    self.IBCBMainBtn = mtcbEls.find("*[ibcb-name=" + sCompId + "_IBCBMainBtn]");

    self.IBCBDRL = mtcbListEls;
    self.IBCBDropDownHead = mtcbListEls.find("*[ibcb-name=" + sCompId + "_IBCBDropDownHead]");
    self.IBCBDropDownHeaderTBL = mtcbListEls.find("*[ibcb-name=" + sCompId+ "_IBCBDropDownHeaderTBL]").children();
    self.IBCBDropDownHeaderTBLTR = mtcbListEls.find("*[ibcb-name=" + sCompId + "_IBCBDropDownHeaderTBLTR]");

    // self.IBCBDropDown = multiComboListElements.find("*[ibcb-name=" + id + "_IBCBDropDown]");
    self.IBCBDropDownHeadTBL = mtcbListEls.find("*[ibcb-name=" + sCompId + "_IBCBDropDownTBL]").children('thead');
    self.IBCBDropDownTBL = mtcbListEls.find("*[ibcb-name=" + sCompId + "_IBCBDropDownTBL]").children('tbody');

    self.IBCBDropDownScroll = mtcbListEls.find("*[ibcb-name=" + sCompId + "_IBCBDropDownScroll]");
    self.IBCBDropDownHeadScroll = _ib(self.IBCBDropDownScroll[0]);
    self.IBCBDropDownBodyScroll = _ib(self.IBCBDropDownScroll[1]);

    // object상위에 dropdown list를 출력하기 위한 꼼수용 panel multicombo 객체의 property에 할당
    self.panelOnObject = self.IBCBDRL.find('iframe');

    opts.drawWidth = self.IBCBMainTbl.outerWidth();

    // dropdownlist show/hide 순서 확인자
    self.dropdownListFlag = true;

    // selectinglbox 에서 list중 사용자가 보고있는 item
    self.selectingItem = undefined;

    // // DOM tree 에 추가
    self.element.after(wrappEl);
    self.IBCBMainDiv.append(self.element.hide());


   //2015-09-15 ie7 위치설정 위에 추가되로고 변경
//20151023 _속도문제
//    if(parseInt(_ib.Browser.version) == 7 &&_ib.Browser.name=="msie"){
//        setTimeout(function() {
//                if (opts.prependIE7 == true)   _ib("body").prepend(mtcbListEls);
//
//   // 2015-09-15 ie7 위치설정 위에 추가되도록 변경
//	// 2015-10-20 위세 때문에 반영한 것이지만 현대건설 때문에 되돌림 )
//	// setTimeout(function(){   _ib("body").prepend(mtcbListEls);},1);
//
//                else  _ib("body").append(mtcbListEls);
//
//                var oHoverStyles=self.IBCBDropDownHeadTBL.find(".DRL_HOVER_ITEM").css("color,backgroundColor");
//                opts.hoverColor = oHoverStyles.backgroundColor;
//                opts.hoverFontColor = oHoverStyles.color;
//            }
//
//            ,1);
//    }else{
//        _ib("body").append(mtcbListEls);
//    }

//2015-12-10 싱글셀렉트일 경우 문제 해결
    if (parseInt(_ib.Browser.version) == 7 && _ib.Browser.name == "msie") {
        if (opts.prependIE7 == true)  setTimeout(function(){   _ib("body").prepend(mtcbListEls);
            var oHoverStyles = self.IBCBDropDownHeadTBL.find(".DRL_HOVER_ITEM").css("color,backgroundColor");
            opts.hoverColor = oHoverStyles.backgroundColor;
            opts.hoverFontColor = oHoverStyles.color;
            var oSelectedColor = self.IBCBDropDownHeadTBL.find(".DRL_SELECTED_ITEM").css("color,backgroundColor");
            opts.selectColor = oSelectedColor.backgroundColor;
        },1);
        else {_ib("body").append(mtcbListEls);
        }
    }else{
        _ib("body").append(mtcbListEls);
    }


   // setTimeout(function(){   _ib("body").prepend(mtcbListEls);},1);   //2015-09-15 ie7 위치설정 위에 추가되도록 변경 (위세 때문에 반영한 것이지만 현대건설 때문에 되돌림 )

    // dropdown list의 dynamic rendering을 위한 viewport 설정
    self._setViewport();

    if (opts.useSelectedBox) {
        self._setOutputMainEditOption(4);
    }

    if (_ib.isSmartDevice) {
        // smartDevice(phone, tablet) scrolling
        self.SmartScrollLoad();
    }

    // // headerElement Create
    if (opts.cols || userOpts.title) {
        (_ib.isUndefined(opts.cols) && _ib.isString(userOpts.title)) && (opts.cols = userOpts.title.split(opts.fixMultiSeparator).length);
        self.HeaderCreate();

        if (userOpts.title) {
            self.SetTitle(userOpts.title);
            opts.titleVisible = true;
        }
    }

    // control의 event listener 할당
    self._assignListener();

    self.__initMultiComboStyle();

    // control 생성시 options.data 입력 시에만 element의 value에서 값 getter 함.
    if (userOpts.data) {
        if (userOpts.data.url) {
            // data 하위에 url 이 있으면 ajax로 로드함.
            if (userOpts.data.accept === "xml") {
                self.GetItemXml(userOpts.data.url, userOpts.data.param, userOpts.data.success);
            } else {
                self.GetItemJson(userOpts.data.url, userOpts.data.param, userOpts.data.success, true);
            }
        } else {
            self._addViewportData(userOpts.data, undefined, userOpts.initColWidth ? false: true);
        }

        // css파일을 ajax로 javascript 내에서 로드되기 때문에 css 로드전 element의 특성을 파악할수가 없어
        // css 파일 로드 callback 을 만들어 실행하도록 한다.
        IbmcTMP.CssOnLoadCallBack.push(function() {
            var sValue, aValue;
            if (sValue = self.element.value()) {
                aValue = sValue.split(opts.fixMultiSeparator);

                for(var j = 0; sValue = aValue[j++]; ) {
                    self.SetSelectCode(sValue);
                }
            }
        });
    }

    if (userOpts.initColWidth) {
        self.SetColWidth(userOpts.initColWidth);
    }

    // checkbox, image box td show
    if (opts.multiSelect) {
        self.IBCBDropDownHeadTBL.children(0).children(0).css("display", isIE67 ? "" : "table-cell");
        self.IBCBDropDownHeaderTBL.children(0).children(0).css("display", isIE67 ? "" : "table-cell");
    } else {
        self.IBCBDropDownHeadTBL.children(0).children(0).hide();
        self.IBCBDropDownHeaderTBL.children(0).children(0).hide();
    }

    if (opts.useImage) {
        self.IBCBDropDownHeadTBL.children(0).children(1).css("display", isIE67 ? "" : "table-cell");
        self.IBCBDropDownHeaderTBL.children(0).children(1).css("display", isIE67 ? "" : "table-cell");
    } else {
        self.IBCBDropDownHeadTBL.children(0).children(1).hide();
        self.IBCBDropDownHeaderTBL.children(0).children(1).hide();
    }

    //console.log('%c1-2 ' + sCompId + '.Init End', IbmcDEV.C1);
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/Initialize.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/InsertItem.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.InsertItem = function(index, text, code) {
    var self = this;

    if (code == null) {
        code = "" + index;
    }
    self._addViewportData([{text: text, code: code}], index, self.options.isCalledSetColWidth ? false : true);

    return index;
};

MultiComboFn.InsertBatchItem = function(index, data, colsWidth) {
    var self,
        i, len;

    self = this;

    if (colsWidth) {
        for (i = 0, len = colsWidth.length; i < len; ++i) {
            self.SetColWidth(i, colsWidth[i])
        }
    }
    self._addViewportData(data, index, false);

    return index;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/InsertItem.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/RemoveAll.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

// ibmulticombo에 입력한 데이터 초기화
MultiComboFn.RemoveAll = function(remainItem, outputMainEdit) {
    var self = this,
        options = self.options,
        id = options.id,
        prevRows, data;

    options.selectedValue.remove();
    self.viewport.scrollTop(0);
    if (remainItem) {
        data = self.viewport.options.data;
        for(var i = 0, len = data.length; i < len; ++i) {
            data[i].checked = '';
        }
    } else {
        prevRows = options.rows;
        options.rows = 0;

        self.viewport.remove();

        // 모든 아이템이 삭제 되었을 때 이벤트가 발생한다.
        // RemoveAll 함수 또는 DeleteItem 함수를 이용하여 아이템이 모두 삭제되면 이벤트가 발생한다.
        if (remainItem === undefined && prevRows > 0) {
            window[id + '_OnClear'] ? window[id + '_OnClear']() : options.onClear && options.onClear();
        }
    }
    if (outputMainEdit !== false) {
        self._outputMainEdit();
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/RemoveAll.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetBackColor.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 배경색  maindiv와 input의 background-color값
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetBackColor = function(sColor) {
    var self = this,
        opts = self.options;
        //ColBackColor = opts.ColBackColor;

    sColor = Util.string2color(sColor);
    opts.backColor = Util.convertColor(_ib("<div>").css({backgroundColor:sColor}).style("backgroundColor")) || opts.backColor;

    if (opts.enable) {
        self.IBCBMainTbl.find("td").css("backgroundColor", opts.backColor);
        self.IBCBMainTbl.css("backgroundColor", opts.backColor);
    }
};

MultiComboFn.GetBackColor = function() {
    return Util.convertColor(this.options.backColor);
};

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 불가배경색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetDisabledBackColor = function(sColor) {
    var self = this,
        options = self.options;
    sColor = Util.string2color(sColor);

    options.disabledBackColor = Util.convertColor(_ib("<div>").css({backgroundColor: sColor}).style("backgroundColor")) || options.disabledBackColor;

    if (!options.enable) {
        self.IBCBMainTbl.find("td").css("backgroundColor", options.disabledBackColor);
        self.IBCBMainTbl.css("backgroundColor", options.disabledBackColor);
    }
};
MultiComboFn.GetDisabledBackColor = function() {
    return Util.convertColor(this.options.disabledBackColor);
};

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 선택배경색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetSelectBackColor = function(sColor) {
    var self = this, ele;

    sColor = Util.string2color(sColor);

    self.options.selectColor =  Util.convertColor(_ib("<div>").css({backgroundColor: sColor}).style("backgroundColor")) || self.options.selectColor;

    if (_ib.isInteger(self.selectingItem)) {
        if (ele = self.viewport.options.data[self.selectingItem].ele) {
            ele.parent().length > 0 && ele.children().css({backgroundColor: self.options.selectColor});
        }
    }
};
MultiComboFn.GetSelectBackColor = function() {
    return Util.convertColor(this.options.selectColor);
};

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - hover 배경색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetHoverBackColor = function ( sColor ) {
    var self, ele;

    self = this;
    sColor = Util.string2color( sColor );

    self.options.hoverColor =  Util.convertColor( _ib( "<div>" ).css( { backgroundColor: sColor } ).style( "backgroundColor" ) ) || self.options.hoverColor;

    if ( _ib.isInteger( self.hoverItem ) ) {
        if ( ele = self.viewport.options.data[ self.hoverItem ].ele ) {
            ele.parent().length > 0 && ele.children().css( { backgroundColor: self.options.hoverColor } );
        }
    }
};
MultiComboFn.GetHoverBackColor = function () {
    return Util.convertColor( this.options.hoverColor );
};

//========================================================================================================================
// focus시 multicombo의 테두리색 설정 / 얻기
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetFocusHighlightColor = function() {
    return Util.convertColor( this.options.focusHighlightColor );
};

MultiComboFn.SetFocusHighlightColor = function(sColor) {
    var self = this,
        opts = self.options;

    sColor = Util.string2color(sColor);
    opts.focusHighlightColor = Util.convertColor(_ib("<div>").css({backgroundColor: sColor}).style("backgroundColor")) || opts.readOnlyBackColor;

    if(window.document.activeElement === self.element[ 0 ] ) {
        self.IBCBMainTbl.css("borderColor", opts.focusHighlightColor);
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetBackColor.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetBatchOutput.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.SetBatchOutput = function ( value ) {
    var self;

    self = this;
    if ( value === 0 ) {
        value = false;
    } else if ( value === 1 ) {
        value = true;
    }

    if ( self.options.batchOutput !== value ) {
        self.options.batchOutput = value;
        self._outputMainEdit();
    }
};

MultiComboFn.GetBatchOutput = function () {
    return this.options.batchOutput;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetBatchOutput.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetColumns.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 컬럼 갯수 설정 - 데이타가 있을때에는 안되고 초기에만 가능
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetCols = function(nCount) {
    var self = this;
    nCount = parseInt(nCount);
    if (self.options.rows > 0) {
        return;
    }

    self.options.cols = nCount;

    self.HeaderCreate();
    self.viewport.setRowTemplate( self._getUserHtml() );
};
MultiComboFn.ColCount = function() {
    return this.options.cols;
};


//========================================================================================================================
// 컬럼 정렬
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetColAlign = function(nCol, sAlign) {
    var self = this,
        options = self.options,
        eles,
        viewportData = self.viewport.options.data,
        data;

    if (options.cols - 1 < nCol || !_ib.isString(sAlign)) {
        return;
    }

    sAlign = (sAlign || "left").toLowerCase();

    options.ColAlign[nCol] = sAlign;

    for (var i = 0, len = viewportData.length; i < len; ++i) {
        if (data = viewportData[i]) {
            data["colAlign" + nCol] = sAlign;
        }
    }
};

//========================================================================================================================
// 컬럼별 폭 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetColWidth = function(nCol, nWidth) {
    var self = this,
        options = self.options;

    nWidth = parseInt(nWidth);

    if (_ib.isInteger(nWidth)) {
        // SetColWidth가 호출되어 사용자가 직접 열의 너비를 수정하였기 때문에 InsertItem시 더이상 자동으로 열을 계산하여 열의 너비를 수정하지 않는다.
        options.isCalledSetColWidth = true;

        options.maxColWidth[nCol] = nWidth;
        self._setDropDownWidth(true);
    } else if (_ib.isArray(nCol)) {
        // SetColWidth가 호출되어 사용자가 직접 열의 너비를 수정하였기 때문에 InsertItem시 더이상 자동으로 열을 계산하여 열의 너비를 수정하지 않는다.
        options.isCalledSetColWidth = true;

        for (var i = 0, len = nCol.length; i < len; ++i) {
            options.maxColWidth[i] = nCol[i];
        }
        self._setDropDownWidth(true);
    }
};

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 컬럼 글자색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetColFontColor = function(nCol, sColor) {
    var self = this,
        options = self.options,
        eles,
        viewportData = self.viewport.options.data,
        data;

    if (options.cols - 1 < nCol) {
        return;
    }

    sColor = Util.string2color(sColor);

    options.ColFontColor[nCol] = Util.convertColor(_ib("<div>").css({color: sColor}).style("color")) || options.ColFontColor[nCol];
    for (var i = 0, len = viewportData.length; i < len; ++i) {
        if (data = viewportData[i]) {
            data["colFontColor" + nCol] = options.ColFontColor[nCol];
        }
    }
    self.viewport.refresh();
};
MultiComboFn.GetColFontColor = function(nCol) {
    var self = this,
        options = self.options;

    if (options.cols - 1 < nCol) {
        return;
    }

    return Util.convertColor(options.ColFontColor[nCol]);
};


//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 컬럼 배경색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetColBackColor = function(nCol, sColor) {
    var self = this,
        options = self.options,
        eles,
        viewportData = self.viewport.options.data,
        data;

    if (options.cols - 1 < nCol) {
        return;
    }

    sColor = Util.string2color(sColor);

    options.ColBackColor[nCol] = Util.convertColor(_ib("<div>").css({backgroundColor: sColor}).style("backgroundColor")) || options.ColBackColor[nCol];
    for (var i = 0, len = viewportData.length; i < len; ++i) {
        if (data = viewportData[i]) {
            data["colBackColor" + nCol] = options.ColBackColor[nCol];
        }
    }
};
MultiComboFn.GetColBackColor = function(nCol) {
    if (this.cols - 1 < nCol) {
        return;
    }

    return Util.convertColor(this.options.ColBackColor[nCol]);
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetColumns.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetCount.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 줄 수 얻기 GetRows = GetItemCount
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetRows = function() {
    return this.options.rows;
};
MultiComboFn.GetItemCount = function() {
    return this.options.rows;
};

//========================================================================================================================
// 선택 건수 표시여부 설정 (SetMultiSelect = true 시에만 적용),표시여부 얻기 (SetMultiSelect = true 시에만 적용)
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetUseSelectCount = function() {
    return this.options.useSelectCount;
};
MultiComboFn.SetUseSelectCount = function(bValue) {
    var self = this,
        opts = self.options;

    if(bValue == null) {
        bValue = false;
    } else {
        bValue = !!bValue;
    }
    opts.useSelectCount = bValue;
    self._outputMainEdit();
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetCount.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetDDListHeight.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 드랍목록 높이
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetDropHeight = function() {
    return this.options.dropHeight;
};

MultiComboFn.SetDropHeight = function(nValue) {
    var self = this,
        opts = self.options,
        nHeight;

    nHeight = opts.oriDropHeight = opts.dropHeight = parseInt(nValue);
    self.viewport.setHeight(nHeight, true);
    //console.log('SetDropHeight: '+ nValue);

};


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetDDListHeight.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetDDListShowBtn.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.SetNarrowDDListShowBtn = function ( value ) {
    var self;

    self = this;
    if ( value === 0 ) {
        value = false;
    } else if ( value === 1 ) {
        value = true;
    }

    if ( !_ib.isBoolean( value ) ) {
        return;
    }

    return self.options.narrowDDListShowBtn = value;
};
MultiComboFn.GetNarrowDDListShowBtn = function () {
    var self;

    self = this;

    return self.options.narrowDDListShowBtn;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetDDListShowBtn.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetEditable.js
/**
 * Created by Euiyeon on 2015-03-19.
 */


//========================================================================================================================
// 편집여부 설정 / 얻기
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetEditable = function() {
    return this.options.editable;
};
MultiComboFn.SetEditable = function(bValue) {
    var self = this,
        options = self.options,
        data = bValue ?
        {editable: true, backgroundColor: options.backColor, fontColor: options.fontColor} :
        {editable: false, backgroundColor: options.readOnlyBackColor, fontColor: options.readOnlyFontColor};

    options.editable = data.editable;
    self.IBCBMainEdit.attribute("readonly", !data.editable).css({color: data.fontColor});

    self.IBCBMainTbl.css({color: data.fontColor});
    if ( options.enable ) {
        self.IBCBMainTbl.find("td").css({backgroundColor: data.backgroundColor});
        self.IBCBMainTbl.css({backgroundColor: data.backgroundColor});
    }
};

//========================================================================================================================
// 불가시 글자색 설정 / 얻기
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetUnEditableFontColor = function(sColor) {
    var self = this,
        options = self.options;
    sColor = Util.string2color(sColor);

    options.readOnlyFontColor =  Util.convertColor(_ib("<div>").css({color: sColor}).style("color")) || options.readOnlyFontColor;

    if ( !options.editable ) {
        self.IBCBMainEdit.css("color", options.editable ? options.fontColor : options.readOnlyFontColor);
    }
};
MultiComboFn.GetUnEditableFontColor = function() {
    return Util.convertColor(this.options.readOnlyFontColor);
};

//========================================================================================================================
// 불가시 배경색 설정 / 얻기
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetUnEditableBackColor = function(sColor) {
    var self = this,
        options = self.options;
    sColor = Util.string2color(sColor);

    options.readOnlyBackColor =  Util.convertColor(_ib("<div>").css({backgroundColor: sColor}).style("backgroundColor")) || options.readOnlyBackColor;

    if ( !options.editable ) {
        self.IBCBMainTbl.find("td").css("backgroundColor", options.readOnlyBackColor);
        self.IBCBMainTbl.css("backgroundColor", options.readOnlyBackColor);
    }
};
MultiComboFn.GetUnEditableBackColor = function() {
    return Util.convertColor(this.options.readOnlyBackColor);
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetEditable.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetEnable.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 사용 가능 여부
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetEnable = function() {
    return this.options.enable;
};
MultiComboFn.SetEnable = function(isEnable) {
    var self = this,
        procMethod,
        disabled = !isEnable,
        backgroundColor;

    if (isEnable) {
        procMethod = "removeAttribute";
        backgroundColor = self.options.editable ? self.options.backColor : self.options.readOnlyBackColor;

    } else {
        procMethod = "attribute"
        backgroundColor = self.options.disabledBackColor;
    }

    self.IBCBMainTbl.find("td").css("backgroundColor", backgroundColor);
    self.IBCBMainTbl[procMethod]("disabled", disabled).css("backgroundColor", backgroundColor);
    self.IBCBMainEdit[procMethod]("disabled", disabled);
    self.IBCBMainBtn[procMethod]("disabled", disabled).css("cursor", disabled ? "default" : "pointer");
    self.element[procMethod]("disabled", disabled);

    // dropdown list show/hide 초기화
    if (self.IBCBDRL.css("display") === "block") {
        self.dropdownListFlag = true;
        self._dropdownProcess(false);
    }

    self.options.enable = isEnable;
};

//========================================================================================================================
// multicombo item 전체 선택 btn 활성화
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetEnableAllCheckBtn = function () {
    return this.options.enableAllCheckBtn;
};
MultiComboFn.SetEnableAllCheckBtn = function ( value ) {
    var that,
        options;

    that = this;
    options = that.options;

    if ( _ib.isBoolean( value ) && that.IBCBHeaderChkBtn ) {
        value ? that.IBCBHeaderChkBtn.show() : that.IBCBHeaderChkBtn.hide();
        options.enableAllCheckBtn = value;
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetEnable.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetFontColor.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 폰트 색상
//폰트색상을 얻는다
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetFontColor = function(sFontColor) {
    var self = this,
        options = self.options,
        cols = options.cols,
        ColFontColor = self.options.ColFontColor,
        oViewportData = self.viewport.options.data,
        oData;

    sFontColor = Util.string2color(sFontColor);

    self.options.fontColor = Util.convertColor(_ib("<div>").css({color: sFontColor}).style("color")) || self.options.fontColor;
    for (var i = 0, len = oViewportData.length; i < len; i++) {
        if (oData = oViewportData[i]) {
            for (var j = 0; j < cols; ++j) {
                ColFontColor[i] = oData["colFontColor" + j] = self.options.fontColor;
            }
        }
    }

    self.IBCBMainEdit.css("color", self.options.fontColor);
    // dropdown list의 header font color
    self.IBCBDRL.find(".DRL_HEADER_TD_DIV").css("color", self.options.fontColor);
    // dropdown list의 body font color
    self.IBCBDRL.find(".DRL_CELL_TEXT").css("color", self.options.fontColor);
};
MultiComboFn.GetFontColor = function() {
    return Util.convertColor(this.options.fontColor);
};

//========================================================================================================================
// 선택 폰트 색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetSelectFontColor = function(sColor) {
    var self = this, ele;
    sColor = Util.string2color(sColor);

    self.options.selectFontColor =  Util.convertColor(_ib("<div>").css({color: sColor}).style("color")) || self.options.selectFontColor;

    if (_ib.isInteger(self.selectingItem)) {
        if (ele = self.viewport.options.data[self.selectingItem].ele) {
            ele.parent().length > 0 && ele.find(".DRL_CELL_TEXT").css({color: self.options.selectFontColor});
        }
    }
};
MultiComboFn.GetSelectFontColor = function() {
    return Util.convertColor(this.options.selectFontColor);
};

//========================================================================================================================
// hover 폰트 색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetHoverFontColor = function(sColor) {
    var self = this, ele;
    sColor = Util.string2color(sColor);

    self.options.hoverFontColor =  Util.convertColor(_ib("<div>").css({color: sColor}).style("color")) || self.options.hoverFontColor;

    if (_ib.isInteger(self.hoverItem)) {
        if (ele = self.viewport.options.data[self.hoverItem].ele) {
            ele.parent().length > 0 && ele.find(".DRL_CELL_TEXT").css({color: self.options.hoverFontColor});
        }
    }
};
MultiComboFn.GetHoverFontColor = function() {
    return Util.convertColor(this.options.hoverFontColor);
};



//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetFontColor.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetFontStyle.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 편집창의 폰트 볼드
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetEditFontBold = function(isBold) {
    var self = this;

    self.options.editFontBold = _ib("<div>").css({fontWeight: isBold ? "bold" : "normal"}).style("fontWeight") || self.options.editFontBold;

    self.IBCBMainEdit.css("fontWeight", self.options.editFontBold);
};
MultiComboFn.GetEditFontBold = function() {
    return this.options.editFontBold === "bold" ? true : false;
};

//========================================================================================================================
// 폰트명 얻기
// 폰트명 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetFontName = function(sFontName) {
    var self = this,
        viewportData = self.viewport.options.data,
        data;

    self.options.fontFamily = _ib("<div>").css("fontFamily", sFontName).style("fontFamily") || self.options.fontFamily;
    self.IBCBMainEdit.css("fontFamily", self.options.fontFamily);
    self.IBCBDRL.find(".DRL_HEADER_TD_DIV").css("fontFamily", self.options.fontFamily);     // dropdown list의 header font family
    for (var i = 0, len = viewportData.length; i < len; ++i) {
        if (data = viewportData[i]) {
            data.fontFamily = self.options.fontFamily;
        }
    }

    self._setDropDownWidth( self.options.isCalledSetColWidth ? true : false );
    self.viewport.refresh();
};
MultiComboFn.GetFontName = function() {
    return this.options.fontFamily;
};

//========================================================================================================================
// 폰트크기 얻기
// 폰트크기 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetFontSize = function(nFontSize) {
    var self = this,
        value,
        viewportData = self.viewport.options.data,
        data;

    nFontSize = _ib.unitSplitExp.exec(nFontSize);

    if (nFontSize) {
        if (nFontSize[1] && nFontSize[2]) {
            nFontSize = nFontSize[1] + nFontSize[2];
        } else {
            nFontSize = parseInt(nFontSize[1]);
        }

        value = self.IBCBMainEdit.value();
        self.IBCBMainEdit.value("");
        self.options.fontSize = nFontSize;

        self.IBCBMainEdit.css("fontSize", self.options.fontSize).style("fontSize");
        self.IBCBDRL.find(".DRL_HEADER_TD_DIV").css("fontSize", self.options.fontSize);     // dropdown list의 header fontSize

        for (var i = 0, len = viewportData.length; i < len; ++i) {
            if (data = viewportData[i]) {
                data.fontSize = self.options.fontSize;
            }
        }

        self._setDropDownWidth( self.options.isCalledSetColWidth ? true : false, true);
        self.IBCBMainEdit.value(value);
        self.viewport.refresh();
    }
};
MultiComboFn.GetFontSize = function() {
    return this.options.fontSize;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetFontStyle.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetImage.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.SetUseImage = function(useImage) {
    var self = this,
        options = self.options,
        id = options.id,
        isIE67 = IbmcTMP.isIE67,
        eles,
        viewportData = self.viewport.options.data,
        display = "display: ";

    options.useImage = useImage;
    if (useImage) {
        display = display + (isIE67 ? ";" : "table-cell;");
        self.IBCBDropDownHeadTBL.children(0).children(1).css("display", isIE67 ? "" : "table-cell");
        self.IBCBDropDownHeaderTBL.children(0).children(1).css("display", isIE67 ? "" : "table-cell");
        self.IBCBDropDownTBL.find("td[ibcb-name=" + self.options.id + "_CellTDIMG]").css("display", isIE67 ? "" : "table-cell");
    } else {
        display = display + "none;";
        self.IBCBDropDownHeadTBL.children(0).children(1).hide();
        self.IBCBDropDownHeaderTBL.children(0).children(1).hide();
        self.IBCBDropDownTBL.find("td[ibcb-name=" + self.options.id + "_CellTDIMG]").css("display", isIE67 ? "" : "table-cell");
    }

    for(var i = 0, len = viewportData.length; i < len; ++i) {
        viewportData[i].useImage = display;
    }
    self.viewport.refresh();
    self.reserveRefresh = true;
};

MultiComboFn.GetUseImage = function() {
    return this.options.useImage;
};

//========================================================================================================================
// 콤보 버튼 이미지 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.ComboBtnImage = function(sUrl) {
    this.IBCBMainBtn.css("backgroundImage", "url('" + sUrl + "')");
};

//========================================================================================================================
// 아이템 이미지 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.ItemImage = function(index, url) {
    var self = this,
        options = self.options,
        data,
        imageEleString = self._getImageEleString(url);

    if (data = self.viewport.options.data[index]) {
        data.imgUrl = imageEleString;
    }
    self.viewport.refresh();
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetImage.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetImeMode.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// ime-mode 속성 => auto : 기본값, 설정되지 않은 것과 동일, active : 활성화, 기본적으로 한글로 입력됨, inactive : 비활성화, 기본적으로 영문이 입력됨, disabled : IME를 사용할 수 없는 경우, 영문만 입력 가능
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetImeMode = function(sValue) {
    switch (sValue) {
        case "auto":
        case "active":
        case "inactive":
        case "disabled":
            this.options.imeMode = sValue;
            this.IBCBMainEdit[0].style.imeMode = sValue;
            break;
    }
};

MultiComboFn.GetImeMode = function() {
    return this.options.imeMode;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetImeMode.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetItemCheck.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 다중선택 일때 코드 또는 인덱스로 선택 선택해제 처리
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetItemCheck = function( index, bFlag, eventTrigging ) {
    var self = this,
        opts = self.options;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return;
    }

    self._itemSelect( index, bFlag, undefined, undefined, eventTrigging );
};

MultiComboFn.GetItemCheck = function(index) {
    var self = this,
        opts = self.options,
        selectedValue;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return;
    }

    selectedValue = opts.selectedValue;

    return self._itemSelect(index, undefined, undefined, function(data) {
        return selectedValue.indexOf(data) > -1 ? true : false;
    }, false);

};

//========================================================================================================================
// 전체선택시 보여주어야할 대체 텍스트
//========================================================================================================================
MultiComboFn.GetPlaceHolder4CheckAll = function() {
    return this.options.placeHolder4CheckAll;
};
MultiComboFn.SetPlaceHolder4CheckAll = function(v) {
    this.options.placeHolder4CheckAll = v;
};


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetItemCheck.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetItemHeight.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 항목 높이
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetItemHeight = function(nValue) {
    var self = this;

    nValue = parseInt(nValue);
    if (nValue <= 0) {
        return;
    }

    // 직접 ItemHeight를 수정하였기 때문에 더이상 ItemHeigt를 자동으로 수정하지 않는다.
    self.options.isCalledSetItemHeight = true;

    self.options.headerHeight = nValue;
    self.viewport.setRowHeight(self.options.itemHeight = nValue);
};

MultiComboFn.GetItemHeight = function() {
    return this.options.itemHeight;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetItemHeight.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetLineColor.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 드랍다운 안쪽선색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetLineColor = function(sColor) {
    var self = this,
        options = self.options,
        headerTd = self.IBCBDropDownHeaderTBLTR.children(),
        viewportData = self.viewport.options.data,
        data;

    sColor = Util.string2color(sColor);

    options.lineColor =  Util.convertColor(_ib("<div>").css({borderColor: sColor}).style("borderColor")) || options.lineColor;

    for (var i = 0, len = viewportData.length; i < len; ++i) {
        if (data = viewportData[i]) {
            data.lineColor = options.lineColor;
        }
    }
    self.viewport.refresh();
};
MultiComboFn.GetLineColor = function() {
    return Util.convertColor(this.options.lineColor);
};

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 외곽선색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetOutLineColor = function(sColor) {
    var self = this;
    sColor = Util.string2color(sColor);

    self.options.outLineColor =  Util.convertColor(_ib("<div>").css({borderColor: sColor}).style("borderColor")) || self.options.outLineColor;
    self.IBCBMainTbl.css("borderColor",self.options.outLineColor);
};
MultiComboFn.GetOutLineColor = function() {
    return Util.convertColor(this.options.outLineColor);
};

//========================================================================================================================
// 컨트롤 디자인 설정과 얻기 - 드랍다운 외곽선색
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetDropDownOutLineColor = function(sColor) {
    var self = this;
    sColor = Util.string2color(sColor);

    self.options.dropDownOutLineColor = Util.convertColor(_ib("<div>").css({borderColor: sColor}).style("borderColor")) || self.options.dropDownOutLineColor;

    self.IBCBDropDownHead.css("borderColor", self.options.dropDownOutLineColor);
    self.IBCBDropDownHeaderTBLTR.children().css("borderColor", self.options.dropDownOutLineColor);
    self.IBCBDropDownBodyScroll.css("borderColor", self.options.dropDownOutLineColor);
};

MultiComboFn.GetDropDownOutLineColor = function() {
    return Util.convertColor(this.options.dropDownOutLineColor);
};


//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetLineColor.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMaxLength.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// input에 사용자가 키보드로 입력 가능한 문자열 최대 길이 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetMaxLength = function() {
    return this.options.maxLength;
};
MultiComboFn.SetMaxLength = function(nValue) {
    var val = parseInt(nValue),
        self = this;

    if (isNaN(val) == true) {
        return ;
    }

    self.options.maxLength = self.IBCBMainEdit.attribute("maxLength", val).attribute("maxLength") || self.options.maxLength;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMaxLength.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMaxSelect.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 동시 최대 선택 가능 갯수 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetMaxSelect = function(maxSelect) { // multiSelect시 최대 선택 가능한 수
    maxSelect = parseInt(maxSelect);
    this.options.selectingCount = maxSelect;
};

MultiComboFn.GetMaxSelect = function() {
    return this.options.selectingCount;
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMaxSelect.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMultiSelect.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 멀티 선택 여부 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetMultiSelect = function(bMultiSelect) {
    var self = this,
        options = self.options,
        viewportData = self.viewport.options.data,
        display = "display: ";

    options.multiSelect = bMultiSelect;
    if (bMultiSelect) {
        display = display + (IbmcTMP.isIE67 ? ";" : "table-cell;");

        self.IBCBDropDownHeadTBL.children(0).children(0).css("display", IbmcTMP.isIE67 ? "" : "table-cell");
        self.IBCBDropDownHeaderTBL.children(0).children(0).css("display", IbmcTMP.isIE67 ? "" : "table-cell");
        self.IBCBDropDownTBL.find("td[ibcb-name=" + self.options.id + "_CellTDCHK]").css("display", IbmcTMP.isIE67 ? "" : "table-cell");
    } else {
        display = display + "none;";
        self.IBCBDropDownHeadTBL.children(0).children(0).hide();
        self.IBCBDropDownHeaderTBL.children(0).children(0).hide();
        self.IBCBDropDownTBL.find("td[ibcb-name=" + self.options.id + "_CellTDCHK]").hide();
    }

    for(var i = 0, len = viewportData.length; i < len; ++i) {
        viewportData[i].multiSelect = display;
    }

    self.RemoveAll(true);
    options.selectingCount = bMultiSelect ? options.rows : 1;

    self.viewport.refresh();
};

MultiComboFn.GetMultiSelect = function() {
    return this.options.multiSelect;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMultiSelect.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMultiSeparator.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 컬럼데이타 구분자
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetMultiSeparator = function() {
    return this.options.multiSeparator;
};
MultiComboFn.SetMultiSeparator = function(sFlag) {
    var self = this,
        value = self.IBCBMainEdit.value();

    self.IBCBMainEdit.value(value.replace(new RegExp("\\"+self.options.multiSeparator, "g"), sFlag));
    self.options.multiSeparator = sFlag;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetMultiSeparator.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetRequired.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// required 속성 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetRequired = function(bFlag, sReqValue) {
    var self = this,
        options = self.options;

    options.required = bFlag = (bFlag == true || bFlag == "true" ? true : false);

    if (bFlag) {
        self.IBCBMainTbl.children().children().children(0).addClass("MAINCTL_REQUIRED");
        self.element.attribute("required", sReqValue || options.id);
    } else {
        self.IBCBMainTbl.children().children().children(0).removeClass("MAINCTL_REQUIRED");
        self.element.removeAttribute("required");
    }
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetRequired.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetSaveName.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// SaveName 속성 설정/얻기 - submit 시 넘어가는 [id]_code 명을 다른 이름으로 변경하기 위한 메소드
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetSaveName = function() {
    return this.options.savename;
};
MultiComboFn.SetSaveName = function(sSaveName) {
    this.options.savename = sSaveName;
    this.element.attribute("name",sSaveName);   // 사용자가 입력한 control에 값 넣음
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetSaveName.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetSelect.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 선택항목 코드 얻기/ 설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetSelectCode = function(sCode, eventTrigging) {
    sCode === '-1' && (sCode = -1);
    this._itemSelect(sCode, true, 'code', undefined, eventTrigging);
};
MultiComboFn.GetSelectCode = function() {
    var self = this,
        opts = self.options, tmpData;

    // 20150306-김의연-#5108 초기화 이전에 GetSelectCode 호출시 오류 예외처리/2
    tmpData = self._getData('code');

    //console.log('%c' + self.id + '.GetSelectCode.tmpData: ' + tmpData, IbmcDEV.C4);
    if(tmpData != null) {
        tmpData = tmpData.join(opts.multiSeparator);
    } else {
        tmpData = '';
    }

    return tmpData;
};

//========================================================================================================================
// 선택항목 인덱스 얻기/설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetSelectIndex = function(nIdx, bEventTrigger) {
    //console.log('SetSelectIndex', 'nIdx:' + nIdx, 'bEventTrigger:' + bEventTrigger);
    this._itemSelect(nIdx, true, 'index', undefined, bEventTrigger);
};
MultiComboFn.GetSelectIndex = function() {
    var self = this,
        opts = self.options,
        NO_SELECTED_ITEM = -1,
        nReturnIdx;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        nReturnIdx = NO_SELECTED_ITEM;
    } else {
        nReturnIdx = self._getData('index').join(opts.multiSeparator) || NO_SELECTED_ITEM;
    }

    if(nReturnIdx === '') {
        nReturnIdx = NO_SELECTED_ITEM;
    }

    return nReturnIdx;
};

//========================================================================================================================
// 선택항목 글 얻기/설정
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetSelectText = function(sText, eventTrigging) {
    this._itemSelect(sText, true, 'text', undefined, eventTrigging);
};
MultiComboFn.GetSelectText = function() {
    var self = this,
        opts = self.options,
        sReturn = '';

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(opts.bInitialize) {
        sReturn = self._getData('text').join(opts.multiSeparator);
    }

    return sReturn;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetSelect.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetSyncRequest.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.SetSyncRequest = function(syncRequest) {
    this.options.syncRequest = (syncRequest == true ? true : false);
};
MultiComboFn.GetSyncRequest = function() {
    return this.options.syncRequest;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetSyncRequest.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetText.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 인덱스나 코드로 특정 컬럼의 글자 설정/ 얻기
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetText = function(index, col, sText) {
    var self = this,
        options = self.options,
        IBCBDropDownTBL = self.IBCBDropDownTBL,
        maxColWidth = options.maxColWidth,
        maxColWidthText = options.maxColWidthText,
        isCalDropDownWidth = false,     // dropdown list의 width값을 재계산 여부
        data,
        i, len,
        viewportData = self.viewport.options.data;

    if (options.cols - 1 < col) {
        return;
    }

    if (_ib.isInteger(index)) {
        if ((data = viewportData[index])) {
            isCalDropDownWidth = true;
            data["text" + col] = sText;
            data["text"] = self._getDelegateText(data);

            self._redefineMaxColWidth(IBCBDropDownTBL.children(), data, maxColWidth, maxColWidthText, col, sText);
            // self.viewport.render();
        }
    } else if (_ib.isString(index)) {
        for (i = 0, len = viewportData.length; i < len; ++i) {
            if ((data = viewportData[i]) && data.code === index) {
                isCalDropDownWidth = true;
                data["text" + col] = sText;
                data["text"] = self._getDelegateText(data);

                self._redefineMaxColWidth(IBCBDropDownTBL.children(), data, maxColWidth, maxColWidthText, col, sText);
                break;
            }
        }
    }
    isCalDropDownWidth && self._setDropDownWidth(true);
    self._outputMainEdit();     // edit box에 추력된 선택된 item의 대표 문자열 수정
    self.viewport.refresh();
};

MultiComboFn.GetText = function(index, col) {
    var self = this,
        opts = self.options,
        viewportData, data;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return '';
    }

    viewportData = self.viewport.options.data;

    if (_ib.isInteger(index)) {
        if (data = viewportData[index]) {
            return data['text' + col];
        }
    } else if (_ib.isString(index)) {
        for (var i = 0, len = viewportData.length; i < len; ++i) {
            if ((data = viewportData[i]) && data.code === index) {
                return data['text' + col];
            }
        }
    }
};


MultiComboFn.GetCode = function(index) {
    var self = this, opts = self.options, viewportData, data;
    if(!opts.bInitialize) {
        return "";
    }
    viewportData = self.viewport.options.data;
    if(_ib.isInteger(index)) {
        if(data = viewportData[index]) {
            return data["code"];
        }
    } else if(_ib.isString(index)) {
        for(var i = 0, len = viewportData.length; i < len; ++i) {
            if((data = viewportData[i]) && data.code === index) {
                return data["code"];
            }
        }
    }
};


//========================================================================================================================
// input에 표시되는 텍스트를 임의로 설정/ 얻기한다.
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetViewText = function() {
    var self = this,
        opts = self.options;

    // 20150402-김의연-# 초기화 이전에 호출시 리턴 (관련이슈:#5108)
    if(!opts.bInitialize) {
        return '';
    }

    return self.IBCBMainEdit.value();
};
MultiComboFn.SetViewText = function(sValue) {
    this.options.viewText = sValue
    this.IBCBMainEdit.value(sValue);
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetText.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetTheme.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.SetTheme = TempFNC.setTheme;

MultiComboFn.GetTheme = function() {
    var self = this;
    return self.options.themeName || "Main";
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetTheme.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetTitle.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 헤더 제목 넣기
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetTitle = function(sText) {
    var self = this,
        IBCBDropDownHeaderTBLTR = self.IBCBDropDownHeaderTBLTR,
        options = self.options,
        titles = sText.split(options.fixMultiSeparator),
        fixCols = options.fixCols,      // check, imgage td
        maxColWidth = options.maxColWidth,
        maxColWidthText = options.maxColWidthText,
        titleWidth,
        isCalDropDownWidth = false,     // dropdown list의 width값을 재계산 여부
        tr = self.IBCBDropDownTBL.children(),
        ele,
        obj = {};

    tr[tr.length] = IBCBDropDownHeaderTBLTR[0];

    for (var i = 0, title; title = titles[i]; i++) {
        if ((ele = IBCBDropDownHeaderTBLTR.children(fixCols + i)) && ele.length > 0) {
            isCalDropDownWidth = true;
            obj["text" + i] = ele.children().text()
            self._redefineMaxColWidth(tr, obj, maxColWidth, maxColWidthText, i, title, true);

            ele.children().text(title);
        } else {
            break;
        }
    }

    isCalDropDownWidth && self._setDropDownWidth(true);
};

//========================================================================================================================
// 타이틀 글자 색상
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetTitleFontColor = function(sFontColor) {
    var self = this;

    sFontColor = Util.string2color(sFontColor);
    self.options.headFontColor =  Util.convertColor(_ib("<div>").css({color: sFontColor}).style("color")) || self.options.headFontColor;
    self.IBCBDRL.find(".DRL_HEADER_TD_DIV").css("color", self.options.headFontColor);       // dropdown list의 header font color
    // 20150429-김의연-# SetTitleFontColor 오류수정
    //self.IBCBDropDownHeaderTBLTR.children().css("color", self.options.headFontColor);
    self.IBCBDropDownHeaderTBLTR.css("color", self.options.headFontColor);
};
MultiComboFn.GetTitleFontColor = function() {
    return Util.convertColor(this.options.headFontColor);
};

//========================================================================================================================
// 타이틀 배경 색상
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetTitleBackColor = function(sColor) {
    var self = this;

    sColor = Util.string2color(sColor);
    self.options.titleColor =  Util.convertColor(_ib("<div>").css({backgroundColor: sColor}).style("backgroundColor")) || self.options.titleColor;
    self.IBCBDropDownHead.css("backgroundColor", self.options.titleColor);
};
MultiComboFn.GetTitleBackColor = function() {
    return Util.convertColor(this.options.titleColor);
};

//========================================================================================================================
// 제목 표시 여부
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetTitleVisible = function(titleVisible) {  // dropdown list의 제목 표시 여부
    this.options.titleVisible = titleVisible ? true : false;
};

MultiComboFn.GetTitleVisible = function() {
    return this.options.titleVisible;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetTitle.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetUseAutoComplete.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 콤보 inputbox에서 편집을 하여 dropdown list의 filtering 여부
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetUseAutoComplete = function(isUseAutoComplete, bIgnoreUpperCase) {
    var self = this,
        opts = self.options;
        //bUseAutoComplete;

    if(isUseAutoComplete == null) {
        isUseAutoComplete = false;
    }
    opts.useAutoComplete = !!isUseAutoComplete;

    // 20150327-김의연-#5121 UseAutoComplete 사용시 콤보리스트-높이설정 오류수정
    //if(isUseAutoComplete) {
    //    opts.oriDropHeight = opts.dropHeight;
    //} else {
    //    opts.dropHeight = opts.oriDropHeight;
    //}

    // 20150302-김의연-#5091 UseAutoComplete Ignore UpperCase
    if(bIgnoreUpperCase == null) {
        bIgnoreUpperCase = false;
    }
    opts.useAutoCompleteIUC = !!bIgnoreUpperCase;
};

MultiComboFn.GetUseAutoComplete = function() {
    return this.options.useAutoComplete;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetUseAutoComplete.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetUseEdit.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 편집한 글자를 유지할지 여부를 설정하거나 확인한다. multiSelect false일 때만 동작가능함.
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetUseEdit = function() {
    return this.options.useEdit;
};
MultiComboFn.SetUseEdit = function(isUseEdit) {
    this.options.useEdit = isUseEdit ? true : false;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetUseEdit.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetVisible.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

//========================================================================================================================
// 보임 여부
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.SetVisible = function(bFlag) {
    var self = this;

    if (bFlag) {
        self.IBCBMainDiv.show();
    } else {
        self.IBCBMainDiv.hide();
        self.dropdownListFlag = true;   // dropdown list show/hide 초기화
        self._dropdownProcess(false);
    }
    this.options.visible = bFlag;
};

MultiComboFn.GetVisible = function() {
    return this.options.visible;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetVisible.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SmartScrollLoad.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.SmartScrollLoad = function () {
    var self = this,
        isTouch= true;      // iScrol사용시 touch event에만 동작 flag

    self.IBCBMainEdit.attribute("readonly",true);   // input 창 사용안함.
    self.options.fixedchkwidth = 25;    // smartdevice의 checkbox 크기 문제로 20 -> 25로 변경
    self.options.fixedimgwidth = 26; // smartdevice의 img 크기 문제로 21 -> 26로 변경

    self.myScroll = new iScroll(self.IBCBDropDownBodyScroll[0], {
        fadeScrollbar: true,
        hideScrollbar: true,
        hScroll: false,
        onTouchEnd: function(e) {
            var tr,
                data,
                isAutoCheck;
            e.stopPropagation();
            e.preventDefault();

            if (isTouch && (tr = _ib(e.target).parents("tr[ibcb-name]"))[0]) {
                isAutoCheck = true;
                data = tr.data("cell_data");

                if (self.options.multiSelect) {
                    self._selectItem(data, tr, isAutoCheck, undefined, true);
                } else {
                    self._selectItem(data,undefined, undefined, undefined, true);
                    self._dropdownProcess(false);
                    self.dropdownListFlag = true;
                }
            }

            isTouch = true;
        },
        onScrollMove: function(e) {
            isTouch = false;
        }
    });
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SmartScrollLoad.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/ValidChar.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.ValidChar = function ( option1, option2 ) {
    var self = this,
        r1, r2, rText, regExp;

    option1 != null && (option1 += "");
    option2 != null && (option2 += "");

    if ( r1 = IbmcTMP.RText1[ option1 ] ) {
        rText = r1.pattern;

        if ( r2 = IbmcTMP.RText2[ option2 ] ) {
            rText += "|" + r2.pattern;
        }

        if ( _ib.Browser.name === "msie" ) {
            if ( option1 != "4" ) {
                self.SetImeMode( "disabled" );
            } else {
                self.SetImeMode( "auto" );
            }
        }

        if ( self.options.multiSelect ) {
            rText += "|[" + self.options.multiSeparator + "]";
        }

        regExp = new RegExp( "^(" + rText + ")*$", r1.option );
    }
    self.validChar1 = option1;
    self.validChar2 = option2;

    self.rText = regExp;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/ValidChar.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetAllowEvent4CheckAll.js
/**
 *  on 2015-10-20.
 */

//========================================================================================================================
//
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetAllowEvent4CheckAll = function() {
    return this.options.AllowEvent4CheckAll;
};
MultiComboFn.SetAllowEvent4CheckAll = function(AllowEvent4CheckAll) {
    this.options.AllowEvent4CheckAll = AllowEvent4CheckAll ? true : false;
};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetAllowEvent4CheckAll.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetPrependIE7.js
/**
 *  on 2015-10-23
 */

//========================================================================================================================
//
//------------------------------------------------------------------------------------------------------------------------
//========================================================================================================================
MultiComboFn.GetPrependIE7 = function() {
    return this.options.prependIE7;
};
MultiComboFn.SetPrependIE7 = function(value) {

    var self;
    self = this;
    if (value === false) {
        value = false;
    } else if (value === true) {
        value = true;
    }
    if (!_ib.isBoolean(value)) {
        return;
    }
    return self.options.prependIE7 = value;

};
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/SetPrependIE7.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/Version.js
/**
 * Created by Euiyeon on 2015-03-19.
 */

MultiComboFn.Version = function() {
    return IbmcCFG.Version;
};

//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/core/service/Version.js
//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ START_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/IBMultiComboMain.js
/**
 * IBMultiCombo Main Function
 * MultiCombo --> MultiComboFn(prototype) --> IBMultiComboMain
 */
(function IbmcMain(global, iBLib) {

    MultiCombo.fn = MultiCombo.prototype = MultiComboFn;

    iBLib.ui.plugin(MultiCombo);

    // 멀티콤보 생성 사용자 API
    global.__createIBMultiCombo = function(sName, oWidth, oHeight, nCols, nShowCol, sHtml) {
        var retObj, tmpObj,
            elem  = null,
            bInit = false;

        if (iBLib.isString(sName) && iBLib.isObject(oWidth)) {
            oWidth.init = true;
            retObj = iBLib('#' + sName).multicombo(oWidth).getMulticombo();

        } else if(iBLib.isString(sName)) {
            elem = document.getElementById(sName);
            if(iBLib.isElement(elem)) {
                bInit = true;
            } else {
                // document.write 하게되면 document.write 작업이 끝난뒤
                // document.getElement 로 특정 element를 select 할 수 있는가?
                document.write('<input type="text" id="' + sName + '" />');
                elem = '#' + sName;
            }

            tmpObj = new MultiCombo(elem, {
                init   : bInit,
                width  : oWidth,
                height : oHeight,
                cols   : nCols,
                showCol: nShowCol || 0,
                wrappingHtml  : sHtml,
                useSelectedBox: false
            });
            tmpObj.element.data('multicombo', tmpObj);
            retObj = tmpObj;
        }

        return retObj;
    };

    /*======================================================*/
    // css 파일 및 js 파일 동적 include 처리
    /*======================================================*/
    IbmcCFG.__init();

    TempFNC.setTheme('Main', true);

    /*======================================================*/
    //화면 resize 시 콤보 리스트 닫히도록 콤보 에디트 창에 blur 호출해줌 2013-02-21
    //(에디트 창에 포커스 남아 있으면 다시 펼쳐지지 않으니 콤보 리스트 닫는 함수 바로 호출하지 않고, 포커스 빠지도록 blur 호출해줌)
    /*======================================================*/
    iBLib(global).addEvent("resize,click,blur", function (e) {
        var target, aDDList, i, len;

        aDDList = IbmcTMP.DDList.get();
        for( i = 0, len = aDDList.length; i < len; ++i ) {
            target = iBLib( e.target ).parents("." + aDDList[ i ].options.themeName + "MAINCTL_DIV,." + aDDList[ i ].options.themeName + "MAINCTL_DRL_DIV");
            if ( aDDList[ i ].multiComboElements[ 0 ] !== target[ 0 ] && aDDList[ i ].multiComboListElements[ 0 ] !== target[ 0 ] ) {
                aDDList[ i ].IBCBDRL.hide();
            }
        }
    });

    /*======================================================*/
    // 스마트 기기에서는 blur 이벤트 핸들링을 element에 저장해둔 multicombo control로 처리함.
    /*======================================================*/
    iBLib.isSmartDevice && iBLib(global).addEvent("touchstart", function(e) {
        var mCombo, id;
        if (IbmcCFG.ActiveElement) {
            if (mCombo = IbmcCFG.ActiveElement.children(1).data("multicombo")) {
                id = mCombo.options.id;

                if (!iBLib(e.target).parents("div[ibcb-name=" + id + "_DRL],div[ibcb-name=" + id + "]")[0]) {
                    // dropdown list show/hide 초기화
                    mCombo.dropdownListFlag = true;
                    mCombo._dropdownProcess(false, true);
                }
            }
        }
    });
})(window, _ib);



//[DoNotDelete]■■■■■■■■■■[IBStar40]■■■■■■■■■■ END_OF_D:\Work\IBSheet7\IBMultiCombo\01_src\main/IBMultiComboMain.js

})(window, document);